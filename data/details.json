{
  "Classes & Objects": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Class:</b> The blueprint or template. It defines the structure (attributes) and capabilities (methods) common to all objects of that type. It does not occupy memory for data (mostly) until instantiated.</li><li><b>Object:</b> The instance of the class. It is a concrete entity created based on the blueprint that occupies memory and holds specific data values.</li></ul><br><p><b>Why use them?</b></p><ul><li><b>Modeling:</b> To represent real-world entities (e.g., <code>User</code>, <code>Payment</code>, <code>Button</code>) in code.</li><li><b>Encapsulation:</b> To bundle data (state) and methods (behavior) together, protecting the internal state from unauthorized access.</li><li><b>Reusability:</b> You write the code once (Class) and create as many instances (Objects) as needed.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>State (Fields/Attributes):</b> Variables that hold data (e.g., color, speed).</li><li><b>Behavior (Methods):</b> Functions that operate on the state (e.g., <code>accelerate()</code>, <code>brake()</code>).</li><li><b>Identity:</b> Every object has a unique identity (memory address), even if two objects have the exact same data values.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Blueprint (Class)\npublic class Car {\n    // State\n    String color;\n    int speed;\n\n    // Constructor (Initialization)\n    public Car(String color) {\n        this.color = color;\n        this.speed = 0;\n    }\n\n    // Behavior\n    public void accelerate() {\n        this.speed += 10;\n    }\n}\n\n// The Usage\npublic class Main {\n    public static void main(String[] args) {\n        // 'c1' is a reference variable, 'new Car()' creates the Object in Heap\n        Car c1 = new Car(\"Red\"); \n        c1.accelerate(); \n        \n        Car c2 = new Car(\"Blue\"); // Distinct identity from c1\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Memory Allocation:</b><ul><li><b>Class:</b> Loaded into Method Area (Metaspace in modern Java).</li><li><b>Object:</b> Allocated on the <b>Heap</b>.</li><li><b>Reference:</b> The variable (e.g., <code>c1</code>) is stored on the <b>Stack</b> and points to the Heap address.</li></ul></li><li><b>The <code>this</code> keyword:</b> Refers to the current object instance. It resolves ambiguity between class fields and parameters.</li><li><b>Object Equality:</b><ul><li><code>==</code> checks if two references point to the same memory address (<b>Identity</b>).</li><li><code>.equals()</code> (if overridden) checks if two objects have the same content (<b>State</b>).</li></ul></li><li><b>Lifecycle:</b> Objects are created via constructors and destroyed by the Garbage Collector (GC) when they are no longer reachable.</li><li><b>Anemic vs. Rich Domain Models:</b><ul><li><b>Anemic:</b> Classes only have data (getters/setters) and no logic. (Common in DTOs).</li><li><b>Rich:</b> Classes contain both data and the business logic that modifies that data. (Preferred in good OOP/LLD).</li></ul></li></ul>"
      }
    ]
  },
  "Interfaces": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>An Interface is a contract:</b> It defines <i>what</i> a class can do, without specifying <i>how</i> it does it. It is a collection of abstract methods (mostly) and constants that a class must implement.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Abstraction:</b> It hides implementation details and exposes only the capability.</li><li><b>Decoupling:</b> You can change the implementation without changing the code that uses it (<i>Dependency Inversion Principle</i>).</li><li><b>Multiple Inheritance:</b> Java classes cannot extend multiple classes, but they can implement multiple interfaces.</li><li><b>Polymorphism:</b> You can treat different objects (e.g., <code>Dog</code>, <code>Cat</code>) as the same type (e.g., <code>Animal</code>) if they implement the same interface.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Methods:</b> Methods without a body (implicitly <code>public abstract</code>).</li><li><b>Constants:</b> Variables are implicitly <code>public static final</code>.</li><li><b>Java 8+ Evolution:</b><ul><li><b>Default Methods:</b> Methods with a body (using <code>default</code> keyword) to allow adding new methods without breaking existing implementations.</li><li><b>Static Methods:</b> Utility methods related to the interface.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Contract\ninterface PaymentProcessor {\n    void processPayment(double amount); // Abstract method\n    \n    // Java 8 Default method (Backward compatibility)\n    default void logTransaction() {\n        System.out.println(\"Logging tx...\");\n    }\n}\n\n// The Implementation A\nclass PaypalProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via PayPal: \" + amount);\n    }\n}\n\n// The Implementation B\nclass StripeProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via Stripe: \" + amount);\n    }\n}\n\n// Usage (Polymorphism)\nclass CheckoutService {\n    // We program to the Interface, not the implementation\n    PaymentProcessor processor; \n\n    public CheckoutService(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>\"Program to an Interface, not an Implementation\":</b> This is a golden rule in design patterns. Always use the interface type for variable references (e.g., <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>).</li><li><b>Interface Segregation Principle (ISP):</b> Clients should not be forced to depend on interfaces they do not use. It's better to have many specific interfaces (e.g., <code>Readable</code>, <code>Writable</code>) than one general-purpose interface (e.g., <code>FileHandler</code>).</li><li><b>Interface vs. Abstract Class:</b><ul><li><b>Interface:</b> Defines \"Can-Do\" capability (e.g., <code>Runnable</code>, <code>Serializable</code>). Supports multiple implementations.</li><li><b>Abstract Class:</b> Defines \"Is-A\" relationship (e.g., <code>Vehicle</code>, <code>Mammal</code>). Shares code/state among related classes.</li></ul></li><li><b>Marker Interfaces:</b> Interfaces with no methods (e.g., <code>Serializable</code>, <code>Cloneable</code>). They provide metadata to the compiler or runtime that the class is special.</li><li><b>Functional Interface:</b> An interface with exactly one abstract method. Used heavily in Lambda expressions (e.g., <code>Runnable</code>, <code>Comparator</code>).</li></ul>"
      }
    ]
  },
  "Inheritance": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Inheritance</b> is the mechanism by which one class (Child/Subclass) acquires the properties (fields) and behaviors (methods) of another class (Parent/Superclass). It establishes an \"Is-A\" relationship.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Code Reusability:</b> Write common code once in the parent class and reuse it in multiple child classes.</li><li><b>Extensibility:</b> You can extend existing logic without modifying the original class (<i>Open/Closed Principle</i>).</li><li><b>Method Overriding:</b> Child classes can provide a specific implementation of a method already defined in the parent class.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Superclass (Parent/Base):</b> The class whose features are inherited.</li><li><b>Subclass (Child/Derived):</b> The class that inherits the other class.</li><li><b><code>extends</code> Keyword:</b> Used in Java to inherit from a class.</li><li><b><code>super</code> Keyword:</b> Used to access members (methods/constructors) of the immediate parent class.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Parent Class\nclass Vehicle {\n    protected String brand = \"Ford\"; // protected: accessible to subclasses\n    public void honk() {\n        System.out.println(\"Tuut, tuut!\");\n    }\n}\n\n// Child Class\nclass Car extends Vehicle {\n    private String modelName = \"Mustang\";\n    \n    // Overriding parent behavior\n    @Override \n    public void honk() {\n        super.honk(); // Calls parent's honk first\n        System.out.println(\"Honk from \" + modelName);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.honk(); // OUTPUT: Tuut, tuut! \\n Honk from Mustang\n        // myCar.brand is accessible here only if Main is in same package or subclass\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Diamond Problem:</b> Java does not support Multiple Inheritance with Classes (inheriting from two classes that have the same method). It solves this via Interfaces.</li><li><b>Liskov Substitution Principle (LSP):</b> A child class must be substitutable for its parent class without breaking the application. If <code>Dog</code> extends <code>Animal</code>, you should be able to use <code>Dog</code> anywhere <code>Animal</code> is expected.</li><li><b>Constructors are NOT inherited:</b> But the child class constructor must call the parent constructor (implicitly or explicitly via <code>super()</code>) as the first statement.</li><li><b><code>final</code> Class:</b> If a class is marked <code>final</code>, it cannot be inherited (e.g., <code>String</code> class in Java).</li><li><b>Composition over Inheritance:</b> In modern LLD, prefer Composition (\"Has-A\") over Inheritance (\"Is-A\") if the relationship is not strictly hierarchical. Inheritance creates tight coupling; composition is more flexible.</li></ul>"
      }
    ]
  },
  "Polymorphism": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Polymorphism</b> (Greek for \"many forms\") is the ability of a single interface or method name to support different underlying forms (types or implementations). It allows objects of different classes to be treated as objects of a common superclass.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Flexibility:</b> You can write code that works with a general type (e.g., <code>Shape</code>) and it will automatically work with any new specific types you add later (e.g., <code>Pentagon</code>) without changing the code.</li><li><b>Clean Code:</b> Reduces <code>if-else</code> or <code>switch</code> statements checking for types.</li><li><b>Decoupling:</b> The caller doesn't need to know the specific class of the object it's working with.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Compile-time Polymorphism (Static Binding):</b><ul><li>Achieved via <b>Method Overloading</b>.</li><li>Same method name, different parameters (signature) within the same class.</li><li>Resolved by the compiler.</li></ul></li><li><b>Runtime Polymorphism (Dynamic Binding):</b><ul><li>Achieved via <b>Method Overriding</b>.</li><li>Same method name and parameters in a Parent and Child class.</li><li>Resolved at runtime based on the actual object created.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// 1. Compile-time (Overloading)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n\n// 2. Runtime (Overriding)\nclass Animal {\n    void speak() { System.out.println(\"Animal makes a sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void speak() { System.out.println(\"Woof\"); }\n}\n\nclass Cat extends Animal {\n    @Override\n    void speak() { System.out.println(\"Meow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Upcasting: Parent Reference -> Child Object\n        Animal myPet = new Dog(); \n        \n        // The method called depends on the OBJECT (Dog), not the reference (Animal)\n        myPet.speak(); // Output: Woof\n        \n        myPet = new Cat();\n        myPet.speak(); // Output: Meow\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Upcasting:</b> Assigning a Child object to a Parent reference (e.g., <code>Animal a = new Dog()</code>). This is safe and implicit.</li><li><b>Downcasting:</b> Assigning a Parent reference back to a Child reference (e.g., <code>Dog d = (Dog) a</code>). This requires an explicit cast and an <code>instanceof</code> check to avoid <code>ClassCastException</code>.</li><li><b>Dynamic Method Dispatch:</b> This is the mechanism Java uses at runtime to figure out which version of an overridden method to call.</li><li><b>Static methods are NOT polymorphic:</b> If you define a static method with the same name in Parent and Child, the Child hides the Parent's method (<i>Method Hiding</i>), but it does not override it. The method called depends on the reference type, not the object.</li><li><b>Fields are NOT polymorphic:</b> If a Child defines a variable with the same name as the Parent, the variable accessed depends on the reference type.</li></ul>"
      }
    ]
  },
  "Abstraction": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstraction</b> is the process of hiding the complex implementation details and showing only the essential features of an object. It focuses on <i>what</i> an object does instead of <i>how</i> it does it.</li><li><b>Analogy:</b> Think of a car. You use the steering wheel and pedals (<b>Abstraction/Interface</b>) to drive. You don't need to know how the fuel injection or combustion engine (<b>Implementation</b>) works to operate it.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Reduces Complexity:</b> It simplifies the interaction for the user (or client code) by filtering out unnecessary details.</li><li><b>Security:</b> Hides internal data and logic that shouldn't be touched directly.</li><li><b>Maintainability:</b> You can change the complex internal logic (e.g., upgrade the engine) without changing the simple interface (the steering wheel), so client code doesn't break.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated on its own (0-100% abstraction). It can have both abstract methods (no body) and concrete methods (with body).</li><li><b>Interface:</b> A pure template (100% abstraction prior to Java 8). Defines only method signatures.</li><li><b>Access Modifiers:</b> Keywords like <code>private</code> and <code>protected</code> help enforce abstraction by hiding internal members.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Abstract Class - partial abstraction\nabstract class BankService {\n    // Abstract method: Logic hidden, must be defined by child\n    abstract void calculateInterest(); \n\n    // Concrete method: Common logic shared by all\n    void login() {\n        System.out.println(\"User Logged in\");\n    }\n}\n\nclass SavingsAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 4%\");\n    }\n}\n\nclass CurrentAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 0%\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // BankService b = new BankService(); // ERROR: Cannot instantiate abstract class\n        \n        BankService myBank = new SavingsAccount();\n        myBank.login();             // Shared logic\n        myBank.calculateInterest(); // Specific logic\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation</b> is about hiding data (bundling data + methods).</li><li><b>Abstraction</b> is about hiding implementation complexity (design level).</li></ul></li><li><b>\"Is-A\" Relationship:</b> Abstract classes are still classes. Use them when child classes share a lot of code but also need specific behavior (e.g., <code>Bird</code> is an abstract class, <code>Sparrow</code> and <code>Penguin</code> extend it).</li><li><b>The 100% Rule:</b> Before Java 8, Interfaces provided 100% abstraction. Now, with default methods, this line is slightly blurred, but conceptually they are still pure contracts.</li><li><b>Design Decision:</b> If you need to add a new method in the future:<ul><li><b>Abstract Class:</b> You can add a concrete method with a default implementation, and existing child classes will work fine.</li><li><b>Interface:</b> Adding a new abstract method breaks all implementing classes (unless you use a <code>default</code> method).</li></ul></li></ul>"
      }
    ]
  },
  "Encapsulation": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Encapsulation</b> is the bundling of data (variables) and methods (functions) that operate on that data into a single unit (Class). Crucially, it involves restricting direct access to some of an object's components, often referred to as \"<i>Data Hiding</i>\".</li><li><b>Analogy:</b> Think of a medical capsule: The medicine (data) is enclosed inside the capsule shell (methods), preventing it from being consumed directly or contaminated.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Control & Validation:</b> You can validate data before assigning it. For example, preventing a generic age variable from being set to -5.</li><li><b>Security:</b> Hides internal implementation details and protects the object's integrity.</li><li><b>Flexibility (Loose Coupling):</b> You can change the internal data structure (e.g., changing a variable from <code>String</code> to <code>StringBuilder</code>) without breaking the code that uses the class, as long as the public methods remain the same.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Access Modifiers:</b> The tools used to enforce encapsulation.<ul><li><code>private</code>: Visible only within the class (Best for state).</li><li><code>protected</code>: Visible to package + subclasses.</li><li><code>public</code>: Visible to everyone (Best for methods/interface).</li><li><code>(default/package-private)</code>: Visible only within the package.</li></ul></li><li><b>Getters (Accessors):</b> Public methods to read private data.</li><li><b>Setters (Mutators):</b> Public methods to modify private data (usually with validation logic).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class User {\n    // 1. Data is Private (Hidden)\n    private String username;\n    private int age;\n\n    // 2. Public Constructor\n    public User(String username, int age) {\n        this.username = username;\n        setAge(age); // Use setter to enforce logic even during creation\n    }\n\n    // 3. Public Getters (Read-only access)\n    public String getUsername() {\n        return username;\n    }\n\n    // 4. Public Setters (Controlled Write access)\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age provided\");\n            // Optionally throw exception\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        User u = new User(\"John\", 25);\n        // u.age = -5; // ERROR: usage of private field\n        u.setAge(-5);  // Output: Invalid age provided. Data remains safe.\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Getters/Setters are NOT mandatory:</b> Pure encapsulation isn't just generating getters and setters for every field (that makes it anemic). True encapsulation often involves methods that do things (e.g., <code>activateAccount()</code> instead of <code>setStatus(\"Active\")</code>).</li><li><b>Immutability:</b> A powerful form of encapsulation. If you make all fields <code>private final</code> and provide no setters, the object state cannot change once created. This makes the code thread-safe and predictable (e.g., <code>String</code> class).</li><li><b>\"Tell, Don't Ask\":</b> A design principle related to encapsulation. Instead of asking an object for its data to perform a calculation (if <code>user.getAge() > 18</code>), tell the object to do it (if <code>user.isAdult()</code>).</li><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation:</b> Hiding Information (State).</li><li><b>Abstraction:</b> Hiding Complexity (Implementation).</li></ul></li></ul>"
      }
    ]
  },
  "Access Modifiers": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Access modifiers</b> are keywords that define the scope and visibility of a class, constructor, variable, method, or data member. They determine who can see and use a specific part of your code.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Encapsulation:</b> They are the primary tool to implement encapsulation (hiding internal state).</li><li><b>Security:</b> Prevents sensitive data or critical logic from being tampered with by external classes.</li><li><b>Maintainability:</b> By restricting access, you limit the \"blast radius\" of changes. If a method is private, you can change it freely knowing no other class relies on it.</li></ul><br><p><b>Key Components (The 4 Levels):</b></p><ul><li><b>Private (<code>private</code>):</b> Only within the Same Class. <br><i>Analogy: Your diary. Only you can read it.</i></li><li><b>Default (none):</b> Within the Same Package only. (Package-Private). <br><i>Analogy: Family fridge. Accessible to everyone in the house.</i></li><li><b>Protected (<code>protected</code>):</b> Same Package + Subclasses (even in different packages). <br><i>Analogy: Family inheritance. Kids get it even if they move out.</i></li><li><b>Public (<code>public</code>):</b> Everywhere (Global). <br><i>Analogy: A billboard. Visible to the world.</i></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// PACKAGE A\npackage com.test.a;\npublic class Parent {\n    public int publicVar = 1;\n    protected int protectedVar = 2;\n    int defaultVar = 3;   // No keyword = Default\n    private int privateVar = 4;\n    \n    public void show() {\n        // All accessible here\n        System.out.println(privateVar); \n    }\n}\n\n// PACKAGE B\npackage com.test.b;\nimport com.test.a.Parent;\n\nclass Child extends Parent {\n    void accessTest() {\n        System.out.println(publicVar);    // OK\n        System.out.println(protectedVar); // OK (Child Class)\n        // System.out.println(defaultVar);   // ERROR: Diff Package\n        // System.out.println(privateVar);   // ERROR: Private\n    }\n}\n\nclass Stranger {\n    void accessTest() {\n        Parent p = new Parent();\n        System.out.println(p.publicVar);  // OK\n        // System.out.println(p.protectedVar); // ERROR: Not a child\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Principle of Least Privilege:</b> Always start with the most restrictive modifier (<code>private</code>) and open it up (<code>protected</code> -> <code>public</code>) only when absolutely necessary. This reduces coupling.</li><li><b>Class vs. Member:</b><ul><li>Top-level classes can only be <code>public</code> or <code>default</code> (package-private). They cannot be <code>private</code> or <code>protected</code>.</li><li>Nested/Inner classes can be all four.</li></ul></li><li><b>Method Overriding Rule:</b> When overriding a method in a child class, you cannot reduce the visibility. If Parent is <code>protected</code>, Child must be <code>protected</code> or <code>public</code>. It cannot be <code>private</code>.</li><li><b>Interface Members:</b><ul><li>Variables in interfaces are implicitly <code>public static final</code>.</li><li>Methods in interfaces are implicitly <code>public</code> (unless <code>private</code> in Java 9+).</li></ul></li></ul>"
      }
    ]
  },
  "Object Lifecycle": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>The Object Lifecycle</b> describes the series of states an object goes through from its <b>Creation</b> (instantiation), to its <b>Usage</b> (performing actions), and finally to its <b>Destruction</b> (garbage collection/memory deallocation).</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Memory Management:</b> Understanding the lifecycle helps prevent <i>Memory Leaks</i> (objects staying in memory when no longer needed).</li><li><b>Resource Management:</b> Ensures external resources (file handles, database connections) are opened and closed correctly.</li><li><b>Performance:</b> Knowing how objects are promoted (e.g., from Young to Old Generation in Java) helps in tuning application performance.</li></ul><br><p><b>Key Components (The 3 Stages):</b></p><ul><li><b>Creation (Initialization):</b><ul><li><b>Loading:</b> The <code>.class</code> file is loaded into the Method Area.</li><li><b>Allocation:</b> Memory is allocated on the <b>Heap</b> for the object.</li><li><b>Initialization:</b> The constructor is called to initialize the state.</li></ul></li><li><b>Usage (Live):</b> The object is referenced by a variable on the <b>Stack</b> or by another live object. It actively performs tasks.</li><li><b>Destruction (Death):</b><ul><li><b>Unreachable:</b> All references to the object are removed (e.g., set to <code>null</code> or out of scope).</li><li><b>Garbage Collection (GC):</b> The GC identifies the object as unreachable and reclaims the memory.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "class Report {\n    String data;\n    \n    public Report() {\n        System.out.println(\"1. Object Created (Constructor)\");\n    }\n    \n    public void print() {\n        System.out.println(\"2. Object in Use\");\n    }\n\n    // Deprecated in modern Java, but good for understanding lifecycle concepts\n    @Override\n    protected void finalize() { \n        System.out.println(\"3. Object Destroyed/GC'd\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Step 1: Creation\n        Report r = new Report(); \n        \n        // Step 2: Usage\n        r.print();\n        \n        // Step 3: Making Eligible for Destruction\n        r = null; // Reference broken. Object is now \"Unreachable\"\n        \n        // Requesting GC (Note: This is just a request, not a command)\n        System.gc(); \n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Stack vs. Heap:</b><ul><li><b>Local Variables</b> (references) live on the <b>Stack</b>.</li><li><b>Objects</b> (actual data) live on the <b>Heap</b>.</li><li>When a stack frame (method) ends, the references pop off, leaving the heap objects eligible for GC if no other references exist.</li></ul></li><li><b>Reachability:</b> An object is only garbage collected if there is no chain of references leading to it from a \"GC Root\" (active thread, static variable, local variable).</li><li><b>Generational GC:</b><ul><li><b>Eden Space:</b> Where new objects are born.</li><li><b>Survivor Space:</b> Objects that survive a GC cycle.</li><li><b>Old/Tenured Gen:</b> Long-lived objects (caches, singletons) move here.</li></ul></li><li><b><code>finalize()</code> is Deprecated:</b> Never rely on <code>finalize()</code> for cleanup (it's unpredictable). Use <code>try-with-resources</code> (<code>AutoCloseable</code> interface) for deterministic cleanup of resources like streams or connections.</li><li><b>Static Variables:</b> These live for the entire life of the application (Class Lifecycle), effectively acting as GC Roots. Be carefulâ€”they are a common source of memory leaks.</li></ul>"
      }
    ]
  },
  "Stack vs Heap": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p>These are the two main areas of memory used by a program.<br><ul><li><b>Stack:</b> A structured, temporary scratchpad for method execution. It stores local primitives and reference variables. It follows the <b>LIFO</b> (Last-In, First-Out) order.</li><li><b>Heap:</b> A large, unstructured pool for dynamic data storage. It stores actual <b>Objects</b> and JRE classes. Memory here is managed by the Garbage Collector.</li></ul><br><p><b>Why use them? (The Roles)</b></p><ul><li><b>Stack (Control Flow):</b> Used to track \"where am I in the code?\". It manages function calls, parameters, and return addresses automatically. When a method finishes, its block is instantly cleared.</li><li><b>Heap (Data Persistence):</b> Used when data needs to live longer than a single function call or when the size of data isn't known at compile time (e.g., a list that grows based on user input).</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Structure:</b> Stack is Linear (LIFO); Heap is Hierarchical/Complex (Young/Old Gen).</li><li><b>Visibility:</b> Stack is <b>Thread-safe</b> (private to each thread). Heap is <b>Shared</b> (all threads share the same Heap, requires synchronization).</li><li><b>Speed:</b> Stack has extremely fast access. Heap is slower due to complex allocation and lookup.</li><li><b>Life Span:</b> Stack is short-lived (method execution). Heap is long-lived (until GC).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class MemoryDemo {\n    public static void main(String[] args) { // Main Stack Frame starts\n        int x = 10;           // 'x' (primitive) stored directly on Stack\n        int y = 20;           // 'y' (primitive) stored directly on Stack\n        \n        Person p = new Person(\"Alice\"); \n        // 1. 'new Person(\"Alice\")' -> Creates Object in HEAP\n        // 2. 'p' (reference variable) -> Stored on STACK, pointing to Heap address\n        \n        print(p); \n    } // Main Stack Frame pops off (x, y, p are gone). Heap object becomes eligible for GC.\n\n    public static void print(Person p) { // New Stack Frame created\n        // 'p' here is a copy of the reference, pointing to same Heap Object\n        System.out.println(p.name);\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The References Rule:</b><ul><li><b>Primitives (int, boolean):</b> Value sits directly on the <b>Stack</b> (if local).</li><li><b>Objects (String, List, Car):</b> The <b>Reference</b> sits on the Stack, but the <b>Actual Data</b> sits in the <b>Heap</b>.</li></ul></li><li><b>The Errors:</b><ul><li><b>StackOverflowError:</b> Happens due to deep/infinite recursion. The stack runs out of space for new frames.</li><li><b>OutOfMemoryError (Java Heap Space):</b> Happens when you create too many objects and the GC cannot free up enough space.</li></ul></li><li><b>String Pool:</b> A special area inside the Heap to store String literals for reusability.</li><li><b>Thread Safety:</b> Since Stack is private to a thread, local variables are inherently thread-safe. Heap objects are shared, so if multiple threads modify the same object, you need <b>Locks/Synchronization</b>.</li></ul>"
      }
    ]
  },
  "Association": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Association</b> is a structural relationship that defines a link between objects of one class and objects of another. It represents a \"Has-A\" or \"Uses-A\" relationship.</li><li>It is the most general term for connection; <b>Aggregation</b> and <b>Composition</b> are specific, stricter types of Association.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Modularity:</b> It allows classes to be independent but still interact. A <code>Teacher</code> class doesn't need to be inside a <code>Student</code> class, but they need to be associated.</li><li><b>Reusability:</b> You can reuse independent classes in different relationships (e.g., a <code>User</code> class can be associated with <code>Order</code> in one context and <code>Comment</code> in another).</li><li><b>Navigation:</b> It defines the direction of data flow (Unidirectional vs. Bidirectional).</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Cardinality (Multiplicity):</b> Defines \"how many.\"<ul><li><b>One-to-One:</b> One User has one Profile.</li><li><b>One-to-Many:</b> One Teacher teaches multiple Students.</li><li><b>Many-to-Many:</b> Many Students take many Courses.</li></ul></li><li><b>Direction:</b><ul><li><b>Unidirectional:</b> <code>Order</code> knows about <code>Customer</code>, but <code>Customer</code> doesn't strictly need to track every <code>Order</code> object internally.</li><li><b>Bidirectional:</b> Both classes hold references to each other (requires careful management to avoid infinite loops).</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Unidirectional Association (Bank -> Employee)\nclass Employee {\n    String name;\n    public Employee(String name) { this.name = name; }\n}\n\nclass Bank {\n    String name;\n    // Association: Bank \"Has-Many\" Employees\n    List<Employee> employees; \n\n    public Bank(String name) {\n        this.name = name;\n        this.employees = new ArrayList<>();\n    }\n    \n    public void addEmployee(Employee e) {\n        employees.add(e);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Employee e1 = new Employee(\"Alice\");\n        Bank b1 = new Bank(\"HDFC\");\n        \n        // Establishing the link\n        b1.addEmployee(e1); \n        \n        // Note: If Bank is destroyed, Employee CAN exist independently \n        // (This distinguishes generic Association/Aggregation from Composition)\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Lifecycle dependency is key:</b> In a generic Association, there is no owner. The objects have their own independent lifecycles. If you delete one, the other survives.</li><li><b>Reflexive Association:</b> A class can be associated with itself.<br><i>Example:</i> An <code>Employee</code> class having a field <code>supervisor</code> which is also of type <code>Employee</code>.</li><li><b>Association vs. Dependency:</b><ul><li><b>Association:</b> Stronger. Class A holds a reference to Class B as a field/variable (state).</li><li><b>Dependency:</b> Weaker. Class A uses Class B only as a parameter in a method or a local variable, but doesn't hold onto it.</li></ul></li><li><b>Mapping:</b> In databases (SQL), associations are implemented using Foreign Keys and Join Tables.</li></ul>"
    }
  ]
},
  "Aggregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Aggregation</b> is a specialized form of Association. It represents a \"Whole-Part\" relationship (Has-A), but with <b>Weak Ownership</b>.</li><li>The \"Part\" (Child) can exist independently of the \"Whole\" (Parent). If the Parent is destroyed, the Child survives.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Shared Resources:</b> Use it when an object needs to be part of a group but might belong to multiple groups or exist on its own.</li><li><b>Decoupled Lifecycles:</b> When destroying the container shouldn't destroy the items inside.</li><li><b>Real-world analogy:</b> A Team and Players. If the Team is dissolved, the Players don't die; they become free agents or join other teams.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Container (Whole):</b> Holds the reference to the collection of items.</li><li><b>The Component (Part):</b> The item being held.</li><li><b>Independent Lifecycle:</b> The key differentiator from Composition. The child is usually passed into the parent via the constructor or a setter (external creation).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Player {\n    String name;\n    public Player(String name) { this.name = name; }\n}\n\nclass Team {\n    String teamName;\n    List<Player> players; // Aggregation\n\n    public Team(String teamName, List<Player> players) {\n        this.teamName = teamName;\n        this.players = players; // Players are created OUTSIDE and passed in\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Create Parts independently\n        Player p1 = new Player(\"Dhoni\");\n        Player p2 = new Player(\"Kohli\");\n\n        // 2. Create Whole and add Parts\n        List<Player> squad = new ArrayList<>(Arrays.asList(p1, p2));\n        Team india = new Team(\"India\", squad);\n        \n        // 3. Destruction Scenario\n        india = null; // Team is destroyed\n        \n        // p1 and p2 STILL EXIST. They were not destroyed with the Team.\n        System.out.println(p1.name); // Works fine\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with an <b>Empty (White) Diamond</b> on the container side.<br><code>Team &lt;&gt;------- Player</code></li><li><b>Parameter Injection:</b> In Aggregation, objects are usually passed into the class (Dependency Injection) rather than being created inside the class using <code>new</code>.</li><li><b>Vs. Composition:</b> Ask this question: \"If I delete the Parent, does the Child die too?\"<ul><li><b>If No -> Aggregation</b> (e.g., Car and Driver).</li><li><b>If Yes -> Composition</b> (e.g., Car and Engine - conceptually, for that specific car).</li></ul></li></ul>"
    }
  ]
},
  "Composition": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Composition</b> is a restricted form of Aggregation. It represents a strong \"Whole-Part\" relationship.</li><li><b>Strong Ownership:</b> The \"Part\" (Child) belongs exclusively to the \"Whole\" (Parent).</li><li><b>Dependent Lifecycle:</b> If the Parent is destroyed, the Child is also destroyed. The child cannot exist independently.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Logical Consistency:</b> Use it when the parts have no meaning outside the whole (e.g., a <code>Room</code> has no identity without a <code>House</code>).</li><li><b>Encapsulation:</b> The parent strictly controls the creation and access of the child components.</li><li><b>Flexibility:</b> It is preferred over Inheritance (\"Composition over Inheritance\") because it allows you to assemble complex behaviors dynamically without the rigidity of class hierarchies.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Owner:</b> The class that manages the lifecycle.</li><li><b>Internal Creation:</b> The child objects are usually created inside the parent's constructor using <code>new</code>. They are not passed in from the outside.</li><li><b>Cascading Delete:</b> Logic that ensures cleaning up the parent cleans up the children.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Room {\n    String type;\n    public Room(String type) { this.type = type; }\n}\n\nclass House {\n    private final List<Room> rooms; // Composition\n\n    public House() {\n        // Rooms are created INSIDE the House. \n        // If House dies, nobody else holds a reference to these specific rooms.\n        this.rooms = new ArrayList<>();\n        this.rooms.add(new Room(\"Bedroom\"));\n        this.rooms.add(new Room(\"Kitchen\"));\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        House myHouse = new House();\n        \n        // 1. Destruction Scenario\n        myHouse = null; \n        \n        // The 'Room' objects created inside myHouse are now unreachable.\n        // They will be Garbage Collected along with the House.\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with a <b>Filled (Black) Diamond</b> on the container side.<br><code>House &lt;#&gt;------- Room</code></li><li><b>The \"Death\" Test:</b><ul><li>If you delete the <code>Order</code>, do the <code>LineItems</code> disappear? <b>Yes (Composition)</b>.</li><li>If you delete the <code>School</code>, do the <code>Students</code> disappear? <b>No (Aggregation)</b>.</li></ul></li><li><b>Composition over Inheritance:</b> This is a major design principle.<ul><li><b>Inheritance:</b> You inherit everything (good and bad) and it's static (fixed at compile time).</li><li><b>Composition:</b> You only include what you need, and you can change behavior at runtime (by swapping the composed object).</li></ul></li></ul>"
    }
  ]
},
  "Composition over Inheritance": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This principle states that classes should achieve code reuse by containing instances of other classes (Composition) rather than inheriting from them.</li><li>It attacks the biggest flaw of inheritance: <b>Tight Coupling</b>.</li></ul><br><p><b>The \"Banana, Gorilla & Jungle\" Problem:</b></p>(This is the most important analogy to remember)<br>Joe Armstrong (creator of Erlang) famously explained why Inheritance is dangerous:<br><i>\"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\"</i><ul><li><b>The Banana:</b> The small piece of functionality you actually needed (e.g., a method <code>calculateTax()</code>).</li><li><b>The Gorilla:</b> The Parent Class (<code>TaxCalculator</code>) that owns the method.</li><li><b>The Jungle:</b> The entire inheritance tree and all the extra data/dependencies the Parent Class carries with it (Grandparents, heavy database connections, unnecessary state).</li></ul><br>Inheritance forces you to load the whole jungle just to eat one banana. <b>Composition lets you just pick the banana.</b><br><br><p><b>Why use Composition?</b></p><ul><li><b>Precision:</b> You pick exactly the behaviors you want. You don't inherit \"baggage\" (variables or methods you don't need).</li><li><b>Flexibility:</b> You can change behaviors at runtime.<br><i>Inheritance:</i> You are born a Dog. You stay a Dog forever.<br><i>Composition:</i> You are an entity holding a <code>SoundBehavior</code>. You can swap it from \"Bark\" to \"Howl\" instantly.</li><li><b>Safety:</b> You avoid the <b>Fragile Base Class</b> problem. Changes in a superclass won't unexpectedly break your subclass because you aren't inextricably linked to its internal structure.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Jungle Way (Inheritance)\n\n// The Jungle (Huge, heavy class)\nclass BigHeavyService {\n    void connectDB() { ... } // Heavy logic\n    void logAnalytics() { ... } // Heavy logic\n    int add(int a, int b) { return a + b; } // THE BANANA (The only thing we want)\n}\n\n// The Gorilla holding the Banana\nclass MyCalculator extends BigHeavyService {\n    // I just wanted 'add()', but now I have DB connections and Analytics \n    // attached to my simple Calculator object. This is wasteful and risky.\n}"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Banana Way (Composition)\n\nclass Adder {\n    int add(int a, int b) { return a + b; } // Just the Banana\n}\n\nclass MyCalculator {\n    private Adder adder = new Adder(); // HAS-A relationship\n    \n    // I delegate the work to the specific component I need.\n    // No Jungle attached.\n    int calculate(int a, int b) {\n        return adder.add(a, b);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember:</b></p><ul><li><b>Is-A vs Has-A:</b><ul><li>If you can say \"A Manager is a Person\" -> Inheritance might be okay.</li><li>If you can say \"A Car has an Engine\" -> Use Composition.</li></ul></li><li><b>The \"Final\" Solution:</b> Many modern languages (like Kotlin or Rust) or libraries make classes <code>final</code> by default to force you to use Composition instead of trying to inherit.</li><li><b>Testing is Easier:</b> In Composition, you can easily mock the <code>Adder</code> component to test <code>MyCalculator</code>. In Inheritance, you often can't mock the Parent class easily without initializing its complex state.</li></ul>"
    }
  ]
},
  "Diamond Problem": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Diamond Problem</b> is an ambiguity that arises in Multiple Inheritance when a class inherits from two classes that both descend from the same superclass.</li><li>If the top superclass (\"Grandparent\") has a method, and both intermediate classes (\"Parents\") override it, the final subclass (\"Child\") doesn't know which version of the method to inherit.</li></ul><br><p><b>The Problem (Why is it tricky?)</b></p><ul><li><b>Ambiguity:</b> If Class B and Class C both extend Class A and override method <code>run()</code>, and Class D extends both B and C... when you call <code>d.run()</code>, should it run B's version or C's version? The compiler cannot decide.</li><li><b>Complexity:</b> It complicates method dispatch and memory layout (e.g., in C++, it can lead to multiple copies of the Grandparent class in memory unless \"virtual inheritance\" is used).</li></ul><br><p><b>Key Components (The Shape):</b></p><ul><li>The inheritance hierarchy looks like a diamond:<br><b>A</b> (Top / Grandparent)<br><b>B extends A</b> & <b>C extends A</b> (Middle / Parents)<br><b>D extends B, C</b> (Bottom / Child)</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "interface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from C\"); }\n}\n\n// PROBLEM: D implements both B and C. Both have 'hello()'.\n// COMPILER ERROR: \"class D inherits unrelated defaults for hello()...\"\nclass D implements B, C {\n    \n    // RESOLUTION: You MUST override the method to resolve ambiguity.\n    @Override\n    public void hello() {\n        // Option 1: Define new logic\n        // System.out.println(\"Hello from D\"); \n        \n        // Option 2: Explicitly choose a parent using 'super'\n        B.super.hello(); \n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        new D().hello(); // Output: Hello from B\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Why Java banned multiple class inheritance:</b> Specifically to avoid this ambiguity and keep the language simple (simplicity was a major design goal of Java vs. C++).</li><li><b>Interface Resolution Rules:</b> If there is a conflict between interfaces:<ul><li><b>Classes win:</b> If a class extends a Parent and implements an Interface, the Parent's method always wins (Rule of \"Class wins\").</li><li><b>Sub-interfaces win:</b> If B extends A, B is more specific.</li><li><b>Explicit Override:</b> If there is no clear winner (like the code above), the compiler forces you to override and clarify.</li></ul></li><li><b>Composition is the fix:</b> If you genuinely need behavior from two different classes, don't try to inherit from both. Have one class as a field inside your new class (Composition).</li></ul>"
    }
  ]
},
  "Dynamic Dispatch": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Dynamic Dispatch</b> (or Dynamic Method Dispatch) is the mechanism by which a call to an overridden method is resolved at <b>runtime</b> rather than compile-time.</li><li>The compiler doesn't know which method implementation to call; the JVM decides at the last moment based on the <i>actual object</i> being referred to, not the variable type.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Enables Polymorphism:</b> It is the technical engine that makes runtime polymorphism possible.</li><li><b>Extensibility:</b> You can add new subclasses (e.g., a new plugin) without recompiling the code that calls the plugin methods. The dispatch mechanism automatically finds the new code.</li><li><b>Cleaner Code:</b> Replaces massive <code>if (obj instanceof TypeA) ... else if (obj instanceof TypeB)</code> blocks.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Upcasting:</b> A Reference Variable of a Parent class holding an Object of a Child class.</li><li><b>Overriding:</b> The Child class must provide a specific implementation of a method defined in the Parent.</li><li><b>Virtual Method Table (vtable):</b> (Under the hood) The JVM maintains a table of method addresses for each class. When a method is called, it looks up the address in this table for the specific object type to find the correct code.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class GameCharacter {\n    void attack() { System.out.println(\"Basic Punch\"); }\n}\n\nclass Warrior extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Sword Slash\"); }\n}\n\nclass Archer extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Shoot Arrow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Compile time: 'c' is just a GameCharacter reference.\n        GameCharacter c;\n        \n        // 2. Runtime: The object is actually a Warrior.\n        c = new Warrior();\n        \n        // 3. Dynamic Dispatch: JVM checks heap object (Warrior) -> calls Sword Slash\n        c.attack(); \n        \n        // 4. Runtime: The object changes to Archer.\n        c = new Archer();\n        \n        // 5. Dynamic Dispatch: JVM checks heap object (Archer) -> calls Shoot Arrow\n        c.attack();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Does NOT apply to Static Methods:</b> Static methods are bound at compile-time (<i>Static Dispatch</i>) based on the reference type. You cannot override static methods (only hide them).</li><li><b>Does NOT apply to Private/Final Methods:</b> These cannot be overridden, so the compiler knows exactly which method to call at compile-time (Optimization).</li><li><b>Does NOT apply to Instance Variables:</b> Data is not polymorphic. If Parent and Child both have a variable <code>int x</code>, <code>parentRef.x</code> will always access the Parent's variable, even if the object is a Child.</li><li><b>Double Dispatch:</b> In some patterns (like <b>Visitor</b>), you need to dispatch based on two object types (the visitor and the element). Java only supports <b>Single Dispatch</b> (based on the receiver object), so we simulate Double Dispatch using two method calls.</li></ul>"
    }
  ]
},
  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Immutability:</b> An object is Immutable if its internal state (data) cannot be modified after it is created. Once initialized, it remains constant for its entire lifecycle. If you want to change something, you must create a new object.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Thread Safety:</b> Since the state cannot change, multiple threads can access the object simultaneously without synchronization (no locking needed).</li><li><b>Hash Keys:</b> They make perfect keys for <code>HashMap</code> or <code>HashSet</code>. If the key object changed (mutable), its hashcode would change, and you would lose the value in the map.</li><li><b>Caching:</b> You can safely cache and share references without worrying that one caller will modify the data and affect others.</li></ul><br><p><b>Key Components (The Recipe):</b></p>To create an immutable class in Java:<br><ul><li><b><code>final</code> Class:</b> Prevent subclasses (which might be mutable).</li><li><b><code>private final</code> Fields:</b> Ensure fields are assigned once and not accessible directly.</li><li><b>No Setters:</b> Remove any methods that modify state.</li><li><b>Deep Copy:</b> If the class holds a Mutable object (like a <code>List</code> or <code>Date</code>), you must perform a defensive copy in the Constructor and the Getter.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Final class\npublic final class ImmutableUser {\n    \n    // 2. Private Final fields\n    private final String name;\n    private final List<String> roles; \n\n    public ImmutableUser(String name, List<String> roles) {\n        this.name = name;\n        // 3. Defensive Copy (In): Don't trust the list passed by the caller\n        this.roles = new ArrayList<>(roles);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 4. No Setters\n    \n    public List<String> getRoles() {\n        // 5. Defensive Copy (Out): Return a copy or unmodifiable view\n        // return new ArrayList<>(roles);\n        return Collections.unmodifiableList(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>String is Immutable:</b> This is the most famous example. <code>String s = \"A\"; s = \"B\";</code> does not change \"A\"; it creates a new string \"B\" and points <code>s</code> to it.</li><li><b>Shallow vs. Deep Immutability:</b><ul><li><b>Shallow:</b> The fields are final, but they point to mutable objects (e.g., an immutable <code>Student</code> class holding a mutable <code>Address</code> object). This is dangerous.</li><li><b>Deep:</b> The object and everything it points to is immutable.</li></ul></li><li><b>Memory Overhead:</b> Since you create new objects for every change, it can generate garbage (pressure on GC). However, modern GCs are very efficient at collecting short-lived objects.</li><li><b>Builder Pattern:</b> Often used to construct complex immutable objects cleanly since you can't use setters after creation.</li></ul>"
    }
  ]
},
  "Abstract Class vs Interface": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated and is used to define a base for subclasses. It represents an \"Is-A\" relationship (Identity).</li><li><b>Interface:</b> A contract that defines a set of behaviors. It represents a \"Can-Do\" relationship (Capability).</li></ul><br><p><b>Why use them? (The Choice)</b></p><ul><li><b>Use Abstract Class when:</b> You want to share code and state (variables) among closely related classes (e.g., <code>Car</code> and <code>Truck</code> sharing <code>fuelLevel</code> and <code>startEngine()</code>).</li><li><b>Use Interface when:</b> You want to define a common capability for unrelated classes (e.g., <code>Bird</code> and <code>Airplane</code> both implement <code>Flyable</code>). It enables loose coupling.</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Relationship:</b> Abstract Class is \"Is-A\" (Inheritance); Interface is \"Can-Do\" (Capability).</li><li><b>State (Fields):</b> Abstract Class can have private, protected, non-static, mutable fields. Interface has only <code>public static final</code> (Constants) and no instance state.</li><li><b>Inheritance:</b> Abstract Class supports <b>Single Inheritance</b> (extends one class). Interface supports <b>Multiple Inheritance</b> (implements many).</li><li><b>Constructors:</b> Abstract Class has constructors to initialize state. Interface cannot have constructors.</li><li><b>Access Modifiers:</b> Abstract methods can be public, protected, private. Interface methods are implicitly <code>public</code> (Java 9 allows private for internal logic).</li><li><b>Speed:</b> Abstract Class is slightly faster (direct binding). Interface is slightly slower (lookup in interface table).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Abstract Class: Defines Identity & Shared State\nabstract class Animal {\n    String name; // State\n    \n    public Animal(String name) { this.name = name; } // Constructor\n    \n    abstract void makeSound(); // Abstract method\n    \n    void sleep() { // Concrete shared method\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\n// 2. Interface: Defines Capability\ninterface Pet {\n    void play(); // Abstract contract\n}\n\n// 3. Concrete Class: Combines both\nclass Dog extends Animal implements Pet {\n    public Dog(String name) { super(name); }\n    \n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n    \n    @Override\n    public void play() { System.out.println(\"Fetching ball\"); }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Java 8+ Blur:</b> With <code>default</code> and <code>static</code> methods in Interfaces, you can add code to interfaces. However, you still cannot have instance variables (state) in interfaces. State is the main tie-breaker.</li><li><b>Versioning:</b><ul><li>Adding a method to an <b>Interface</b> breaks all implementing classes (unless you make it <code>default</code>).</li><li>Adding a concrete method to an <b>Abstract Class</b> is safe (all children inherit it automatically).</li></ul></li><li><b>Design Rule:</b> \"Favor Interfaces over Abstract Classes\" (Item 20 in <i>Effective Java</i>). Use Abstract Classes only when you explicitly need to share variables or strictly control the hierarchy.</li><li><b>Marker Interface:</b> An interface with no methods (e.g., <code>Serializable</code>) used purely to \"mark\" a class with a specific property.</li></ul>"
    }
  ]
},
  "ER Diagrams": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>An <b>ER Diagram</b> (Entity-Relationship Diagram) is the structural blueprint of a database. It abstracts away technical details (like SQL types) to focus on the data and how it connects (the \"Nouns\" and \"Verbs\").</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Entities (The Nouns):</b><ul><li><b>Strong Entity:</b> Has its own Primary Key (Identity). Symbol: Single Rectangle. (e.g., <code>Student</code>).</li><li><b>Weak Entity:</b> Depends on a \"Strong Entity\" for existence. Does not have a full PK. Symbol: Double Rectangle. (e.g., <code>Apartment</code> needs <code>Building</code>).</li><li><b>Associative Entity:</b> An entity formed by resolving a Many-to-Many relationship. (e.g., <code>Enrollment</code> connecting Student and Course).</li></ul></li><li><b>Attributes (The Adjectives):</b><ul><li><b>Key Attribute:</b> Unique ID (Primary Key). Symbol: Underlined Text.</li><li><b>Composite:</b> Can be divided into sub-parts (e.g., <code>Address</code> -> City, Zip). Physical DBs store the sub-parts.</li><li><b>Multivalued:</b> Can have multiple values (e.g., <code>PhoneNumbers</code>). Symbol: Double Oval.</li><li><b>Derived:</b> Calculated from other attributes (e.g., Age from DOB). Symbol: Dashed Oval.</li></ul></li><li><b>Relationships (The Verbs):</b><ul><li><b>Binary:</b> Between two entities (Most common).</li><li><b>Recursive (Unary):</b> An entity relates to itself (e.g., Employee manages Employee). Symbol: Line looping back to same entity.</li><li><b>Generalization (IS-A):</b> Inheritance in DBs. A Superclass (Vehicle) has Subclasses (Car, Truck). Symbol: Triangle pointing to Superclass.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Cardinality & Participation (The Rules):</b></p><ul><li><b>Cardinality (Maximums - \"How many?\"):</b><ul><li><b>1:1 (One-to-One):</b> CEO manages Company.</li><li><b>1:N (One-to-Many):</b> Customer places Orders. (Most common).</li><li><b>M:N (Many-to-Many):</b> Actor acts in Movies.</li></ul></li><li><b>Participation (Minimums - \"Must they?\"):</b><ul><li><b>Total (Mandatory):</b> Every entity must be involved (e.g., Every Loan must belong to a Bank). Symbol: Double Line.</li><li><b>Partial (Optional):</b> Not every entity needs to be involved (e.g., Not every Employee manages a Department). Symbol: Single Line.</li></ul></li></ul><br><p><b>Notation Reality Check:</b></p><ul><li><b>Chen Notation:</b> Uses Diamonds & Ovals. Good for academic exams/whiteboarding.</li><li><b>Crow's Foot Notation:</b> Uses Forks & Circles. Standard for Industry LLD & SQL Tools.<br><code>||</code> (Exactly One), <code>|&lt;</code> (One or More), <code>0|</code> (Zero or One), <code>0&lt;</code> (Zero or More).</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- The M:N Trap: You cannot implement Many-to-Many in physical SQL.\n-- You must create a Join Table (Associative Entity).\n\n-- Logical: [Student] M <---> N [Course]\n\n-- Physical Implementation:\nCREATE TABLE Student (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100)\n);\n\nCREATE TABLE Course (\n    course_id INT PRIMARY KEY,\n    title VARCHAR(100)\n);\n\n-- The Associative Entity (Join Table)\nCREATE TABLE Enrollment (\n    enrollment_id INT PRIMARY KEY,\n    student_id INT,\n    course_id INT,\n    grade CHAR(1),\n    FOREIGN KEY (student_id) REFERENCES Student(student_id),\n    FOREIGN KEY (course_id) REFERENCES Course(course_id)\n);"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The M:N Trap:</b> You cannot implement a Many-to-Many relationship in a physical SQL database. You must create a <b>Join Table</b> (Associative Entity) to break it into two 1:N relationships.</li><li><b>Identifying Weak Entities:</b> Ask: \"If I delete the Parent, does this child disappear entirely and lose its identity?\" If yes, it's a <b>Weak Entity</b> (e.g., <code>InvoiceLineItem</code> inside <code>Invoice</code>).</li><li><b>Normalization:</b> ER Diagrams should typically reflect <b>3rd Normal Form (3NF)</b>. Avoid storing attributes in the wrong entity (e.g., <code>SupplierAddress</code> should be in <code>Supplier</code>, not <code>Product</code>).</li><li><b>Naming Convention:</b> Use <b>Singular Nouns</b> for Entities (<code>User</code>, not <code>Users</code>) and <b>Verbs</b> for Relationships (<code>Owns</code>, <code>Completes</code>).</li></ul>"
    },
     {
        "type": "gallery",
        "urls": [
          "images/erdiagram3.png",
          "images/erdiagram.png",
          "images/erdiagram2.png"
        ],
        "caption": ""
      }
  ]
},

  "Normalization": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Normalization</b> is the process of organizing columns and tables in a database to reduce data redundancy (duplication) and improve data integrity.</li><li>It is essentially \"Clean Code\" for Data. You break large, messy tables into smaller, focused tables and link them using relationships.</li></ul><br><p><b>Why use it? (The 3 Anomalies)</b></p>We normalize to avoid \"Anomalies\"â€”logical errors that happen when data is duplicated.<br><i>Imagine a single table: <code>Student_Course_Table</code> storing Student Name, Course Name, and Instructor Name.</i><ul><li><b>Update Anomaly:</b> If \"Professor Snape\" changes his phone number, and he teaches 100 students, you have to update 100 rows. If you miss one, your data is inconsistent.</li><li><b>Insertion Anomaly:</b> You cannot add a new Course (e.g., \"Defense Against Dark Arts\") unless a student enrolls in it, because the Primary Key includes <code>Student_ID</code>. No student = No course record.</li><li><b>Deletion Anomaly:</b> If the only student in \"History of Magic\" drops the class, you delete the row. Poof! You just lost the information that \"History of Magic\" exists as a course.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Normal Forms (The Steps):</b></p>There is a famous mnemonic by database pioneer Bill Kent to remember the first three rules:<br><i>\"The data depends on the Key (1NF), the Whole Key (2NF), and Nothing But the Key (3NF)... so help me Codd.\"</i><br><br><ul><li><b>First Normal Form (1NF) - \"Atomic Values\":</b><ul><li><b>Rule:</b> Every cell must hold a single value. No lists, arrays, or comma-separated strings.</li><li><b>Bad:</b> A column <code>Skills</code> containing \"Java, Python, C++\".</li><li><b>Good:</b> A separate table <code>User_Skills</code> with one row per skill.</li></ul></li><li><b>Second Normal Form (2NF) - \"No Partial Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 1NF.</li><li><b>The Issue:</b> This usually applies when you have a <b>Composite Primary Key</b> (a key made of 2+ columns).</li><li><b>Rule:</b> Non-key columns must depend on the <i>entire</i> primary key, not just part of it.</li></ul></li><li><b>Third Normal Form (3NF) - \"No Transitive Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 2NF.</li><li><b>The Issue:</b> A non-key column depends on another non-key column.</li><li><b>Rule:</b> A column should depend <i>only</i> on the Primary Key.</li></ul></li><li><b>Boyce-Codd Normal Form (BCNF):</b> A stricter version of 3NF. It handles rare cases where a Primary Key column depends on a Non-Key column.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- 2NF Example: Fix Partial Dependency\n-- Scenario: Composite PK is (Student_ID, Course_ID)\n\n-- BAD (Violation): Student_Name depends ONLY on Student_ID, not Course_ID.\nTable Grades {\n    Student_ID (PK),\n    Course_ID (PK),\n    Student_Name, -- Partial Dependency!\n    Grade\n}\n\n-- GOOD (Normalized):\nTable Students {\n    Student_ID (PK),\n    Student_Name\n}\nTable Grades {\n    Student_ID (FK),\n    Course_ID (FK),\n    Grade\n}\n\n-- 3NF Example: Fix Transitive Dependency\n-- Scenario: PK is Order_ID\n\n-- BAD (Violation): City depends on Zip_Code, which depends on Order_ID.\n-- Chain: Order_ID -> Zip_Code -> City\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code,\n    City -- Transitive Dependency!\n}\n\n-- GOOD (Normalized):\nTable Locations {\n    Zip_Code (PK),\n    City\n}\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code (FK)\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Denormalization (The Reality Check):</b></p><ul><li>In LLD and System Design, we sometimes intentionally break these rules. This is called <b>Denormalization</b>.</li><li><b>Why?</b> Normalization requires <b>JOINS</b>. To get a User's profile, address, and recent orders in 3NF, you might need 3-4 Joins. This is slow for reading.</li><li><b>Trade-off:</b><ul><li><b>Normalized:</b> Fast Writes (no duplication to update), Slow Reads (Joins), Consistent Data.</li><li><b>Denormalized:</b> Fast Reads (Pre-joined data), Slow Writes (update everywhere), Risk of Inconsistency.</li></ul></li></ul><br><p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>3NF is the Gold Standard:</b> For most generic backend interviews and \"clean\" designs, aim for 3NF. Going to 4NF or 5NF is usually academic overkill.</li><li><b>Identifying dependencies is key:</b> Ask \"Does knowing X tell me Y?\" If knowing <code>ZipCode</code> tells you the <code>City</code>, then City is dependent on ZipCode. If ZipCode is not the Primary Key, move City out!</li><li><b>NoSQL is often Denormalized:</b> In MongoDB or Cassandra, we often store the Address object inside the User document (breaking 1NF/3NF). We accept the redundancy to avoid Joins.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/Normalization.png"
        ],
        "caption": ""
      }
  ]
},

  "Entity vs Value Object": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This is a fundamental distinction in Domain-Driven Design (DDD) regarding how we model objects based on their identity and lifecycle.</li><li><b>Entity:</b> An object defined by its <b>Identity</b> (Who it is). It has a unique ID that persists over time, even if its details change.</li><li><b>Value Object:</b> An object defined by its <b>Attributes</b> (What it looks like). It has no unique ID; it is defined strictly by the values it holds.</li></ul><br><p><b>The Analogy: \"The Person vs. The Money\"</b></p><ul><li><b>Entity (The Person):</b> Imagine you meet a friend named John. If John changes his shirt, he is still John. If you meet another person named John who looks exactly like him, they are still two different people. <i>Conclusion: You care about which specific person it is.</i></li><li><b>Value Object (The Money):</b> Imagine you have a $10 bill. If you lend it to a friend and they pay you back with a different $10 bill, do you care? No. You define it by its properties (10 USD), not its serial number.</li></ul><br><p><b>Deep Dive: Key Differences</b></p><ul><li><b>Identity:</b><ul><li><b>Entity:</b> Defined by a Unique ID (Primary Key, UUID).</li><li><b>VO:</b> Defined by its State (All fields combined).</li></ul></li><li><b>Equality Check:</b><ul><li><b>Entity:</b> <code>a == b</code> if their IDs match.</li><li><b>VO:</b> <code>a.equals(b)</code> if all fields match.</li></ul></li><li><b>Mutability:</b><ul><li><b>Entity:</b> Mutable. Its state changes over time (lifecycle).</li><li><b>VO:</b> Immutable. Once created, it never changes. To change it, you create a new one.</li></ul></li><li><b>Lifespan:</b><ul><li><b>Entity:</b> Has a history and lifecycle (Created -> Active -> Deleted).</li><li><b>VO:</b> Ephemeral. Created when needed, discarded when done.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Value Object (Money)\n// Notice there is no id. Equality checks the values.\npublic final class Money {\n    private final BigDecimal amount;\n    private final String currency;\n\n    public Money(BigDecimal amount, String currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    // VO Logic: Equality depends on content\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Money money = (Money) o;\n        return amount.equals(money.amount) && \n               currency.equals(money.currency);\n    }\n}\n\n// Entity (Order)\n// Notice the id. Equality checks the ID.\npublic class Order {\n    private final String orderId; // Identity\n    private Money totalCost;      // Has-A Value Object\n    private String status;        // Mutable state\n\n    public Order(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public void changeStatus(String newStatus) {\n        this.status = newStatus; // Can change\n    }\n\n    // Entity Logic: Equality depends ONLY on ID\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Order order = (Order) o;\n        return orderId.equals(order.orderId);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Swap Test:</b> To decide between Entity vs. Value Object, ask: \"If I replace this object with another one having the exact same values, does it break my system?\"<ul><li><b>If Yes</b> (I need that specific one) -> <b>Entity</b>.</li><li><b>If No</b> (Any identical one works) -> <b>Value Object</b>.</li></ul></li><li><b>Immutability is King:</b> Value Objects should always be immutable. Do not add setters. If you need to change a coordinate (x, y) to (x+1, y), return a new <code>Point</code> object.</li><li><b>Database Mapping:</b><ul><li><b>Entities</b> usually get their own Table (Users, Orders).</li><li><b>Value Objects</b> are usually <b>Embedded</b> in the parent's table (e.g., <code>user_address_city</code>, <code>user_address_zip</code> inside the Users table) or stored as a JSON blob.</li></ul></li><li><b>Code Smell:</b> If you see a Value Object (like <code>Color</code> or <code>Date</code>) with an <code>id</code> field, something is wrong.</li></ul>"
    }
  ]
},

  "ORM Mapping": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ORM (Object-Relational Mapping)</b> is a technique (and a software layer) that sits between your Object-Oriented code (Java/Python classes) and your Relational Database (SQL tables).</li><li>It acts as a <b>Translator</b>.<br><i>Your Code speaks \"Objects\"</i> (Inheritance, Polymorphism).<br><i>The DB speaks \"Tables\"</i> (Rows, FKs, Joins).</li><li>The ORM automatically translates \"Save User Object\" into <code>INSERT INTO users...</code> and vice versa.</li></ul><br><p><b>Why use it? (The Impedance Mismatch)</b></p>The fundamental problem ORM solves is the friction caused because the two paradigms are conceptually different:<ul><li><b>Granularity:</b> Java has nested classes (<code>Address</code> inside <code>User</code>); SQL has flat columns. ORM maps this.</li><li><b>Inheritance:</b> SQL tables don't support inheritance (e.g., Manager extends Employee). ORM simulates this strategies like Single Table.</li><li><b>Identity:</b> Java uses memory addresses/equals; SQL uses Primary Keys.</li><li><b>Relationships:</b> Java uses references (<code>user.getOrders()</code>); SQL uses Foreign Keys (<code>user_id</code>).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Key Mapping Annotations (The \"How\" in JPA/Hibernate):</b></p><ul><li><b>Class Level:</b><ul><li><code>@Entity</code>: \"Hey ORM, treat this class as a database table.\"</li><li><code>@Table(name=\"users\")</code>: \"Map this class specifically to the <code>users</code> table.\"</li></ul></li><li><b>Field Level:</b><ul><li><code>@Id</code>: \"This is the Primary Key.\"</li><li><code>@GeneratedValue</code>: \"Auto-increment this ID.\"</li><li><code>@Column(name=\"email_addr\")</code>: \"Map the email field to the <code>email_addr</code> column.\"</li><li><code>@Transient</code>: \"Ignore this field. Do not store it in the DB.\"</li></ul></li><li><b>Relationship Level:</b><ul><li><code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>: Defines the association logic.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity // 1. Mark as ORM Object\n@Table(name = \"employees\")\npublic class Employee {\n\n    @Id // 2. Primary Key\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    // 3. Mapping a Relationship\n    // \"Many Employees belong to One Department\"\n    @ManyToOne(fetch = FetchType.LAZY) \n    @JoinColumn(name = \"dept_id\") // The Foreign Key column in 'employees' table\n    private Department department;\n\n    // Standard Getters/Setters...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The N+1 Problem (Performance Killer):</b><ul><li><b>Scenario:</b> You fetch 100 <code>Department</code> objects. Then you loop through them and call <code>dept.getEmployees()</code> for each one.</li><li><b>What happens:</b> 1 Query to get Departments + 100 Queries (one per department) to get their employees = 101 Queries.</li><li><b>Fix:</b> Use \"Join Fetch\" (eagerly load data in the initial query using a JOIN) or Entity Graphs.</li></ul></li><li><b>Lazy vs. Eager Loading:</b><ul><li><b>Eager:</b> \"Bring the Jungle.\" When you fetch the User, the ORM effectively does a JOIN and fetches all their Orders immediately.</li><li><b>Lazy:</b> \"Bring the Banana.\" When you fetch User, the Orders list is just a proxy (empty placeholder). The DB query fires only when you touch <code>user.getOrders()</code>. <b>Best Practice:</b> Prefer Lazy loading.</li></ul></li><li><b>Caching (L1 vs L2):</b><ul><li><b>Level 1 (Session Cache):</b> Default. Within a single transaction, if you ask for User ID #1 twice, the ORM returns it from memory the second time.</li><li><b>Level 2 (Global Cache):</b> Optional (e.g., Redis). Shared across all users/sessions. Good for read-heavy, static data.</li></ul></li><li><b>Dirty Checking:</b> You don't always need to call <code>repository.save(user)</code>. If you modify a fetched object inside a <code>@Transactional</code> block, the ORM automatically detects the change and fires the UPDATE query when the transaction ends.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/ormmapping.png"
        ],
        "caption": ""
      }
  ]
},
  "Lazy vs Eager": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This concept dictates <i>when</i> related data is fetched from the database.</li><li><b>Eager Loading:</b> Fetches the main entity and its related entities immediately in a single go (usually via a massive JOIN).</li><li><b>Lazy Loading:</b> Fetches only the main entity. The related entities are fetched on-demand, only when you explicitly access them in your code.</li></ul><br><p><b>The Analogy: \"Moving Houses\"</b></p><ul><li><b>Eager Loading (The Over-Packer):</b> You move to a new house and pack everything you own (winter coats, old yearbooks, kitchen sink) into the truck immediately.<br><i>Pros:</i> Everything is there if you need it.<br><i>Cons:</i> The truck is heavy, slow, and you might not look at those old yearbooks for 5 years. Wasted effort.</li><li><b>Lazy Loading (The Minimalist):</b> You move with just your essentials (bed, clothes). You leave the rest in storage.<br><i>Pros:</i> The move is fast and light.<br><i>Cons:</i> If you suddenly decide you need your \"High School Yearbook,\" you have to drive back to storage (make another DB trip) to get it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Mechanics: How it works (The Proxy)</b></p><ul><li>How does Java know to fetch data later? <b>Proxies.</b></li><li>When you Lazy load a User's orders, Hibernate doesn't give you a <code>List&lt;Order&gt;</code>. It gives you a <b>Proxy Object</b> (a placeholder/stub).</li><li>This Proxy looks like a list, but it's empty.</li><li><b>The Trigger:</b> The moment you call <code>user.getOrders().size()</code> or access the data, the Proxy \"wakes up,\" fires a SQL query to the database, fills itself with real data, and then gives it to you.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity\npublic class User {\n    @Id\n    private Long id;\n\n    // EAGER: \"I want the Profile immediately when I get the User\"\n    // Result: SELECT * FROM User LEFT JOIN Profile ...\n    @OneToOne(fetch = FetchType.EAGER)\n    private Profile profile;\n\n    // LAZY: \"Don't fetch Orders yet. Just give me a placeholder.\"\n    // Result: SELECT * FROM User ... (No Orders yet)\n    @OneToMany(fetch = FetchType.LAZY) \n    private List<Order> orders;\n}\n\n// Usage\nclass Main {\n    void test(EntityManager em) {\n        User u = em.find(User.class, 1L); // Query 1 fires here (User + Profile)\n        \n        System.out.println(u.getProfile().getBio()); // No new query (Already loaded)\n        \n        System.out.println(\"Wait for it...\");\n        \n        // Query 2 fires HERE (The \"Lazy Initialization\")\n        System.out.println(u.getOrders().size()); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Defaults (Memorize this):</b> JPA has default settings based on cardinality.<ul><li><code>@OneToOne</code>, <code>@ManyToOne</code> (Single Association) -> Default is <b>EAGER</b>.</li><li><code>@OneToMany</code>, <code>@ManyToMany</code> (Collection Association) -> Default is <b>LAZY</b>.</li><li><i>Tip:</i> Always explicitly set <code>@ManyToOne(fetch = FetchType.LAZY)</code>. Eager loading is almost always a performance trap in large apps.</li></ul></li><li><b>LazyInitializationException:</b> This is the most common error in Hibernate.<ul><li><b>Cause:</b> You fetched a Lazy entity, closed the Database Session (Transaction ended), and <i>then</i> tried to access the lazy data.</li><li><b>Result:</b> The Proxy tries to go back to the DB, finds the connection closed, and crashes.</li><li><b>Fix:</b> Keep the transaction open (using <code>@Transactional</code>) or use \"Join Fetch\".</li></ul></li><li><b>When to use which?</b><ul><li><b>Use Eager:</b> When you are 100% sure you will use the related data every single time you load the parent (e.g., User and UserPreferences).</li><li><b>Use Lazy:</b> For everything else. Especially for Lists/Collections. Loading 5000 Orders just to check a User's name is a disaster.</li></ul></li></ul>"
    }
  ]
},

  "Schema Evolution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Schema Evolution</b> is the process of managing changes to your database structure (tables, columns, types) over time as your application requirements change.</li><li>It is the art of \"Changing the tires on a moving car.\" You need to upgrade the database without crashing the application or losing data.</li></ul><br><p><b>Why use it? (The Challenge)</b></p><ul><li><b>Agile Development:</b> Requirements change. You need a new <code>is_verified</code> column today that you didn't need yesterday.</li><li><b>Zero Downtime:</b> In modern systems, you cannot just shut down the server. The old code and the new database schema must often coexist during deployment.</li><li><b>Compatibility:</b> You must ensure Backward Compatibility (New DB works with Old Code) and Forward Compatibility (Old DB works with New Code).</li></ul><br><p><b>The Strategy: Expand and Contract (Parallel Change)</b></p><ul><li>This is the Gold Standard pattern for safe schema evolution without downtime. It involves multiple small steps instead of one big \"Rename\" or \"Delete\".</li><li><b>Scenario:</b> Rename <code>full_name</code> to <code>display_name</code>.</li><li><b>Steps:</b><ol><li><b>Expand (Add):</b> Add <code>display_name</code> (nullable). DB has both.</li><li><b>Dual Write:</b> Deploy code that writes to both, but reads from old.</li><li><b>Backfill:</b> Copy data from old to new.</li><li><b>Switch Read:</b> Deploy code that reads from new.</li><li><b>Contract (Remove):</b> Stop writing to old. Remove old column.</li></ol></li></ul><br><p><b>Tools of the Trade:</b></p><ul><li><b>Flyway / Liquibase:</b> Version control tools for your database. They use a hidden table (<code>schema_version</code>) to track which scripts have run.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- File: V2__split_name_column.sql\n\n-- 1. Add new columns (Allow NULLs initially to prevent locking/errors)\nALTER TABLE users ADD COLUMN first_name VARCHAR(50);\nALTER TABLE users ADD COLUMN last_name VARCHAR(50);\n\n-- 2. Migrate existing data (The Backfill)\n-- Ideally, do this in batches for large tables to avoid locking\nUPDATE users SET first_name = SPLIT_PART(full_name, ' ', 1),\n    last_name = SPLIT_PART(full_name, ' ', 2);\n\n-- 3. Add constraints (After data is safe)\n-- ALTER TABLE users ALTER COLUMN first_name SET NOT NULL;"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Never Rename Columns directly:</b> <code>RENAME COLUMN</code> is a destructive action. The code looking for \"old\" will instantly crash. Use Expand & Contract.</li><li><b>Locking & Performance:</b> Adding a column with a <code>DEFAULT</code> value (in older DB versions) can lock the entire table. <b>Fix:</b> Add as <code>NULL</code> first -> Populate -> Add <code>NOT NULL</code> constraint.</li><li><b>Deprecation Phase:</b> If you delete a column, ensure the code has stopped using it for at least one full deployment cycle.</li><li><b>NoSQL is easier (but messier):</b> In MongoDB, you don't need migrations. You can have Document A with <code>name</code> and Document B with <code>firstName</code>. The complexity moves from the Database to the Application Code.</li></ul>"
    }
  ]
},

  "Threads vs Processes": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy:</b></p><ul><li><b>Process (The House):</b> A Process is the \"container.\" It has the address (Memory Space) and the resources (Kitchen/TV). It provides the environment to live in.</li><li><b>Thread (The Person):</b> A Thread is the \"worker\" inside the house. It actually does the things (cooking, cleaning).</li><li><b>Multi-threading:</b> Multiple people living in the same house. They share the same Fridge (<b>Heap Memory</b>) but have their own To-Do lists (<b>Stacks</b>).</li></ul><br><p><b>How Java \"Thinks\" of a Thread:</b></p>In Java, a Thread is not just a concept; it is an Object that wraps a real Operating System resource.<br><ul><li><b>1:1 Mapping:</b> When you call <code>t.start()</code>, the JVM asks the OS to create a real, native thread. One Java Thread = One OS Thread.</li><li><b>The Wrapper:</b> The Java Thread object (in Heap) is just the \"Remote Control.\" It holds metadata, but the actual execution happens in the OS.</li><li><b>The Job vs The Worker:</b><ul><li><b>Runnable Interface</b> = The Job (The specific logic/code to run).</li><li><b>Thread Class</b> = The Worker (The resource that executes the job).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Memory Architecture (Crucial for LLD):</b></p><ul><li><b>The Heap (Shared Space):</b> Where Objects live (<code>new HashMap()</code>). Visible to ALL threads. <i>Risk: Race Conditions.</i></li><li><b>The Stack (Private Space):</b> Where Method Calls and Local Variables live. Visible ONLY to the owner thread. <i>Risk: None (Thread-safe).</i></li></ul><br><p><b>Context Switching (The Cost):</b></p><ul><li><b>Process Switch:</b> Slow. CPU saves entire memory map and loads new app.</li><li><b>Thread Switch:</b> Fast. CPU stays in same memory address, just swaps Registers and Stack Pointer.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Way 1: The \"Job\" Approach (Recommended - implements Runnable)\n// Decouples the logic from the thread object.\n\n// 1. Define the Job\nRunnable myTask = () -> {\n    System.out.println(\"Thread is running: \" + Thread.currentThread().getName());\n};\n\n// 2. Hire the Worker (Thread) and give him the Job\nThread worker = new Thread(myTask);\nworker.start(); // STARTS the thread. Do not call run() directly!\n\n// Way 2: The \"Subclass\" Approach (Not Recommended - extends Thread)\n// Hardcodes the logic into the thread itself."
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>t.start()</code> and <code>t.run()</code>?</b><br><b>Answer:</b> <code>start()</code> creates a new separate thread (native OS call) and then calls <code>run()</code> inside that new thread. <code>run()</code> is just a normal method call on the <i>current</i> thread (no multi-threading).</li><li><b>Q2: Why did Chrome move to \"Process-per-Tab\"?</b><br><b>Answer:</b> Isolation. If one tab (Thread) crashed, the whole browser (Process) closed. Processes provide memory isolation and stability.</li><li><b>Q3: If a Thread throws a <code>StackOverflowError</code>, what crashes?</b><br><b>Answer:</b> Only that specific thread dies.</li><li><b>Q4: If a Thread throws an <code>OutOfMemoryError</code> (Heap Space), what crashes?</b><br><b>Answer:</b> The entire Application (Process) usually crashes (Shared Heap is full for everyone).</li><li><b>Q5: Why is <code>implements Runnable</code> better than <code>extends Thread</code>?</b><br><b>Answer:</b> Java allows single inheritance. If you extend <code>Thread</code>, you can't extend anything else. <code>Runnable</code> is an interface, allowing better flexibility and design (separation of Task from Runner).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/processthread.png"
        ],
        "caption": ""
      }
  ]
},

  "Thread Lifecycle": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy (The Gym Member):</b></p>A thread's life isn't just \"Running\" or \"Stopped.\" It moves through distinct phases managed by the OS Scheduler.<br><ul><li><b>New:</b> You just bought the gym membership. You haven't stepped inside yet.</li><li><b>Runnable (Ready + Running):</b> You are inside the gym. You might be lifting weights (<b>Running</b>) or waiting for your turn on the bench (<b>Ready</b>).</li><li><b>Blocked:</b> You want to use the Squat Rack, but someone else is using it. You wait passively for the resource (Lock).</li><li><b>Waiting:</b> You are resting on a bench and tell your trainer, \"Tap me when you are ready.\" You wait for a specific signal (Notification).</li><li><b>Timed Waiting:</b> You nap for exactly 10 minutes. You wake up automatically (Sleep).</li><li><b>Terminated:</b> You finished the workout and left. You cannot re-enter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>The 6 States (Technical Definitions - <code>Thread.State</code>):</b></p><ul><li><b>NEW:</b> Thread object created (<code>new Thread()</code>) but <code>start()</code> not called. No OS resources allocated.</li><li><b>RUNNABLE:</b> Includes both \"Ready to Run\" and \"Actually Running.\" The OS swaps them so fast Java groups them together.</li><li><b>BLOCKED:</b> <b>Passive Wait.</b> The thread tries to enter a <code>synchronized</code> block but the Lock is held by another thread. It uses 0% CPU.</li><li><b>WAITING:</b> <b>Active Voluntary Wait.</b> The thread explicitly paused itself (<code>Object.wait()</code>, <code>Thread.join()</code>) and waits for a signal (<code>notify()</code>).</li><li><b>TIMED_WAITING:</b> Same as WAITING, but with a timeout (<code>Thread.sleep(1000)</code>). Exits on timeout or interrupt.</li><li><b>TERMINATED:</b> Execution completed or crashed. The thread is dead.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class LifecycleDemo {\n    public static void main(String[] args) throws InterruptedException {\n        \n        // 1. NEW State\n        Thread t1 = new Thread(() -> {\n            try {\n                // 3. TIMED_WAITING State (during sleep)\n                Thread.sleep(1000); \n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        System.out.println(\"State 1: \" + t1.getState()); // Output: NEW\n\n        t1.start();\n        // 2. RUNNABLE State\n        System.out.println(\"State 2: \" + t1.getState()); // Output: RUNNABLE\n\n        Thread.sleep(100); // Main thread pauses to ensure t1 starts sleeping\n        \n        System.out.println(\"State 3: \" + t1.getState()); // Output: TIMED_WAITING\n\n        t1.join(); // Main thread waits for t1 to finish\n        \n        // 4. TERMINATED State\n        System.out.println(\"State 4: \" + t1.getState()); // Output: TERMINATED\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between BLOCKED and WAITING? (Very Common)</b><br><b>Answer:</b> <b>BLOCKED</b> happens automatically when waiting for a <i>Lock</i> (resource busy). <b>WAITING</b> happens manually when you call <code>.wait()</code> expecting a <i>Signal/Notification</i> (logic flow).</li><li><b>Q2: Can we restart a dead thread?</b><br><b>Answer:</b> No. Once TERMINATED, it's gone. Calling <code>start()</code> again throws an exception.</li><li><b>Q3: Difference between <code>Thread.sleep()</code> and <code>Object.wait()</code>?</b><br><b>Answer:</b> <code>sleep()</code> <b>keeps</b> the lock (\"I'm napping with the key in my pocket\"). <code>wait()</code> <b>releases</b> the lock (\"I'm pausing, here is the key for someone else\").</li><li><b>Q4: What is <code>Thread.yield()</code>?</b><br><b>Answer:</b> A hint to the scheduler to let other threads run. It goes from Running -> Ready (stays in RUNNABLE). Rarely used.</li></ul>"
    }
  ]
},

  "Locks": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Locks</b> are mechanisms used to enforce limits on access to a resource in an environment where there are many threads of execution.</li></ul><br><p><b>The Analogy: \"The Fitting Room\"</b></p><ul><li><b>The Shared Resource:</b> A clothing store has one <b>Fitting Room</b>.</li><li><b>The Threads:</b> Many <b>Customers</b> want to try on clothes.</li><li><b>The Lock:</b> The <b>Latch</b> on the fitting room door.</li><li><b>The Process:</b><ul><li><b>Acquire Lock:</b> Customer A enters and locks the door.</li><li><b>Critical Section:</b> Customer A changes clothes. Customer B must wait outside (Blocked).</li><li><b>Release Lock:</b> Customer A unlocks and leaves.</li><li><b>Next Turn:</b> Customer B sees the door is free and enters.</li></ul></li><li><b>Without a Lock (Race Condition):</b> Customer A is half-naked, and Customer B barges in. Chaos (Data Corruption) ensues.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Race Condition:</b> A bug where the output depends on the timing of uncontrollable events (threads). Happens when multiple threads Read-Modify-Write shared data simultaneously.</li><li><b>Critical Section:</b> The specific lines of code that access the shared resource. This section needs protection.</li><li><b>Monitor (Intrinsic Lock):</b> Every Object in Java has an internal lock built-in. When you use <code>synchronized</code>, the thread grabs this specific object's monitor. <b>Rule:</b> Only one thread can hold an object's monitor at a time.</li></ul><br><p><b>Types of Synchronization:</b></p><ul><li><b>Synchronized Method (Coarse-Grained):</b> Locks the entire method using <code>this</code>. <i>Downside:</i> Slow; freezes the whole object.</li><li><b>Synchronized Block (Fine-Grained) - BEST PRACTICE:</b> Locks only a specific part of the code. Allows other threads to access other parts of the object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class FittingRoom {\n    public void tryOnClothes(String customerName) {\n        System.out.println(customerName + \" entered the store.\");\n\n        // Only one person can be inside this block at a time\n        synchronized(this) { \n            System.out.println(customerName + \" locked the Fitting Room.\");\n            try {\n                Thread.sleep(1000); // Simulate changing clothes\n            } catch (InterruptedException e) {}\n            System.out.println(customerName + \" unlocked the Fitting Room.\");\n        }\n        \n        System.out.println(customerName + \" left the store.\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions (Locks):</b></p><ul><li><b>Q1: Can Thread A enter <code>synchronized methodA()</code> and Thread B enter <code>synchronized methodB()</code> on the SAME object at the same time?</b><br><b>Answer:</b> No. Both methods use the same lock (<code>this</code>). Thread B is blocked.</li><li><b>Q2: Can Thread A enter a synchronized method and Thread B enter a non-synchronized method on the same object?</b><br><b>Answer:</b> Yes. Normal methods are \"Open Doors\"â€”anyone can walk in.</li><li><b>Q3: What is the difference between Object Lock and Class Lock?</b><br><b>Answer:</b><ul><li><b>Object Lock:</b> Locks a specific instance (<code>new FittingRoom()</code>).</li><li><b>Class Lock:</b> Locks the Class definition itself (<code>FittingRoom.class</code>). It is a Global Lock for all instances.</li></ul></li><li><b>Q4: Why prefer Synchronized Blocks over Methods?</b><br><b>Answer:</b> Performance. Blocks allow you to keep the \"Critical Section\" as small as possible.</li></ul>"
    },
    {
      "type": "text",
      "content": "<hr><p><b>The Deadlock (The Nightmare Scenario)</b></p><p><b>1. The Core Analogy: Pen and Paper</b></p><ul><li><b>The Scenario:</b> You and your friend need to write a letter. You need both a Pen and Paper.</li><li><b>The Trap:</b><ul><li>You grab the Pen (Holding Lock A).</li><li>Friend grabs the Paper (Holding Lock B).</li><li>You wait for the Paper.</li><li>Friend waits for the Pen.</li></ul></li><li><b>Result:</b> Neither of you will give up what you have. You stare at each other forever.</li></ul><br><br><p><b>2. Technical Definition & Conditions</b></p><ul><li><b>Deadlock:</b> A situation where two or more threads are blocked forever, waiting for each other.</li><li><b>The 4 Conditions (Coffman Conditions) - All must be true:</b><ol><li><b>Mutual Exclusion:</b> Only one thread can use the resource at a time.</li><li><b>Hold and Wait:</b> Holding a resource while waiting for another.</li><li><b>No Preemption:</b> Resources cannot be forcibly taken away.</li><li><b>Circular Wait:</b> A closed chain of threads waiting for each other.</li></ol></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// How to create a Deadlock\n\n// Thread 1\nsynchronized(LockA) {\n    System.out.println(\"Holding Lock A...\");\n    Thread.sleep(100); // Wait for Thread 2 to grab Lock B\n    \n    synchronized(LockB) { // WAITING FOREVER\n        System.out.println(\"Got Lock B\");\n    }\n}\n\n// Thread 2\nsynchronized(LockB) {\n    System.out.println(\"Holding Lock B...\");\n    Thread.sleep(100); // Wait for Thread 1 to grab Lock A\n    \n    synchronized(LockA) { // WAITING FOREVER\n        System.out.println(\"Got Lock A\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Deadlock Interview Questions:</b></p><ul><li><b>Q1: How do you prevent Deadlocks in code?</b><br><b>Answer:</b> The most practical way is <b>Lock Ordering</b>. Always acquire locks in the same order everywhere in your code. (e.g., Always Lock A then Lock B).</li><li><b>Q2: How do you detect a Deadlock in a running server?</b><br><b>Answer:</b> Take a <b>Thread Dump</b> (using tools like <code>jstack</code> or VisualVM). The tool will literally print a message saying: \"Found one Java-level deadlock\" and list the threads involved.</li><li><b>Q3: Can <code>synchronized</code> detect deadlocks and recover automatically?</b><br><b>Answer:</b> No. <code>synchronized</code> will wait forever. This is why we sometimes use <code>ReentrantLock</code> with <code>.tryLock()</code>, which allows us to say \"If I can't get the lock in 2 seconds, I'll give up,\" effectively breaking the deadlock.</li></ul>"
    }
  ]
},

  "ReentrantLock": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ReentrantLock</b> is a class in <code>java.util.concurrent.locks</code> that provides advanced locking capabilities beyond <code>synchronized</code>.</li></ul><br><p><b>The Analogy: \"The Security Badge\"</b></p><ul><li><b>The Scenario:</b> You work in a high-security building.</li><li><b>Reentrancy (Re-entering):</b><ul><li><b>Main Entrance:</b> You swipe your badge to enter. System: \"Welcome.\" (You hold the lock).</li><li><b>Server Room (Inside):</b> You need to enter a room <i>inside</i> the building. You swipe the same badge again.</li><li><b>Smart System (Reentrant):</b> It sees it's YOU (who already holds the lock) and lets you in immediately.</li><li><b>Dumb System (Non-Reentrant):</b> It says \"User is already in. Wait for User to leave.\" You are trapped waiting for yourself (Deadlock).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Hold Count:</b> The lock keeps a counter.<ul><li><code>lock()</code> -> Count increments (0 -> 1).</li><li><code>lock()</code> again (same thread) -> Count increments (1 -> 2).</li><li><code>unlock()</code> -> Count decrements (2 -> 1).</li><li>The lock is only released when Count reaches <b>0</b>.</li></ul></li><li><b>Fairness:</b><ul><li><b>Unfair (Default):</b> Faster. A new thread can \"cut in line\" if the lock is free.</li><li><b>Fair (<code>new ReentrantLock(true)</code>):</b> Slower. Strictly follows <b>FIFO</b>. The longest-waiting thread always gets the lock next.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SecuritySystem {\n    // 1. Create the Lock\n    // Pass 'true' to constructor for Fairness (FIFO)\n    private final ReentrantLock lock = new ReentrantLock(true); \n\n    public void accessResource() {\n        // 2. Lock Manually\n        lock.lock(); \n        \n        try {\n            // --- CRITICAL SECTION ---\n            System.out.println(\"Processing secure data...\");\n            \n            // Reentrancy Example:\n            // Calling another method that requires the SAME lock.\n            // This works fine because the lock is Reentrant.\n            internalAudit(); \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // 3. Unlock ALWAYS in finally\n            // Even if the code above crashes, this runs.\n            lock.unlock(); \n        }\n    }\n\n    public void internalAudit() {\n        lock.lock(); // Count goes 1 -> 2\n        try {\n            System.out.println(\"Auditing...\");\n        } finally {\n            lock.unlock(); // Count goes 2 -> 1\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the main difference between <code>synchronized</code> and <code>ReentrantLock</code>?</b><br><b>Answer:</b> Flexibility. <code>synchronized</code> is implicit and rigid (must wait forever). <code>ReentrantLock</code> is explicit (manual) and supports <b>Timeouts</b> (<code>tryLock</code>), <b>Fairness policies</b>, and multiple Condition variables.</li><li><b>Q2: What is <code>tryLock()</code> and why is it useful?</b><br><b>Answer:</b> <code>tryLock()</code> attempts to grab the lock but returns <code>false</code> immediately (or after a timeout) if it fails. Use it to prevent Deadlocks (\"If I can't get the lock in 2 seconds, I'll give up\").</li><li><b>Q3: Why shouldn't we use Fairness (true) all the time?</b><br><b>Answer:</b> <b>Performance.</b> Managing a strict queue takes CPU effort. Unfair locks have much higher throughput because they reduce context switching. Only use Fair locks if \"Starvation\" is a real problem.</li><li><b>Q4: What happens if you throw an Exception inside a <code>lock()</code> block without <code>finally</code>?</b><br><b>Answer:</b> The method exits, but <code>lock.unlock()</code> is never called. The lock remains held forever, hanging the system.</li></ul>"
    }
  ]
},

  "Volatile": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Notice Board vs. Personal Notepad Analogy:</b></li><li><b>The Setup:</b> Imagine an office with a Boss (Main Thread) and an Employee (Worker Thread).<ul><li><b>Main Memory (RAM):</b> A big Notice Board in the hallway.</li><li><b>CPU Cache:</b> The Employee's personal Notepad at their desk.</li></ul></li><li><b>The Problem (Without Volatile):</b> The Boss writes \"STOP WORKING\" on the Notice Board. The Employee looks at their Notepad, which still says \"KEEP WORKING.\" Result: The Employee works forever (Visibility Problem).</li><li><b>The Solution (With Volatile):</b> Declaring a variable <code>volatile</code> is a new rule: \"You are forbidden from writing this in your Notepad. You must walk to the Notice Board every single time you read or write this.\"</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Visibility:</b> <code>volatile</code> guarantees that changes made by one thread are immediately visible to other threads. It bypasses the CPU Cache (L1/L2) and goes straight to Main Memory (RAM).</li><li><b>Instruction Reordering (Memory Barrier):</b> Compilers like to rearrange code to make it faster. <code>volatile</code> acts as a wall. It prevents the compiler from reordering instructions across the variable.</li><li><b>Limitation:</b> It guarantees <b>Visibility</b>, but NOT <b>Atomicity</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Worker {\n    // WITHOUT 'volatile': \n    // The thread might cache 'running = true' and loop forever, \n    // even after you call stop().\n    private volatile boolean running = true; \n\n    public void run() {\n        System.out.println(\"Worker started.\");\n        \n        while (running) {\n            // \"Poll\" the variable. \n            // Because it is volatile, it checks Main Memory every single loop.\n        }\n        \n        System.out.println(\"Worker stopped.\");\n    }\n\n    public void stop() {\n        running = false; // Writes immediately to Main Memory\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The \"Count++\" Trap (What Volatile cannot do):</b></p><ul><li><b>Scenario:</b> You have <code>volatile int count = 0</code>. Two threads do <code>count++</code>.</li><li><b>The Bug:</b> <code>count++</code> is three steps: Read (0) -> Add (1) -> Write (1).</li><li><code>volatile</code> ensures they READ the latest value (0), but it doesn't stop them from running Step 2 at the exact same time. They both write 1.</li><li><b>Rule:</b> Never use <code>volatile</code> for counters or read-modify-write operations. Use <code>AtomicInteger</code> instead.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>volatile</code> and <code>synchronized</code>?</b><br><b>Answer:</b><ul><li><b>volatile:</b> Light. Guarantees <b>Visibility only</b>. No locking (non-blocking).</li><li><b>synchronized:</b> Heavy. Guarantees <b>Visibility AND Atomicity</b>. Forces threads to wait (blocking).</li></ul></li><li><b>Q2: Can we use volatile for a Singleton (Double-Checked Locking)?</b><br><b>Answer:</b> Yes. The instance variable must be <code>volatile</code> to prevent a half-initialized object from being visible to other threads due to instruction reordering.</li><li><b>Q3: When should you use volatile?</b><br><b>Answer:</b> Only in two cases: <br>1. <b>Flags</b> (boolean status like <code>stopRequested</code>).<br>2. <b>Single Writer, Many Readers</b> (One thread updates, many just read).</li></ul>"
    }
  ]
},


  "Atomic Ops": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Atomic Operations</b> are operations that appear to the rest of the system to occur instantaneously. They are indivisible.</li></ul><br><p><b>The Core Analogy: \"The Like Button\"</b></p><ul><li><b>The Scenario:</b> A post has 99 likes. Two friends click \"Like\" at the exact same millisecond.</li><li><b>Non-Atomic Way (The Glitch):</b><ul><li>Phone A reads: 99. Phone B reads: 99.</li><li>Phone A writes: 100. Phone B writes: 100.</li><li><b>Result:</b> 100 Likes. (One like was lost).</li></ul></li><li><b>Atomic Way (The Fix):</b> The hardware forces the operations into a strict line.</li><li><b>Result:</b> 99 -> 100 -> 101.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>CAS (Compare-And-Swap):</b> The secret sauce behind Atomic variables. It is a hardware instruction that is faster than locking.<br><i>Logic:</i> \"I think the current value is A. If it is A, change it to B. If it is NOT A (because someone changed it), tell me, and I will try again.\"</li><li><b>Optimistic Locking:</b> Atomics assume conflicts are rare. They don't lock the door; they just try to update and retry if they fail. This is <b>Non-Blocking</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicDemo {\n\n    // The \"Dangerous\" Way (int)\n    // int count = 0; // Not thread-safe. (Read-Modify-Write is 3 steps)\n\n    // The \"Safe\" Way (AtomicInteger)\n    // 1. Create the Atomic Variable\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        // 2. Atomic Increment\n        // Efficiently performs \"Read-Modify-Write\" in one shot using CAS.\n        // Returns the new value.\n        int newValue = count.incrementAndGet(); \n    }\n    \n    public int getCount() {\n        return count.get();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How are Atomics different from synchronized?</b><br><b>Answer:</b><ul><li><b>Atomics (CAS):</b> Optimistic. Non-blocking. Uses CPU instructions directly. Very fast for simple counters.</li><li><b>Synchronized:</b> Pessimistic. Blocking. Context switches threads. Better for complex logic.</li></ul></li><li><b>Q2: What is the \"ABA Problem\" in CAS?</b><br><b>Answer:</b> A famous bug. Thread 1 reads A. Thread 2 changes A -> B -> A. Thread 1 wakes up, sees A, and thinks \"Nothing changed!\", so it proceeds erroneously. <b>Fix:</b> Use <code>AtomicStampedReference</code> (Versions: A v1 -> B v2 -> A v3).</li><li><b>Q3: Can AtomicInteger replace synchronized blocks?</b><br><b>Answer:</b> Only for single variable updates. If you need to update balance AND transactionHistory together atomically, you still need <code>synchronized</code>.</li></ul>"
    }
  ]
},

  "ExecutorService": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ExecutorService</b> is the High-Level Interface in Java that manages a pool of threads, a work queue, and the lifecycle of task execution. It replaces the manual creation of threads.</li></ul><br><p><b>The Core Analogy: \"The Restaurant Manager\"</b></p><ul><li><b>The Old Way (<code>new Thread()</code>):</b> Customer enters. You hire a new chef. Chef cooks. You fire the chef. <i>Result:</i> Chaos and high cost.</li><li><b>The New Way (Thread Pool):</b> You hire a <b>Manager (ExecutorService)</b> and a <b>Fixed Crew</b> of 5 chefs.<ul><li>Customer enters. Manager gives the order to Chef 1.</li><li>If all chefs are busy, the Manager puts the order on the <b>Waiting Spike (Queue)</b>.</li><li>When Chef 1 is done, they pick the next ticket from the queue.</li></ul></li><li><b>Result:</b> Stability. You handle 1,000 customers with just 5 reused chefs.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why <code>new Thread()</code> is forbidden:</b><ul><li><b>Expensive:</b> Creating a thread takes OS resources (Stack Memory ~1MB).</li><li><b>Uncontrolled:</b> If you spawn 100k threads, you get <code>OutOfMemoryError</code>.</li></ul></li><li><b>Thread Pool:</b> A collection of pre-started threads that are reused for multiple tasks.</li></ul><br><p><b>Types of Pools (The \"Kitchen\" Types):</b></p><ul><li><b>FixedThreadPool(n):</b> Creates n threads. If busy, tasks queue up. <i>Best for:</i> Predictable, stable loads.</li><li><b>CachedThreadPool():</b> Creates new threads as needed. Kills them if idle for 60s. <i>Best for:</i> Short, bursty tasks. <i>Risk:</i> Can crash if load is infinite.</li><li><b>SingleThreadExecutor():</b> Only 1 thread. Tasks run sequentially. <i>Best for:</i> Ordering (logging).</li><li><b>ScheduledThreadPool():</b> Runs tasks after delay or periodically.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.*;\n\npublic class ManagerDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // 1. Hire the Manager (Fixed crew of 2 threads)\n        ExecutorService manager = Executors.newFixedThreadPool(2);\n\n        // 2. Submit a Task (Callable = Returns a Result)\n        // \"Future\" is the Claim Ticket/Receipt.\n        Future<String> receipt = manager.submit(() -> {\n            Thread.sleep(1000); // Simulate work\n            return \"Burger Ready!\";\n        });\n\n        System.out.println(\"Doing other work while burger cooks...\");\n\n        // 3. Get the Result (Blocking)\n        // This waits until the chef is done.\n        String result = receipt.get(); \n        System.out.println(result);\n\n        // 4. Close the Kitchen\n        manager.shutdown();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Difference between <code>execute()</code> and <code>submit()</code>?</b><br><b>Answer:</b> <code>execute()</code> is \"Fire and Forget\" (returns void). <code>submit()</code> returns a <b>Future</b>, allowing you to check status or get return values.</li><li><b>Q2: If a thread crashes (unchecked exception), what happens?</b><br><b>Answer:</b> The pool detects the thread died, discards it, and creates a <b>new one</b> to replace it. Pool size remains constant.</li><li><b>Q3: Risks of <code>CachedThreadPool</code> in production?</b><br><b>Answer:</b> <b>System Crash.</b> Since it creates a thread for <i>every</i> task if others are busy, a spike of 1M requests = 1M threads = <code>OutOfMemoryError</code>.</li><li><b>Q4: What is a Future?</b><br><b>Answer:</b> It's a placeholder object for a result that hasn't arrived yet (like a claim ticket). It allows the main thread to keep working and check for the result later using <code>future.get()</code>.</li></ul>"
    }
  ]
},


  "Concurrent Collections": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Concurrent Collections</b> are specialized data structures designed to be accessed and modified by multiple threads simultaneously without explicit external synchronization and without compromising data integrity.</li></ul><br><p><b>The Core Analogy: \"The Attendance Sheet\"</b></p><ul><li><b>The Scenario:</b> A classroom with 30 students and one attendance sheet.</li><li><b>The Old Way (Hashtable / Synchronized Map):</b><ul><li><b>The Rule:</b> The teacher holds the single sheet.</li><li><b>The Bottleneck:</b> If Student A is signing, Student Z must wait in line, even if they are signing at the bottom of the page.</li><li><b>Result:</b> Safe, but Slow (Coarse-grained locking).</li></ul></li><li><b>The New Way (ConcurrentHashMap):</b><ul><li><b>The Rule:</b> The teacher tears the sheet into 16 pieces (Buckets) and pastes them on different walls.</li><li><b>The Parallelism:</b> Student A goes to Wall 1. Student Z goes to Wall 16. They sign simultaneously.</li><li><b>Result:</b> Safe and Fast (Fine-grained locking).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why HashMap fails:</b> It is not thread-safe. If two threads modify it at once, it can corrupt the internal linked list (infinite loops) or lose data.</li><li><b>Why Hashtable is obsolete:</b> It uses a <b>Global Lock</b> (synchronized on the whole method). Only one thread can read/write at a time.</li><li><b>ConcurrentHashMap (The King):</b><ul><li><b>Lock Striping (Bucket Locking):</b> Instead of locking the whole map, it only locks the specific Bucket (index) you are writing to.</li><li><b>Read Operations (<code>get</code>):</b> Completely <b>Lock-Free</b>. They are non-blocking and very fast.</li><li><b>Iterators:</b> <b>Fail-Safe</b>. You can iterate over the map while other threads are adding/removing items without crashing.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentMapDemo {\n    public static void main(String[] args) {\n        \n        // Thread-safe map designed for high concurrency\n        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n        map.put(\"Apple\", 1);\n        map.put(\"Banana\", 2);\n\n        // Thread 1: Writing to 'Orange' bucket\n        new Thread(() -> {\n            map.put(\"Orange\", 3); \n            System.out.println(\"Added Orange\");\n        }).start();\n\n        // Thread 2: Reading 'Apple' bucket (Non-blocking)\n        // Works instantly even if Thread 1 is writing\n        new Thread(() -> {\n            System.out.println(\"Read Apple: \" + map.get(\"Apple\"));\n        }).start();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How does ConcurrentHashMap work internally in Java 8+?</b><br><b>Answer:</b> It no longer uses \"Segments.\" It uses a hybrid of <b>CAS</b> and <b>synchronized</b>.<ul><li><b>Empty Bucket:</b> Uses <b>CAS</b> to insert the new node (Lock-Free).</li><li><b>Collision:</b> If the slot has data, it locks <b>ONLY that specific Node</b> (using <code>synchronized</code>) to append to the list/tree.</li></ul></li><li><b>Q2: Why does ConcurrentHashMap NOT allow null keys or values?</b><br><b>Answer:</b> <b>Ambiguity.</b> In a normal map, <code>null</code> could mean \"Value is null\" OR \"Key doesn't exist.\" In multi-threading, you can't double-check with <code>containsKey()</code> because the map might change between the two calls. To prevent this race condition confusion, nulls are banned.</li><li><b>Q3: What is <code>ConcurrentModificationException</code>?</b><br><b>Answer:</b> A crash in normal collections (ArrayList) if you modify the list while iterating. <b>Fix:</b> Use <code>CopyOnWriteArrayList</code> or <code>ConcurrentHashMap</code> (Fail-Safe iterators).</li><li><b>Q4: Is <code>size()</code> accurate in ConcurrentHashMap?</b><br><b>Answer:</b> No, it is an <b>estimate</b>. Because threads are constantly adding/removing, the size might change before the method returns.</li></ul>"
    }
  ]
},

  "Thread-Safety": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Thread-Safety</b> means that code functions correctly (no data corruption, no crashes) when accessed by multiple threads simultaneously.</li></ul><br><p><b>The Core Analogy: \"The Kitchen Safety Hierarchy\"</b></p><ul><li><b>The Goal:</b> Multiple chefs (Threads) need to cook in the same building without ruining each other's food.</li><li><b>Strategy 1: Private Kitchens (Statelessness) - ðŸ¥‡ GOLD STANDARD:</b> Every chef gets their own private room and ingredients. <br><i>Result:</i> 100% Safe. No collisions possible.</li><li><b>Strategy 2: The Museum Display (Immutability) - ðŸ¥ˆ SILVER BULLET:</b> The recipe book is behind bulletproof glass. Chefs can read it, but no one can scribble on it. <br><i>Result:</i> 100% Safe. Read-only shared data never causes race conditions.</li><li><b>Strategy 3: The Locked Pot (Synchronization) - ðŸ¥‰ BRONZE:</b> There is one shared soup pot with a lock on the lid. <br><i>Result:</i> Safe, but Slow. Chefs must wait in line.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions & Code:</b></p><ul><li><b>Stateless Object:</b> An object with no instance variables (fields). It relies only on method arguments (Stack memory), which are inherently private to the thread.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// A. Stateless Service (The Best Way)\n// Safe because it has NO state (fields)\npublic class MathService {\n    \n    public int add(int a, int b) {\n        // 'a' and 'b' are local variables (Stack). \n        // Thread A's 'a' is totally different from Thread B's 'a'.\n        return a + b; \n    }\n}"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Immutable Object:</b> An object whose state cannot be changed after creation. All fields are <code>final</code> and there are no setters.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// B. Immutable Object (The Read-Only Way)\n// Safe because state CANNOT change\npublic final class UserConfig {\n    private final String url;\n    private final int timeout;\n\n    public UserConfig(String url, int timeout) {\n        this.url = url;\n        this.timeout = timeout;\n    }\n\n    public String getUrl() { return url; }\n    // NO SETTERS.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How do you make a Java class Thread-Safe? (The Hierarchy)</b><br><b>Answer:</b> (Always order by preference) <br>1. <b>Statelessness:</b> Can I remove the fields? (Best)<br>2. <b>Immutability:</b> Can I make fields final?<br>3. <b>Thread-Safe Tools:</b> Can I use <code>AtomicInteger</code> or <code>ConcurrentHashMap</code>?<br>4. <b>Locking:</b> If all else fails, use <code>synchronized</code>.</li><li><b>Q2: Are Spring Boot Controllers/Services Thread-Safe?</b><br><b>Answer:</b> By default, Spring beans are <b>Singletons</b> (shared by all threads). Therefore, they <b>MUST be Stateless</b>. If you put a mutable instance variable (like <code>private int count</code>) inside a Controller, it is a critical bug.</li><li><b>Q3: Is <code>SimpleDateFormat</code> thread-safe?</b><br><b>Answer:</b> <b>No.</b> It stores intermediate parsing results in instance variables. Use <code>java.time.DateTimeFormatter</code> (Immutable) instead.</li><li><b>Q4: What is <code>ThreadLocal</code>?</b><br><b>Answer:</b> It gives every thread its own private \"pocket\" for data (e.g., storing a User ID for the duration of a request), ensuring isolation without passing parameters everywhere.</li></ul>"
    }
  ]
},


  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Museum Display Analogy:</b></li><li><b>Mutable Object:</b> You leave a precious manuscript on a table. Anyone can scribble on it. To protect it, you need a guard (Lock/Synchronization).</li><li><b>Immutable Object:</b> You put the manuscript inside a <b>bulletproof glass case</b>. 1,000 people can look at it (Read) simultaneously, but no one can touch it.</li><li><b>Result:</b> You don't need a guard. It is inherently safe because it is <b>Read-Only</b>.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Immutable Object:</b> An object whose state (data) cannot be modified after it is created.</li><li><b>The Golden Rule:</b> \"If you can't change it, you can't break it.\"</li><li><b>Key Characteristics:</b><ul><li>No \"Setters\" (e.g., <code>setName()</code>).</li><li>All fields are <code>private</code> and <code>final</code>.</li><li>The class is <code>final</code> (preventing subclasses from altering behavior).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Strategy (Create vs. Modify):</b></p><ul><li>If you need to \"change\" data in an immutable object, you <b>do NOT modify</b> the existing object. Instead, you <b>create a New Copy</b> with the updated value.</li><li><i>Example:</i> <code>String</code> in Java. <code>s.toUpperCase()</code> does not change <code>s</code>; it returns a completely new String object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n\n// 1. Make class final (No subclasses allowed)\npublic final class ImmutableUser {\n    \n    // 2. Make fields private and final (Must be set in constructor)\n    private final String name;\n    private final int age;\n    private final List<String> roles;\n\n    public ImmutableUser(String name, int age, List<String> roles) {\n        this.name = name;\n        this.age = age;\n        \n        // 3. DEEP COPY (Crucial Step!)\n        // If we just said \"this.roles = roles\", the caller could modify the \n        // original list later and break our immutability.\n        this.roles = new ArrayList<>(roles);\n    }\n\n    // 4. Getters Only (No Setters)\n    public String getName() { return name; }\n    public int getAge() { return age; }\n\n    public List<String> getRoles() {\n        // Return a copy or unmodifiable view so they can't touch our internal list\n        return new ArrayList<>(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Why is String immutable in Java?</b><br><b>Answer:</b><ul><li><b>Security:</b> Strings are used for Database URLs and passwords. If mutable, a hacker could change a filename after the security check but before file access.</li><li><b>Thread-Safety:</b> Safe to share across threads without locks.</li><li><b>String Pool:</b> Caching identical strings to save memory is only possible if they never change.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q2: What is the difference between <code>final</code> and Immutable?</b><br><b>Answer:</b><ul><li><b>final:</b> Refers to the <b>Reference</b> (\"I cannot point this variable to a new object\").</li><li><b>Immutable:</b> Refers to the <b>Object Content</b> (\"The data inside this object cannot change\").</li><li><i>Trap:</i> <code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> -> You cannot say <code>list = new List()</code>, BUT you CAN say <code>list.add(\"Hack\")</code>. The list is final but Mutable.</li></ul></li><li><b>Q3: How do you handle a Date or List field inside an Immutable class?</b><br><b>Answer:</b> You must use <b>Defensive Copies</b> (Deep Copy). Copy the incoming list in the Constructor, and return a copy in the Getter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q4: What are the downsides of Immutability?</b><br><b>Answer:</b> <b>Memory Overhead.</b> Creating a new object for every small change generates \"garbage\" (e.g., String concatenation in a loop). <b>Fix:</b> Use <code>StringBuilder</code> (Mutable) for heavy editing, then convert to <code>String</code>.</li></ul>"
    }
  ]
}



  
}

















