{
  "Classes & Objects": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Class:</b> The blueprint or template. It defines the structure (attributes) and capabilities (methods) common to all objects of that type. It does not occupy memory for data (mostly) until instantiated.</li><li><b>Object:</b> The instance of the class. It is a concrete entity created based on the blueprint that occupies memory and holds specific data values.</li></ul><br><p><b>Why use them?</b></p><ul><li><b>Modeling:</b> To represent real-world entities (e.g., <code>User</code>, <code>Payment</code>, <code>Button</code>) in code.</li><li><b>Encapsulation:</b> To bundle data (state) and methods (behavior) together, protecting the internal state from unauthorized access.</li><li><b>Reusability:</b> You write the code once (Class) and create as many instances (Objects) as needed.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>State (Fields/Attributes):</b> Variables that hold data (e.g., color, speed).</li><li><b>Behavior (Methods):</b> Functions that operate on the state (e.g., <code>accelerate()</code>, <code>brake()</code>).</li><li><b>Identity:</b> Every object has a unique identity (memory address), even if two objects have the exact same data values.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Blueprint (Class)\npublic class Car {\n    // State\n    String color;\n    int speed;\n\n    // Constructor (Initialization)\n    public Car(String color) {\n        this.color = color;\n        this.speed = 0;\n    }\n\n    // Behavior\n    public void accelerate() {\n        this.speed += 10;\n    }\n}\n\n// The Usage\npublic class Main {\n    public static void main(String[] args) {\n        // 'c1' is a reference variable, 'new Car()' creates the Object in Heap\n        Car c1 = new Car(\"Red\"); \n        c1.accelerate(); \n        \n        Car c2 = new Car(\"Blue\"); // Distinct identity from c1\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Memory Allocation:</b><ul><li><b>Class:</b> Loaded into Method Area (Metaspace in modern Java).</li><li><b>Object:</b> Allocated on the <b>Heap</b>.</li><li><b>Reference:</b> The variable (e.g., <code>c1</code>) is stored on the <b>Stack</b> and points to the Heap address.</li></ul></li><li><b>The <code>this</code> keyword:</b> Refers to the current object instance. It resolves ambiguity between class fields and parameters.</li><li><b>Object Equality:</b><ul><li><code>==</code> checks if two references point to the same memory address (<b>Identity</b>).</li><li><code>.equals()</code> (if overridden) checks if two objects have the same content (<b>State</b>).</li></ul></li><li><b>Lifecycle:</b> Objects are created via constructors and destroyed by the Garbage Collector (GC) when they are no longer reachable.</li><li><b>Anemic vs. Rich Domain Models:</b><ul><li><b>Anemic:</b> Classes only have data (getters/setters) and no logic. (Common in DTOs).</li><li><b>Rich:</b> Classes contain both data and the business logic that modifies that data. (Preferred in good OOP/LLD).</li></ul></li></ul>"
      }
    ]
  },
  "Interfaces": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>An Interface is a contract:</b> It defines <i>what</i> a class can do, without specifying <i>how</i> it does it. It is a collection of abstract methods (mostly) and constants that a class must implement.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Abstraction:</b> It hides implementation details and exposes only the capability.</li><li><b>Decoupling:</b> You can change the implementation without changing the code that uses it (<i>Dependency Inversion Principle</i>).</li><li><b>Multiple Inheritance:</b> Java classes cannot extend multiple classes, but they can implement multiple interfaces.</li><li><b>Polymorphism:</b> You can treat different objects (e.g., <code>Dog</code>, <code>Cat</code>) as the same type (e.g., <code>Animal</code>) if they implement the same interface.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Methods:</b> Methods without a body (implicitly <code>public abstract</code>).</li><li><b>Constants:</b> Variables are implicitly <code>public static final</code>.</li><li><b>Java 8+ Evolution:</b><ul><li><b>Default Methods:</b> Methods with a body (using <code>default</code> keyword) to allow adding new methods without breaking existing implementations.</li><li><b>Static Methods:</b> Utility methods related to the interface.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Contract\ninterface PaymentProcessor {\n    void processPayment(double amount); // Abstract method\n    \n    // Java 8 Default method (Backward compatibility)\n    default void logTransaction() {\n        System.out.println(\"Logging tx...\");\n    }\n}\n\n// The Implementation A\nclass PaypalProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via PayPal: \" + amount);\n    }\n}\n\n// The Implementation B\nclass StripeProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via Stripe: \" + amount);\n    }\n}\n\n// Usage (Polymorphism)\nclass CheckoutService {\n    // We program to the Interface, not the implementation\n    PaymentProcessor processor; \n\n    public CheckoutService(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>\"Program to an Interface, not an Implementation\":</b> This is a golden rule in design patterns. Always use the interface type for variable references (e.g., <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>).</li><li><b>Interface Segregation Principle (ISP):</b> Clients should not be forced to depend on interfaces they do not use. It's better to have many specific interfaces (e.g., <code>Readable</code>, <code>Writable</code>) than one general-purpose interface (e.g., <code>FileHandler</code>).</li><li><b>Interface vs. Abstract Class:</b><ul><li><b>Interface:</b> Defines \"Can-Do\" capability (e.g., <code>Runnable</code>, <code>Serializable</code>). Supports multiple implementations.</li><li><b>Abstract Class:</b> Defines \"Is-A\" relationship (e.g., <code>Vehicle</code>, <code>Mammal</code>). Shares code/state among related classes.</li></ul></li><li><b>Marker Interfaces:</b> Interfaces with no methods (e.g., <code>Serializable</code>, <code>Cloneable</code>). They provide metadata to the compiler or runtime that the class is special.</li><li><b>Functional Interface:</b> An interface with exactly one abstract method. Used heavily in Lambda expressions (e.g., <code>Runnable</code>, <code>Comparator</code>).</li></ul>"
      }
    ]
  },
  "Inheritance": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Inheritance</b> is the mechanism by which one class (Child/Subclass) acquires the properties (fields) and behaviors (methods) of another class (Parent/Superclass). It establishes an \"Is-A\" relationship.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Code Reusability:</b> Write common code once in the parent class and reuse it in multiple child classes.</li><li><b>Extensibility:</b> You can extend existing logic without modifying the original class (<i>Open/Closed Principle</i>).</li><li><b>Method Overriding:</b> Child classes can provide a specific implementation of a method already defined in the parent class.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Superclass (Parent/Base):</b> The class whose features are inherited.</li><li><b>Subclass (Child/Derived):</b> The class that inherits the other class.</li><li><b><code>extends</code> Keyword:</b> Used in Java to inherit from a class.</li><li><b><code>super</code> Keyword:</b> Used to access members (methods/constructors) of the immediate parent class.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Parent Class\nclass Vehicle {\n    protected String brand = \"Ford\"; // protected: accessible to subclasses\n    public void honk() {\n        System.out.println(\"Tuut, tuut!\");\n    }\n}\n\n// Child Class\nclass Car extends Vehicle {\n    private String modelName = \"Mustang\";\n    \n    // Overriding parent behavior\n    @Override \n    public void honk() {\n        super.honk(); // Calls parent's honk first\n        System.out.println(\"Honk from \" + modelName);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.honk(); // OUTPUT: Tuut, tuut! \\n Honk from Mustang\n        // myCar.brand is accessible here only if Main is in same package or subclass\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Diamond Problem:</b> Java does not support Multiple Inheritance with Classes (inheriting from two classes that have the same method). It solves this via Interfaces.</li><li><b>Liskov Substitution Principle (LSP):</b> A child class must be substitutable for its parent class without breaking the application. If <code>Dog</code> extends <code>Animal</code>, you should be able to use <code>Dog</code> anywhere <code>Animal</code> is expected.</li><li><b>Constructors are NOT inherited:</b> But the child class constructor must call the parent constructor (implicitly or explicitly via <code>super()</code>) as the first statement.</li><li><b><code>final</code> Class:</b> If a class is marked <code>final</code>, it cannot be inherited (e.g., <code>String</code> class in Java).</li><li><b>Composition over Inheritance:</b> In modern LLD, prefer Composition (\"Has-A\") over Inheritance (\"Is-A\") if the relationship is not strictly hierarchical. Inheritance creates tight coupling; composition is more flexible.</li></ul>"
      }
    ]
  },
  "Polymorphism": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Polymorphism</b> (Greek for \"many forms\") is the ability of a single interface or method name to support different underlying forms (types or implementations). It allows objects of different classes to be treated as objects of a common superclass.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Flexibility:</b> You can write code that works with a general type (e.g., <code>Shape</code>) and it will automatically work with any new specific types you add later (e.g., <code>Pentagon</code>) without changing the code.</li><li><b>Clean Code:</b> Reduces <code>if-else</code> or <code>switch</code> statements checking for types.</li><li><b>Decoupling:</b> The caller doesn't need to know the specific class of the object it's working with.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Compile-time Polymorphism (Static Binding):</b><ul><li>Achieved via <b>Method Overloading</b>.</li><li>Same method name, different parameters (signature) within the same class.</li><li>Resolved by the compiler.</li></ul></li><li><b>Runtime Polymorphism (Dynamic Binding):</b><ul><li>Achieved via <b>Method Overriding</b>.</li><li>Same method name and parameters in a Parent and Child class.</li><li>Resolved at runtime based on the actual object created.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// 1. Compile-time (Overloading)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n\n// 2. Runtime (Overriding)\nclass Animal {\n    void speak() { System.out.println(\"Animal makes a sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void speak() { System.out.println(\"Woof\"); }\n}\n\nclass Cat extends Animal {\n    @Override\n    void speak() { System.out.println(\"Meow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Upcasting: Parent Reference -> Child Object\n        Animal myPet = new Dog(); \n        \n        // The method called depends on the OBJECT (Dog), not the reference (Animal)\n        myPet.speak(); // Output: Woof\n        \n        myPet = new Cat();\n        myPet.speak(); // Output: Meow\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Upcasting:</b> Assigning a Child object to a Parent reference (e.g., <code>Animal a = new Dog()</code>). This is safe and implicit.</li><li><b>Downcasting:</b> Assigning a Parent reference back to a Child reference (e.g., <code>Dog d = (Dog) a</code>). This requires an explicit cast and an <code>instanceof</code> check to avoid <code>ClassCastException</code>.</li><li><b>Dynamic Method Dispatch:</b> This is the mechanism Java uses at runtime to figure out which version of an overridden method to call.</li><li><b>Static methods are NOT polymorphic:</b> If you define a static method with the same name in Parent and Child, the Child hides the Parent's method (<i>Method Hiding</i>), but it does not override it. The method called depends on the reference type, not the object.</li><li><b>Fields are NOT polymorphic:</b> If a Child defines a variable with the same name as the Parent, the variable accessed depends on the reference type.</li></ul>"
      }
    ]
  },
  "Abstraction": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstraction</b> is the process of hiding the complex implementation details and showing only the essential features of an object. It focuses on <i>what</i> an object does instead of <i>how</i> it does it.</li><li><b>Analogy:</b> Think of a car. You use the steering wheel and pedals (<b>Abstraction/Interface</b>) to drive. You don't need to know how the fuel injection or combustion engine (<b>Implementation</b>) works to operate it.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Reduces Complexity:</b> It simplifies the interaction for the user (or client code) by filtering out unnecessary details.</li><li><b>Security:</b> Hides internal data and logic that shouldn't be touched directly.</li><li><b>Maintainability:</b> You can change the complex internal logic (e.g., upgrade the engine) without changing the simple interface (the steering wheel), so client code doesn't break.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated on its own (0-100% abstraction). It can have both abstract methods (no body) and concrete methods (with body).</li><li><b>Interface:</b> A pure template (100% abstraction prior to Java 8). Defines only method signatures.</li><li><b>Access Modifiers:</b> Keywords like <code>private</code> and <code>protected</code> help enforce abstraction by hiding internal members.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Abstract Class - partial abstraction\nabstract class BankService {\n    // Abstract method: Logic hidden, must be defined by child\n    abstract void calculateInterest(); \n\n    // Concrete method: Common logic shared by all\n    void login() {\n        System.out.println(\"User Logged in\");\n    }\n}\n\nclass SavingsAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 4%\");\n    }\n}\n\nclass CurrentAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 0%\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // BankService b = new BankService(); // ERROR: Cannot instantiate abstract class\n        \n        BankService myBank = new SavingsAccount();\n        myBank.login();             // Shared logic\n        myBank.calculateInterest(); // Specific logic\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation</b> is about hiding data (bundling data + methods).</li><li><b>Abstraction</b> is about hiding implementation complexity (design level).</li></ul></li><li><b>\"Is-A\" Relationship:</b> Abstract classes are still classes. Use them when child classes share a lot of code but also need specific behavior (e.g., <code>Bird</code> is an abstract class, <code>Sparrow</code> and <code>Penguin</code> extend it).</li><li><b>The 100% Rule:</b> Before Java 8, Interfaces provided 100% abstraction. Now, with default methods, this line is slightly blurred, but conceptually they are still pure contracts.</li><li><b>Design Decision:</b> If you need to add a new method in the future:<ul><li><b>Abstract Class:</b> You can add a concrete method with a default implementation, and existing child classes will work fine.</li><li><b>Interface:</b> Adding a new abstract method breaks all implementing classes (unless you use a <code>default</code> method).</li></ul></li></ul>"
      }
    ]
  },
  "Encapsulation": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Encapsulation</b> is the bundling of data (variables) and methods (functions) that operate on that data into a single unit (Class). Crucially, it involves restricting direct access to some of an object's components, often referred to as \"<i>Data Hiding</i>\".</li><li><b>Analogy:</b> Think of a medical capsule: The medicine (data) is enclosed inside the capsule shell (methods), preventing it from being consumed directly or contaminated.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Control & Validation:</b> You can validate data before assigning it. For example, preventing a generic age variable from being set to -5.</li><li><b>Security:</b> Hides internal implementation details and protects the object's integrity.</li><li><b>Flexibility (Loose Coupling):</b> You can change the internal data structure (e.g., changing a variable from <code>String</code> to <code>StringBuilder</code>) without breaking the code that uses the class, as long as the public methods remain the same.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Access Modifiers:</b> The tools used to enforce encapsulation.<ul><li><code>private</code>: Visible only within the class (Best for state).</li><li><code>protected</code>: Visible to package + subclasses.</li><li><code>public</code>: Visible to everyone (Best for methods/interface).</li><li><code>(default/package-private)</code>: Visible only within the package.</li></ul></li><li><b>Getters (Accessors):</b> Public methods to read private data.</li><li><b>Setters (Mutators):</b> Public methods to modify private data (usually with validation logic).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class User {\n    // 1. Data is Private (Hidden)\n    private String username;\n    private int age;\n\n    // 2. Public Constructor\n    public User(String username, int age) {\n        this.username = username;\n        setAge(age); // Use setter to enforce logic even during creation\n    }\n\n    // 3. Public Getters (Read-only access)\n    public String getUsername() {\n        return username;\n    }\n\n    // 4. Public Setters (Controlled Write access)\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age provided\");\n            // Optionally throw exception\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        User u = new User(\"John\", 25);\n        // u.age = -5; // ERROR: usage of private field\n        u.setAge(-5);  // Output: Invalid age provided. Data remains safe.\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Getters/Setters are NOT mandatory:</b> Pure encapsulation isn't just generating getters and setters for every field (that makes it anemic). True encapsulation often involves methods that do things (e.g., <code>activateAccount()</code> instead of <code>setStatus(\"Active\")</code>).</li><li><b>Immutability:</b> A powerful form of encapsulation. If you make all fields <code>private final</code> and provide no setters, the object state cannot change once created. This makes the code thread-safe and predictable (e.g., <code>String</code> class).</li><li><b>\"Tell, Don't Ask\":</b> A design principle related to encapsulation. Instead of asking an object for its data to perform a calculation (if <code>user.getAge() > 18</code>), tell the object to do it (if <code>user.isAdult()</code>).</li><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation:</b> Hiding Information (State).</li><li><b>Abstraction:</b> Hiding Complexity (Implementation).</li></ul></li></ul>"
      }
    ]
  },
  "Access Modifiers": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Access modifiers</b> are keywords that define the scope and visibility of a class, constructor, variable, method, or data member. They determine who can see and use a specific part of your code.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Encapsulation:</b> They are the primary tool to implement encapsulation (hiding internal state).</li><li><b>Security:</b> Prevents sensitive data or critical logic from being tampered with by external classes.</li><li><b>Maintainability:</b> By restricting access, you limit the \"blast radius\" of changes. If a method is private, you can change it freely knowing no other class relies on it.</li></ul><br><p><b>Key Components (The 4 Levels):</b></p><ul><li><b>Private (<code>private</code>):</b> Only within the Same Class. <br><i>Analogy: Your diary. Only you can read it.</i></li><li><b>Default (none):</b> Within the Same Package only. (Package-Private). <br><i>Analogy: Family fridge. Accessible to everyone in the house.</i></li><li><b>Protected (<code>protected</code>):</b> Same Package + Subclasses (even in different packages). <br><i>Analogy: Family inheritance. Kids get it even if they move out.</i></li><li><b>Public (<code>public</code>):</b> Everywhere (Global). <br><i>Analogy: A billboard. Visible to the world.</i></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// PACKAGE A\npackage com.test.a;\npublic class Parent {\n    public int publicVar = 1;\n    protected int protectedVar = 2;\n    int defaultVar = 3;   // No keyword = Default\n    private int privateVar = 4;\n    \n    public void show() {\n        // All accessible here\n        System.out.println(privateVar); \n    }\n}\n\n// PACKAGE B\npackage com.test.b;\nimport com.test.a.Parent;\n\nclass Child extends Parent {\n    void accessTest() {\n        System.out.println(publicVar);    // OK\n        System.out.println(protectedVar); // OK (Child Class)\n        // System.out.println(defaultVar);   // ERROR: Diff Package\n        // System.out.println(privateVar);   // ERROR: Private\n    }\n}\n\nclass Stranger {\n    void accessTest() {\n        Parent p = new Parent();\n        System.out.println(p.publicVar);  // OK\n        // System.out.println(p.protectedVar); // ERROR: Not a child\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Principle of Least Privilege:</b> Always start with the most restrictive modifier (<code>private</code>) and open it up (<code>protected</code> -> <code>public</code>) only when absolutely necessary. This reduces coupling.</li><li><b>Class vs. Member:</b><ul><li>Top-level classes can only be <code>public</code> or <code>default</code> (package-private). They cannot be <code>private</code> or <code>protected</code>.</li><li>Nested/Inner classes can be all four.</li></ul></li><li><b>Method Overriding Rule:</b> When overriding a method in a child class, you cannot reduce the visibility. If Parent is <code>protected</code>, Child must be <code>protected</code> or <code>public</code>. It cannot be <code>private</code>.</li><li><b>Interface Members:</b><ul><li>Variables in interfaces are implicitly <code>public static final</code>.</li><li>Methods in interfaces are implicitly <code>public</code> (unless <code>private</code> in Java 9+).</li></ul></li></ul>"
      }
    ]
  },
  "Object Lifecycle": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>The Object Lifecycle</b> describes the series of states an object goes through from its <b>Creation</b> (instantiation), to its <b>Usage</b> (performing actions), and finally to its <b>Destruction</b> (garbage collection/memory deallocation).</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Memory Management:</b> Understanding the lifecycle helps prevent <i>Memory Leaks</i> (objects staying in memory when no longer needed).</li><li><b>Resource Management:</b> Ensures external resources (file handles, database connections) are opened and closed correctly.</li><li><b>Performance:</b> Knowing how objects are promoted (e.g., from Young to Old Generation in Java) helps in tuning application performance.</li></ul><br><p><b>Key Components (The 3 Stages):</b></p><ul><li><b>Creation (Initialization):</b><ul><li><b>Loading:</b> The <code>.class</code> file is loaded into the Method Area.</li><li><b>Allocation:</b> Memory is allocated on the <b>Heap</b> for the object.</li><li><b>Initialization:</b> The constructor is called to initialize the state.</li></ul></li><li><b>Usage (Live):</b> The object is referenced by a variable on the <b>Stack</b> or by another live object. It actively performs tasks.</li><li><b>Destruction (Death):</b><ul><li><b>Unreachable:</b> All references to the object are removed (e.g., set to <code>null</code> or out of scope).</li><li><b>Garbage Collection (GC):</b> The GC identifies the object as unreachable and reclaims the memory.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "class Report {\n    String data;\n    \n    public Report() {\n        System.out.println(\"1. Object Created (Constructor)\");\n    }\n    \n    public void print() {\n        System.out.println(\"2. Object in Use\");\n    }\n\n    // Deprecated in modern Java, but good for understanding lifecycle concepts\n    @Override\n    protected void finalize() { \n        System.out.println(\"3. Object Destroyed/GC'd\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Step 1: Creation\n        Report r = new Report(); \n        \n        // Step 2: Usage\n        r.print();\n        \n        // Step 3: Making Eligible for Destruction\n        r = null; // Reference broken. Object is now \"Unreachable\"\n        \n        // Requesting GC (Note: This is just a request, not a command)\n        System.gc(); \n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Stack vs. Heap:</b><ul><li><b>Local Variables</b> (references) live on the <b>Stack</b>.</li><li><b>Objects</b> (actual data) live on the <b>Heap</b>.</li><li>When a stack frame (method) ends, the references pop off, leaving the heap objects eligible for GC if no other references exist.</li></ul></li><li><b>Reachability:</b> An object is only garbage collected if there is no chain of references leading to it from a \"GC Root\" (active thread, static variable, local variable).</li><li><b>Generational GC:</b><ul><li><b>Eden Space:</b> Where new objects are born.</li><li><b>Survivor Space:</b> Objects that survive a GC cycle.</li><li><b>Old/Tenured Gen:</b> Long-lived objects (caches, singletons) move here.</li></ul></li><li><b><code>finalize()</code> is Deprecated:</b> Never rely on <code>finalize()</code> for cleanup (it's unpredictable). Use <code>try-with-resources</code> (<code>AutoCloseable</code> interface) for deterministic cleanup of resources like streams or connections.</li><li><b>Static Variables:</b> These live for the entire life of the application (Class Lifecycle), effectively acting as GC Roots. Be carefulâ€”they are a common source of memory leaks.</li></ul>"
      }
    ]
  },
  "Stack vs Heap": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p>These are the two main areas of memory used by a program.<br><ul><li><b>Stack:</b> A structured, temporary scratchpad for method execution. It stores local primitives and reference variables. It follows the <b>LIFO</b> (Last-In, First-Out) order.</li><li><b>Heap:</b> A large, unstructured pool for dynamic data storage. It stores actual <b>Objects</b> and JRE classes. Memory here is managed by the Garbage Collector.</li></ul><br><p><b>Why use them? (The Roles)</b></p><ul><li><b>Stack (Control Flow):</b> Used to track \"where am I in the code?\". It manages function calls, parameters, and return addresses automatically. When a method finishes, its block is instantly cleared.</li><li><b>Heap (Data Persistence):</b> Used when data needs to live longer than a single function call or when the size of data isn't known at compile time (e.g., a list that grows based on user input).</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Structure:</b> Stack is Linear (LIFO); Heap is Hierarchical/Complex (Young/Old Gen).</li><li><b>Visibility:</b> Stack is <b>Thread-safe</b> (private to each thread). Heap is <b>Shared</b> (all threads share the same Heap, requires synchronization).</li><li><b>Speed:</b> Stack has extremely fast access. Heap is slower due to complex allocation and lookup.</li><li><b>Life Span:</b> Stack is short-lived (method execution). Heap is long-lived (until GC).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class MemoryDemo {\n    public static void main(String[] args) { // Main Stack Frame starts\n        int x = 10;           // 'x' (primitive) stored directly on Stack\n        int y = 20;           // 'y' (primitive) stored directly on Stack\n        \n        Person p = new Person(\"Alice\"); \n        // 1. 'new Person(\"Alice\")' -> Creates Object in HEAP\n        // 2. 'p' (reference variable) -> Stored on STACK, pointing to Heap address\n        \n        print(p); \n    } // Main Stack Frame pops off (x, y, p are gone). Heap object becomes eligible for GC.\n\n    public static void print(Person p) { // New Stack Frame created\n        // 'p' here is a copy of the reference, pointing to same Heap Object\n        System.out.println(p.name);\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The References Rule:</b><ul><li><b>Primitives (int, boolean):</b> Value sits directly on the <b>Stack</b> (if local).</li><li><b>Objects (String, List, Car):</b> The <b>Reference</b> sits on the Stack, but the <b>Actual Data</b> sits in the <b>Heap</b>.</li></ul></li><li><b>The Errors:</b><ul><li><b>StackOverflowError:</b> Happens due to deep/infinite recursion. The stack runs out of space for new frames.</li><li><b>OutOfMemoryError (Java Heap Space):</b> Happens when you create too many objects and the GC cannot free up enough space.</li></ul></li><li><b>String Pool:</b> A special area inside the Heap to store String literals for reusability.</li><li><b>Thread Safety:</b> Since Stack is private to a thread, local variables are inherently thread-safe. Heap objects are shared, so if multiple threads modify the same object, you need <b>Locks/Synchronization</b>.</li></ul>"
      }
    ]
  },
  "Association": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Association</b> is a structural relationship that defines a link between objects of one class and objects of another. It represents a \"Has-A\" or \"Uses-A\" relationship.</li><li>It is the most general term for connection; <b>Aggregation</b> and <b>Composition</b> are specific, stricter types of Association.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Modularity:</b> It allows classes to be independent but still interact. A <code>Teacher</code> class doesn't need to be inside a <code>Student</code> class, but they need to be associated.</li><li><b>Reusability:</b> You can reuse independent classes in different relationships (e.g., a <code>User</code> class can be associated with <code>Order</code> in one context and <code>Comment</code> in another).</li><li><b>Navigation:</b> It defines the direction of data flow (Unidirectional vs. Bidirectional).</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Cardinality (Multiplicity):</b> Defines \"how many.\"<ul><li><b>One-to-One:</b> One User has one Profile.</li><li><b>One-to-Many:</b> One Teacher teaches multiple Students.</li><li><b>Many-to-Many:</b> Many Students take many Courses.</li></ul></li><li><b>Direction:</b><ul><li><b>Unidirectional:</b> <code>Order</code> knows about <code>Customer</code>, but <code>Customer</code> doesn't strictly need to track every <code>Order</code> object internally.</li><li><b>Bidirectional:</b> Both classes hold references to each other (requires careful management to avoid infinite loops).</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Unidirectional Association (Bank -> Employee)\nclass Employee {\n    String name;\n    public Employee(String name) { this.name = name; }\n}\n\nclass Bank {\n    String name;\n    // Association: Bank \"Has-Many\" Employees\n    List<Employee> employees; \n\n    public Bank(String name) {\n        this.name = name;\n        this.employees = new ArrayList<>();\n    }\n    \n    public void addEmployee(Employee e) {\n        employees.add(e);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Employee e1 = new Employee(\"Alice\");\n        Bank b1 = new Bank(\"HDFC\");\n        \n        // Establishing the link\n        b1.addEmployee(e1); \n        \n        // Note: If Bank is destroyed, Employee CAN exist independently \n        // (This distinguishes generic Association/Aggregation from Composition)\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Lifecycle dependency is key:</b> In a generic Association, there is no owner. The objects have their own independent lifecycles. If you delete one, the other survives.</li><li><b>Reflexive Association:</b> A class can be associated with itself.<br><i>Example:</i> An <code>Employee</code> class having a field <code>supervisor</code> which is also of type <code>Employee</code>.</li><li><b>Association vs. Dependency:</b><ul><li><b>Association:</b> Stronger. Class A holds a reference to Class B as a field/variable (state).</li><li><b>Dependency:</b> Weaker. Class A uses Class B only as a parameter in a method or a local variable, but doesn't hold onto it.</li></ul></li><li><b>Mapping:</b> In databases (SQL), associations are implemented using Foreign Keys and Join Tables.</li></ul>"
    }
  ]
},
  "Aggregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Aggregation</b> is a specialized form of Association. It represents a \"Whole-Part\" relationship (Has-A), but with <b>Weak Ownership</b>.</li><li>The \"Part\" (Child) can exist independently of the \"Whole\" (Parent). If the Parent is destroyed, the Child survives.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Shared Resources:</b> Use it when an object needs to be part of a group but might belong to multiple groups or exist on its own.</li><li><b>Decoupled Lifecycles:</b> When destroying the container shouldn't destroy the items inside.</li><li><b>Real-world analogy:</b> A Team and Players. If the Team is dissolved, the Players don't die; they become free agents or join other teams.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Container (Whole):</b> Holds the reference to the collection of items.</li><li><b>The Component (Part):</b> The item being held.</li><li><b>Independent Lifecycle:</b> The key differentiator from Composition. The child is usually passed into the parent via the constructor or a setter (external creation).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Player {\n    String name;\n    public Player(String name) { this.name = name; }\n}\n\nclass Team {\n    String teamName;\n    List<Player> players; // Aggregation\n\n    public Team(String teamName, List<Player> players) {\n        this.teamName = teamName;\n        this.players = players; // Players are created OUTSIDE and passed in\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Create Parts independently\n        Player p1 = new Player(\"Dhoni\");\n        Player p2 = new Player(\"Kohli\");\n\n        // 2. Create Whole and add Parts\n        List<Player> squad = new ArrayList<>(Arrays.asList(p1, p2));\n        Team india = new Team(\"India\", squad);\n        \n        // 3. Destruction Scenario\n        india = null; // Team is destroyed\n        \n        // p1 and p2 STILL EXIST. They were not destroyed with the Team.\n        System.out.println(p1.name); // Works fine\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with an <b>Empty (White) Diamond</b> on the container side.<br><code>Team &lt;&gt;------- Player</code></li><li><b>Parameter Injection:</b> In Aggregation, objects are usually passed into the class (Dependency Injection) rather than being created inside the class using <code>new</code>.</li><li><b>Vs. Composition:</b> Ask this question: \"If I delete the Parent, does the Child die too?\"<ul><li><b>If No -> Aggregation</b> (e.g., Car and Driver).</li><li><b>If Yes -> Composition</b> (e.g., Car and Engine - conceptually, for that specific car).</li></ul></li></ul>"
    }
  ]
},
  "Composition": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Composition</b> is a restricted form of Aggregation. It represents a strong \"Whole-Part\" relationship.</li><li><b>Strong Ownership:</b> The \"Part\" (Child) belongs exclusively to the \"Whole\" (Parent).</li><li><b>Dependent Lifecycle:</b> If the Parent is destroyed, the Child is also destroyed. The child cannot exist independently.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Logical Consistency:</b> Use it when the parts have no meaning outside the whole (e.g., a <code>Room</code> has no identity without a <code>House</code>).</li><li><b>Encapsulation:</b> The parent strictly controls the creation and access of the child components.</li><li><b>Flexibility:</b> It is preferred over Inheritance (\"Composition over Inheritance\") because it allows you to assemble complex behaviors dynamically without the rigidity of class hierarchies.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Owner:</b> The class that manages the lifecycle.</li><li><b>Internal Creation:</b> The child objects are usually created inside the parent's constructor using <code>new</code>. They are not passed in from the outside.</li><li><b>Cascading Delete:</b> Logic that ensures cleaning up the parent cleans up the children.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Room {\n    String type;\n    public Room(String type) { this.type = type; }\n}\n\nclass House {\n    private final List<Room> rooms; // Composition\n\n    public House() {\n        // Rooms are created INSIDE the House. \n        // If House dies, nobody else holds a reference to these specific rooms.\n        this.rooms = new ArrayList<>();\n        this.rooms.add(new Room(\"Bedroom\"));\n        this.rooms.add(new Room(\"Kitchen\"));\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        House myHouse = new House();\n        \n        // 1. Destruction Scenario\n        myHouse = null; \n        \n        // The 'Room' objects created inside myHouse are now unreachable.\n        // They will be Garbage Collected along with the House.\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with a <b>Filled (Black) Diamond</b> on the container side.<br><code>House &lt;#&gt;------- Room</code></li><li><b>The \"Death\" Test:</b><ul><li>If you delete the <code>Order</code>, do the <code>LineItems</code> disappear? <b>Yes (Composition)</b>.</li><li>If you delete the <code>School</code>, do the <code>Students</code> disappear? <b>No (Aggregation)</b>.</li></ul></li><li><b>Composition over Inheritance:</b> This is a major design principle.<ul><li><b>Inheritance:</b> You inherit everything (good and bad) and it's static (fixed at compile time).</li><li><b>Composition:</b> You only include what you need, and you can change behavior at runtime (by swapping the composed object).</li></ul></li></ul>"
    }
  ]
},
  "Composition over Inheritance": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This principle states that classes should achieve code reuse by containing instances of other classes (Composition) rather than inheriting from them.</li><li>It attacks the biggest flaw of inheritance: <b>Tight Coupling</b>.</li></ul><br><p><b>The \"Banana, Gorilla & Jungle\" Problem:</b></p>(This is the most important analogy to remember)<br>Joe Armstrong (creator of Erlang) famously explained why Inheritance is dangerous:<br><i>\"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\"</i><ul><li><b>The Banana:</b> The small piece of functionality you actually needed (e.g., a method <code>calculateTax()</code>).</li><li><b>The Gorilla:</b> The Parent Class (<code>TaxCalculator</code>) that owns the method.</li><li><b>The Jungle:</b> The entire inheritance tree and all the extra data/dependencies the Parent Class carries with it (Grandparents, heavy database connections, unnecessary state).</li></ul><br>Inheritance forces you to load the whole jungle just to eat one banana. <b>Composition lets you just pick the banana.</b><br><br><p><b>Why use Composition?</b></p><ul><li><b>Precision:</b> You pick exactly the behaviors you want. You don't inherit \"baggage\" (variables or methods you don't need).</li><li><b>Flexibility:</b> You can change behaviors at runtime.<br><i>Inheritance:</i> You are born a Dog. You stay a Dog forever.<br><i>Composition:</i> You are an entity holding a <code>SoundBehavior</code>. You can swap it from \"Bark\" to \"Howl\" instantly.</li><li><b>Safety:</b> You avoid the <b>Fragile Base Class</b> problem. Changes in a superclass won't unexpectedly break your subclass because you aren't inextricably linked to its internal structure.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Jungle Way (Inheritance)\n\n// The Jungle (Huge, heavy class)\nclass BigHeavyService {\n    void connectDB() { ... } // Heavy logic\n    void logAnalytics() { ... } // Heavy logic\n    int add(int a, int b) { return a + b; } // THE BANANA (The only thing we want)\n}\n\n// The Gorilla holding the Banana\nclass MyCalculator extends BigHeavyService {\n    // I just wanted 'add()', but now I have DB connections and Analytics \n    // attached to my simple Calculator object. This is wasteful and risky.\n}"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Banana Way (Composition)\n\nclass Adder {\n    int add(int a, int b) { return a + b; } // Just the Banana\n}\n\nclass MyCalculator {\n    private Adder adder = new Adder(); // HAS-A relationship\n    \n    // I delegate the work to the specific component I need.\n    // No Jungle attached.\n    int calculate(int a, int b) {\n        return adder.add(a, b);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember:</b></p><ul><li><b>Is-A vs Has-A:</b><ul><li>If you can say \"A Manager is a Person\" -> Inheritance might be okay.</li><li>If you can say \"A Car has an Engine\" -> Use Composition.</li></ul></li><li><b>The \"Final\" Solution:</b> Many modern languages (like Kotlin or Rust) or libraries make classes <code>final</code> by default to force you to use Composition instead of trying to inherit.</li><li><b>Testing is Easier:</b> In Composition, you can easily mock the <code>Adder</code> component to test <code>MyCalculator</code>. In Inheritance, you often can't mock the Parent class easily without initializing its complex state.</li></ul>"
    }
  ]
},
  "Diamond Problem": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Diamond Problem</b> is an ambiguity that arises in Multiple Inheritance when a class inherits from two classes that both descend from the same superclass.</li><li>If the top superclass (\"Grandparent\") has a method, and both intermediate classes (\"Parents\") override it, the final subclass (\"Child\") doesn't know which version of the method to inherit.</li></ul><br><p><b>The Problem (Why is it tricky?)</b></p><ul><li><b>Ambiguity:</b> If Class B and Class C both extend Class A and override method <code>run()</code>, and Class D extends both B and C... when you call <code>d.run()</code>, should it run B's version or C's version? The compiler cannot decide.</li><li><b>Complexity:</b> It complicates method dispatch and memory layout (e.g., in C++, it can lead to multiple copies of the Grandparent class in memory unless \"virtual inheritance\" is used).</li></ul><br><p><b>Key Components (The Shape):</b></p><ul><li>The inheritance hierarchy looks like a diamond:<br><b>A</b> (Top / Grandparent)<br><b>B extends A</b> & <b>C extends A</b> (Middle / Parents)<br><b>D extends B, C</b> (Bottom / Child)</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "interface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from C\"); }\n}\n\n// PROBLEM: D implements both B and C. Both have 'hello()'.\n// COMPILER ERROR: \"class D inherits unrelated defaults for hello()...\"\nclass D implements B, C {\n    \n    // RESOLUTION: You MUST override the method to resolve ambiguity.\n    @Override\n    public void hello() {\n        // Option 1: Define new logic\n        // System.out.println(\"Hello from D\"); \n        \n        // Option 2: Explicitly choose a parent using 'super'\n        B.super.hello(); \n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        new D().hello(); // Output: Hello from B\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Why Java banned multiple class inheritance:</b> Specifically to avoid this ambiguity and keep the language simple (simplicity was a major design goal of Java vs. C++).</li><li><b>Interface Resolution Rules:</b> If there is a conflict between interfaces:<ul><li><b>Classes win:</b> If a class extends a Parent and implements an Interface, the Parent's method always wins (Rule of \"Class wins\").</li><li><b>Sub-interfaces win:</b> If B extends A, B is more specific.</li><li><b>Explicit Override:</b> If there is no clear winner (like the code above), the compiler forces you to override and clarify.</li></ul></li><li><b>Composition is the fix:</b> If you genuinely need behavior from two different classes, don't try to inherit from both. Have one class as a field inside your new class (Composition).</li></ul>"
    }
  ]
},
  "Dynamic Dispatch": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Dynamic Dispatch</b> (or Dynamic Method Dispatch) is the mechanism by which a call to an overridden method is resolved at <b>runtime</b> rather than compile-time.</li><li>The compiler doesn't know which method implementation to call; the JVM decides at the last moment based on the <i>actual object</i> being referred to, not the variable type.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Enables Polymorphism:</b> It is the technical engine that makes runtime polymorphism possible.</li><li><b>Extensibility:</b> You can add new subclasses (e.g., a new plugin) without recompiling the code that calls the plugin methods. The dispatch mechanism automatically finds the new code.</li><li><b>Cleaner Code:</b> Replaces massive <code>if (obj instanceof TypeA) ... else if (obj instanceof TypeB)</code> blocks.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Upcasting:</b> A Reference Variable of a Parent class holding an Object of a Child class.</li><li><b>Overriding:</b> The Child class must provide a specific implementation of a method defined in the Parent.</li><li><b>Virtual Method Table (vtable):</b> (Under the hood) The JVM maintains a table of method addresses for each class. When a method is called, it looks up the address in this table for the specific object type to find the correct code.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class GameCharacter {\n    void attack() { System.out.println(\"Basic Punch\"); }\n}\n\nclass Warrior extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Sword Slash\"); }\n}\n\nclass Archer extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Shoot Arrow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Compile time: 'c' is just a GameCharacter reference.\n        GameCharacter c;\n        \n        // 2. Runtime: The object is actually a Warrior.\n        c = new Warrior();\n        \n        // 3. Dynamic Dispatch: JVM checks heap object (Warrior) -> calls Sword Slash\n        c.attack(); \n        \n        // 4. Runtime: The object changes to Archer.\n        c = new Archer();\n        \n        // 5. Dynamic Dispatch: JVM checks heap object (Archer) -> calls Shoot Arrow\n        c.attack();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Does NOT apply to Static Methods:</b> Static methods are bound at compile-time (<i>Static Dispatch</i>) based on the reference type. You cannot override static methods (only hide them).</li><li><b>Does NOT apply to Private/Final Methods:</b> These cannot be overridden, so the compiler knows exactly which method to call at compile-time (Optimization).</li><li><b>Does NOT apply to Instance Variables:</b> Data is not polymorphic. If Parent and Child both have a variable <code>int x</code>, <code>parentRef.x</code> will always access the Parent's variable, even if the object is a Child.</li><li><b>Double Dispatch:</b> In some patterns (like <b>Visitor</b>), you need to dispatch based on two object types (the visitor and the element). Java only supports <b>Single Dispatch</b> (based on the receiver object), so we simulate Double Dispatch using two method calls.</li></ul>"
    }
  ]
},
  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Immutability:</b> An object is Immutable if its internal state (data) cannot be modified after it is created. Once initialized, it remains constant for its entire lifecycle. If you want to change something, you must create a new object.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Thread Safety:</b> Since the state cannot change, multiple threads can access the object simultaneously without synchronization (no locking needed).</li><li><b>Hash Keys:</b> They make perfect keys for <code>HashMap</code> or <code>HashSet</code>. If the key object changed (mutable), its hashcode would change, and you would lose the value in the map.</li><li><b>Caching:</b> You can safely cache and share references without worrying that one caller will modify the data and affect others.</li></ul><br><p><b>Key Components (The Recipe):</b></p>To create an immutable class in Java:<br><ul><li><b><code>final</code> Class:</b> Prevent subclasses (which might be mutable).</li><li><b><code>private final</code> Fields:</b> Ensure fields are assigned once and not accessible directly.</li><li><b>No Setters:</b> Remove any methods that modify state.</li><li><b>Deep Copy:</b> If the class holds a Mutable object (like a <code>List</code> or <code>Date</code>), you must perform a defensive copy in the Constructor and the Getter.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Final class\npublic final class ImmutableUser {\n    \n    // 2. Private Final fields\n    private final String name;\n    private final List<String> roles; \n\n    public ImmutableUser(String name, List<String> roles) {\n        this.name = name;\n        // 3. Defensive Copy (In): Don't trust the list passed by the caller\n        this.roles = new ArrayList<>(roles);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 4. No Setters\n    \n    public List<String> getRoles() {\n        // 5. Defensive Copy (Out): Return a copy or unmodifiable view\n        // return new ArrayList<>(roles);\n        return Collections.unmodifiableList(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>String is Immutable:</b> This is the most famous example. <code>String s = \"A\"; s = \"B\";</code> does not change \"A\"; it creates a new string \"B\" and points <code>s</code> to it.</li><li><b>Shallow vs. Deep Immutability:</b><ul><li><b>Shallow:</b> The fields are final, but they point to mutable objects (e.g., an immutable <code>Student</code> class holding a mutable <code>Address</code> object). This is dangerous.</li><li><b>Deep:</b> The object and everything it points to is immutable.</li></ul></li><li><b>Memory Overhead:</b> Since you create new objects for every change, it can generate garbage (pressure on GC). However, modern GCs are very efficient at collecting short-lived objects.</li><li><b>Builder Pattern:</b> Often used to construct complex immutable objects cleanly since you can't use setters after creation.</li></ul>"
    }
  ]
},
  "Abstract Class vs Interface": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated and is used to define a base for subclasses. It represents an \"Is-A\" relationship (Identity).</li><li><b>Interface:</b> A contract that defines a set of behaviors. It represents a \"Can-Do\" relationship (Capability).</li></ul><br><p><b>Why use them? (The Choice)</b></p><ul><li><b>Use Abstract Class when:</b> You want to share code and state (variables) among closely related classes (e.g., <code>Car</code> and <code>Truck</code> sharing <code>fuelLevel</code> and <code>startEngine()</code>).</li><li><b>Use Interface when:</b> You want to define a common capability for unrelated classes (e.g., <code>Bird</code> and <code>Airplane</code> both implement <code>Flyable</code>). It enables loose coupling.</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Relationship:</b> Abstract Class is \"Is-A\" (Inheritance); Interface is \"Can-Do\" (Capability).</li><li><b>State (Fields):</b> Abstract Class can have private, protected, non-static, mutable fields. Interface has only <code>public static final</code> (Constants) and no instance state.</li><li><b>Inheritance:</b> Abstract Class supports <b>Single Inheritance</b> (extends one class). Interface supports <b>Multiple Inheritance</b> (implements many).</li><li><b>Constructors:</b> Abstract Class has constructors to initialize state. Interface cannot have constructors.</li><li><b>Access Modifiers:</b> Abstract methods can be public, protected, private. Interface methods are implicitly <code>public</code> (Java 9 allows private for internal logic).</li><li><b>Speed:</b> Abstract Class is slightly faster (direct binding). Interface is slightly slower (lookup in interface table).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Abstract Class: Defines Identity & Shared State\nabstract class Animal {\n    String name; // State\n    \n    public Animal(String name) { this.name = name; } // Constructor\n    \n    abstract void makeSound(); // Abstract method\n    \n    void sleep() { // Concrete shared method\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\n// 2. Interface: Defines Capability\ninterface Pet {\n    void play(); // Abstract contract\n}\n\n// 3. Concrete Class: Combines both\nclass Dog extends Animal implements Pet {\n    public Dog(String name) { super(name); }\n    \n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n    \n    @Override\n    public void play() { System.out.println(\"Fetching ball\"); }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Java 8+ Blur:</b> With <code>default</code> and <code>static</code> methods in Interfaces, you can add code to interfaces. However, you still cannot have instance variables (state) in interfaces. State is the main tie-breaker.</li><li><b>Versioning:</b><ul><li>Adding a method to an <b>Interface</b> breaks all implementing classes (unless you make it <code>default</code>).</li><li>Adding a concrete method to an <b>Abstract Class</b> is safe (all children inherit it automatically).</li></ul></li><li><b>Design Rule:</b> \"Favor Interfaces over Abstract Classes\" (Item 20 in <i>Effective Java</i>). Use Abstract Classes only when you explicitly need to share variables or strictly control the hierarchy.</li><li><b>Marker Interface:</b> An interface with no methods (e.g., <code>Serializable</code>) used purely to \"mark\" a class with a specific property.</li></ul>"
    }
  ]
},
  "ER Diagrams": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>An <b>ER Diagram</b> (Entity-Relationship Diagram) is the structural blueprint of a database. It abstracts away technical details (like SQL types) to focus on the data and how it connects (the \"Nouns\" and \"Verbs\").</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Entities (The Nouns):</b><ul><li><b>Strong Entity:</b> Has its own Primary Key (Identity). Symbol: Single Rectangle. (e.g., <code>Student</code>).</li><li><b>Weak Entity:</b> Depends on a \"Strong Entity\" for existence. Does not have a full PK. Symbol: Double Rectangle. (e.g., <code>Apartment</code> needs <code>Building</code>).</li><li><b>Associative Entity:</b> An entity formed by resolving a Many-to-Many relationship. (e.g., <code>Enrollment</code> connecting Student and Course).</li></ul></li><li><b>Attributes (The Adjectives):</b><ul><li><b>Key Attribute:</b> Unique ID (Primary Key). Symbol: Underlined Text.</li><li><b>Composite:</b> Can be divided into sub-parts (e.g., <code>Address</code> -> City, Zip). Physical DBs store the sub-parts.</li><li><b>Multivalued:</b> Can have multiple values (e.g., <code>PhoneNumbers</code>). Symbol: Double Oval.</li><li><b>Derived:</b> Calculated from other attributes (e.g., Age from DOB). Symbol: Dashed Oval.</li></ul></li><li><b>Relationships (The Verbs):</b><ul><li><b>Binary:</b> Between two entities (Most common).</li><li><b>Recursive (Unary):</b> An entity relates to itself (e.g., Employee manages Employee). Symbol: Line looping back to same entity.</li><li><b>Generalization (IS-A):</b> Inheritance in DBs. A Superclass (Vehicle) has Subclasses (Car, Truck). Symbol: Triangle pointing to Superclass.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Cardinality & Participation (The Rules):</b></p><ul><li><b>Cardinality (Maximums - \"How many?\"):</b><ul><li><b>1:1 (One-to-One):</b> CEO manages Company.</li><li><b>1:N (One-to-Many):</b> Customer places Orders. (Most common).</li><li><b>M:N (Many-to-Many):</b> Actor acts in Movies.</li></ul></li><li><b>Participation (Minimums - \"Must they?\"):</b><ul><li><b>Total (Mandatory):</b> Every entity must be involved (e.g., Every Loan must belong to a Bank). Symbol: Double Line.</li><li><b>Partial (Optional):</b> Not every entity needs to be involved (e.g., Not every Employee manages a Department). Symbol: Single Line.</li></ul></li></ul><br><p><b>Notation Reality Check:</b></p><ul><li><b>Chen Notation:</b> Uses Diamonds & Ovals. Good for academic exams/whiteboarding.</li><li><b>Crow's Foot Notation:</b> Uses Forks & Circles. Standard for Industry LLD & SQL Tools.<br><code>||</code> (Exactly One), <code>|&lt;</code> (One or More), <code>0|</code> (Zero or One), <code>0&lt;</code> (Zero or More).</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- The M:N Trap: You cannot implement Many-to-Many in physical SQL.\n-- You must create a Join Table (Associative Entity).\n\n-- Logical: [Student] M <---> N [Course]\n\n-- Physical Implementation:\nCREATE TABLE Student (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100)\n);\n\nCREATE TABLE Course (\n    course_id INT PRIMARY KEY,\n    title VARCHAR(100)\n);\n\n-- The Associative Entity (Join Table)\nCREATE TABLE Enrollment (\n    enrollment_id INT PRIMARY KEY,\n    student_id INT,\n    course_id INT,\n    grade CHAR(1),\n    FOREIGN KEY (student_id) REFERENCES Student(student_id),\n    FOREIGN KEY (course_id) REFERENCES Course(course_id)\n);"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The M:N Trap:</b> You cannot implement a Many-to-Many relationship in a physical SQL database. You must create a <b>Join Table</b> (Associative Entity) to break it into two 1:N relationships.</li><li><b>Identifying Weak Entities:</b> Ask: \"If I delete the Parent, does this child disappear entirely and lose its identity?\" If yes, it's a <b>Weak Entity</b> (e.g., <code>InvoiceLineItem</code> inside <code>Invoice</code>).</li><li><b>Normalization:</b> ER Diagrams should typically reflect <b>3rd Normal Form (3NF)</b>. Avoid storing attributes in the wrong entity (e.g., <code>SupplierAddress</code> should be in <code>Supplier</code>, not <code>Product</code>).</li><li><b>Naming Convention:</b> Use <b>Singular Nouns</b> for Entities (<code>User</code>, not <code>Users</code>) and <b>Verbs</b> for Relationships (<code>Owns</code>, <code>Completes</code>).</li></ul>"
    },
     {
        "type": "gallery",
        "urls": [
          "images/erdiagram3.png",
          "images/erdiagram.png",
          "images/erdiagram2.png"
        ],
        "caption": ""
      }
  ]
},

  "Normalization": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Normalization</b> is the process of organizing columns and tables in a database to reduce data redundancy (duplication) and improve data integrity.</li><li>It is essentially \"Clean Code\" for Data. You break large, messy tables into smaller, focused tables and link them using relationships.</li></ul><br><p><b>Why use it? (The 3 Anomalies)</b></p>We normalize to avoid \"Anomalies\"â€”logical errors that happen when data is duplicated.<br><i>Imagine a single table: <code>Student_Course_Table</code> storing Student Name, Course Name, and Instructor Name.</i><ul><li><b>Update Anomaly:</b> If \"Professor Snape\" changes his phone number, and he teaches 100 students, you have to update 100 rows. If you miss one, your data is inconsistent.</li><li><b>Insertion Anomaly:</b> You cannot add a new Course (e.g., \"Defense Against Dark Arts\") unless a student enrolls in it, because the Primary Key includes <code>Student_ID</code>. No student = No course record.</li><li><b>Deletion Anomaly:</b> If the only student in \"History of Magic\" drops the class, you delete the row. Poof! You just lost the information that \"History of Magic\" exists as a course.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Normal Forms (The Steps):</b></p>There is a famous mnemonic by database pioneer Bill Kent to remember the first three rules:<br><i>\"The data depends on the Key (1NF), the Whole Key (2NF), and Nothing But the Key (3NF)... so help me Codd.\"</i><br><br><ul><li><b>First Normal Form (1NF) - \"Atomic Values\":</b><ul><li><b>Rule:</b> Every cell must hold a single value. No lists, arrays, or comma-separated strings.</li><li><b>Bad:</b> A column <code>Skills</code> containing \"Java, Python, C++\".</li><li><b>Good:</b> A separate table <code>User_Skills</code> with one row per skill.</li></ul></li><li><b>Second Normal Form (2NF) - \"No Partial Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 1NF.</li><li><b>The Issue:</b> This usually applies when you have a <b>Composite Primary Key</b> (a key made of 2+ columns).</li><li><b>Rule:</b> Non-key columns must depend on the <i>entire</i> primary key, not just part of it.</li></ul></li><li><b>Third Normal Form (3NF) - \"No Transitive Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 2NF.</li><li><b>The Issue:</b> A non-key column depends on another non-key column.</li><li><b>Rule:</b> A column should depend <i>only</i> on the Primary Key.</li></ul></li><li><b>Boyce-Codd Normal Form (BCNF):</b> A stricter version of 3NF. It handles rare cases where a Primary Key column depends on a Non-Key column.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- 2NF Example: Fix Partial Dependency\n-- Scenario: Composite PK is (Student_ID, Course_ID)\n\n-- BAD (Violation): Student_Name depends ONLY on Student_ID, not Course_ID.\nTable Grades {\n    Student_ID (PK),\n    Course_ID (PK),\n    Student_Name, -- Partial Dependency!\n    Grade\n}\n\n-- GOOD (Normalized):\nTable Students {\n    Student_ID (PK),\n    Student_Name\n}\nTable Grades {\n    Student_ID (FK),\n    Course_ID (FK),\n    Grade\n}\n\n-- 3NF Example: Fix Transitive Dependency\n-- Scenario: PK is Order_ID\n\n-- BAD (Violation): City depends on Zip_Code, which depends on Order_ID.\n-- Chain: Order_ID -> Zip_Code -> City\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code,\n    City -- Transitive Dependency!\n}\n\n-- GOOD (Normalized):\nTable Locations {\n    Zip_Code (PK),\n    City\n}\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code (FK)\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Denormalization (The Reality Check):</b></p><ul><li>In LLD and System Design, we sometimes intentionally break these rules. This is called <b>Denormalization</b>.</li><li><b>Why?</b> Normalization requires <b>JOINS</b>. To get a User's profile, address, and recent orders in 3NF, you might need 3-4 Joins. This is slow for reading.</li><li><b>Trade-off:</b><ul><li><b>Normalized:</b> Fast Writes (no duplication to update), Slow Reads (Joins), Consistent Data.</li><li><b>Denormalized:</b> Fast Reads (Pre-joined data), Slow Writes (update everywhere), Risk of Inconsistency.</li></ul></li></ul><br><p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>3NF is the Gold Standard:</b> For most generic backend interviews and \"clean\" designs, aim for 3NF. Going to 4NF or 5NF is usually academic overkill.</li><li><b>Identifying dependencies is key:</b> Ask \"Does knowing X tell me Y?\" If knowing <code>ZipCode</code> tells you the <code>City</code>, then City is dependent on ZipCode. If ZipCode is not the Primary Key, move City out!</li><li><b>NoSQL is often Denormalized:</b> In MongoDB or Cassandra, we often store the Address object inside the User document (breaking 1NF/3NF). We accept the redundancy to avoid Joins.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/Normalization.png"
        ],
        "caption": ""
      }
  ]
},

  "Entity vs Value Object": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This is a fundamental distinction in Domain-Driven Design (DDD) regarding how we model objects based on their identity and lifecycle.</li><li><b>Entity:</b> An object defined by its <b>Identity</b> (Who it is). It has a unique ID that persists over time, even if its details change.</li><li><b>Value Object:</b> An object defined by its <b>Attributes</b> (What it looks like). It has no unique ID; it is defined strictly by the values it holds.</li></ul><br><p><b>The Analogy: \"The Person vs. The Money\"</b></p><ul><li><b>Entity (The Person):</b> Imagine you meet a friend named John. If John changes his shirt, he is still John. If you meet another person named John who looks exactly like him, they are still two different people. <i>Conclusion: You care about which specific person it is.</i></li><li><b>Value Object (The Money):</b> Imagine you have a $10 bill. If you lend it to a friend and they pay you back with a different $10 bill, do you care? No. You define it by its properties (10 USD), not its serial number.</li></ul><br><p><b>Deep Dive: Key Differences</b></p><ul><li><b>Identity:</b><ul><li><b>Entity:</b> Defined by a Unique ID (Primary Key, UUID).</li><li><b>VO:</b> Defined by its State (All fields combined).</li></ul></li><li><b>Equality Check:</b><ul><li><b>Entity:</b> <code>a == b</code> if their IDs match.</li><li><b>VO:</b> <code>a.equals(b)</code> if all fields match.</li></ul></li><li><b>Mutability:</b><ul><li><b>Entity:</b> Mutable. Its state changes over time (lifecycle).</li><li><b>VO:</b> Immutable. Once created, it never changes. To change it, you create a new one.</li></ul></li><li><b>Lifespan:</b><ul><li><b>Entity:</b> Has a history and lifecycle (Created -> Active -> Deleted).</li><li><b>VO:</b> Ephemeral. Created when needed, discarded when done.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Value Object (Money)\n// Notice there is no id. Equality checks the values.\npublic final class Money {\n    private final BigDecimal amount;\n    private final String currency;\n\n    public Money(BigDecimal amount, String currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    // VO Logic: Equality depends on content\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Money money = (Money) o;\n        return amount.equals(money.amount) && \n               currency.equals(money.currency);\n    }\n}\n\n// Entity (Order)\n// Notice the id. Equality checks the ID.\npublic class Order {\n    private final String orderId; // Identity\n    private Money totalCost;      // Has-A Value Object\n    private String status;        // Mutable state\n\n    public Order(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public void changeStatus(String newStatus) {\n        this.status = newStatus; // Can change\n    }\n\n    // Entity Logic: Equality depends ONLY on ID\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Order order = (Order) o;\n        return orderId.equals(order.orderId);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Swap Test:</b> To decide between Entity vs. Value Object, ask: \"If I replace this object with another one having the exact same values, does it break my system?\"<ul><li><b>If Yes</b> (I need that specific one) -> <b>Entity</b>.</li><li><b>If No</b> (Any identical one works) -> <b>Value Object</b>.</li></ul></li><li><b>Immutability is King:</b> Value Objects should always be immutable. Do not add setters. If you need to change a coordinate (x, y) to (x+1, y), return a new <code>Point</code> object.</li><li><b>Database Mapping:</b><ul><li><b>Entities</b> usually get their own Table (Users, Orders).</li><li><b>Value Objects</b> are usually <b>Embedded</b> in the parent's table (e.g., <code>user_address_city</code>, <code>user_address_zip</code> inside the Users table) or stored as a JSON blob.</li></ul></li><li><b>Code Smell:</b> If you see a Value Object (like <code>Color</code> or <code>Date</code>) with an <code>id</code> field, something is wrong.</li></ul>"
    }
  ]
},

  "ORM Mapping": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ORM (Object-Relational Mapping)</b> is a technique (and a software layer) that sits between your Object-Oriented code (Java/Python classes) and your Relational Database (SQL tables).</li><li>It acts as a <b>Translator</b>.<br><i>Your Code speaks \"Objects\"</i> (Inheritance, Polymorphism).<br><i>The DB speaks \"Tables\"</i> (Rows, FKs, Joins).</li><li>The ORM automatically translates \"Save User Object\" into <code>INSERT INTO users...</code> and vice versa.</li></ul><br><p><b>Why use it? (The Impedance Mismatch)</b></p>The fundamental problem ORM solves is the friction caused because the two paradigms are conceptually different:<ul><li><b>Granularity:</b> Java has nested classes (<code>Address</code> inside <code>User</code>); SQL has flat columns. ORM maps this.</li><li><b>Inheritance:</b> SQL tables don't support inheritance (e.g., Manager extends Employee). ORM simulates this strategies like Single Table.</li><li><b>Identity:</b> Java uses memory addresses/equals; SQL uses Primary Keys.</li><li><b>Relationships:</b> Java uses references (<code>user.getOrders()</code>); SQL uses Foreign Keys (<code>user_id</code>).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Key Mapping Annotations (The \"How\" in JPA/Hibernate):</b></p><ul><li><b>Class Level:</b><ul><li><code>@Entity</code>: \"Hey ORM, treat this class as a database table.\"</li><li><code>@Table(name=\"users\")</code>: \"Map this class specifically to the <code>users</code> table.\"</li></ul></li><li><b>Field Level:</b><ul><li><code>@Id</code>: \"This is the Primary Key.\"</li><li><code>@GeneratedValue</code>: \"Auto-increment this ID.\"</li><li><code>@Column(name=\"email_addr\")</code>: \"Map the email field to the <code>email_addr</code> column.\"</li><li><code>@Transient</code>: \"Ignore this field. Do not store it in the DB.\"</li></ul></li><li><b>Relationship Level:</b><ul><li><code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>: Defines the association logic.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity // 1. Mark as ORM Object\n@Table(name = \"employees\")\npublic class Employee {\n\n    @Id // 2. Primary Key\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    // 3. Mapping a Relationship\n    // \"Many Employees belong to One Department\"\n    @ManyToOne(fetch = FetchType.LAZY) \n    @JoinColumn(name = \"dept_id\") // The Foreign Key column in 'employees' table\n    private Department department;\n\n    // Standard Getters/Setters...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The N+1 Problem (Performance Killer):</b><ul><li><b>Scenario:</b> You fetch 100 <code>Department</code> objects. Then you loop through them and call <code>dept.getEmployees()</code> for each one.</li><li><b>What happens:</b> 1 Query to get Departments + 100 Queries (one per department) to get their employees = 101 Queries.</li><li><b>Fix:</b> Use \"Join Fetch\" (eagerly load data in the initial query using a JOIN) or Entity Graphs.</li></ul></li><li><b>Lazy vs. Eager Loading:</b><ul><li><b>Eager:</b> \"Bring the Jungle.\" When you fetch the User, the ORM effectively does a JOIN and fetches all their Orders immediately.</li><li><b>Lazy:</b> \"Bring the Banana.\" When you fetch User, the Orders list is just a proxy (empty placeholder). The DB query fires only when you touch <code>user.getOrders()</code>. <b>Best Practice:</b> Prefer Lazy loading.</li></ul></li><li><b>Caching (L1 vs L2):</b><ul><li><b>Level 1 (Session Cache):</b> Default. Within a single transaction, if you ask for User ID #1 twice, the ORM returns it from memory the second time.</li><li><b>Level 2 (Global Cache):</b> Optional (e.g., Redis). Shared across all users/sessions. Good for read-heavy, static data.</li></ul></li><li><b>Dirty Checking:</b> You don't always need to call <code>repository.save(user)</code>. If you modify a fetched object inside a <code>@Transactional</code> block, the ORM automatically detects the change and fires the UPDATE query when the transaction ends.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/ormmapping.png"
        ],
        "caption": ""
      }
  ]
},
  "Lazy vs Eager": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This concept dictates <i>when</i> related data is fetched from the database.</li><li><b>Eager Loading:</b> Fetches the main entity and its related entities immediately in a single go (usually via a massive JOIN).</li><li><b>Lazy Loading:</b> Fetches only the main entity. The related entities are fetched on-demand, only when you explicitly access them in your code.</li></ul><br><p><b>The Analogy: \"Moving Houses\"</b></p><ul><li><b>Eager Loading (The Over-Packer):</b> You move to a new house and pack everything you own (winter coats, old yearbooks, kitchen sink) into the truck immediately.<br><i>Pros:</i> Everything is there if you need it.<br><i>Cons:</i> The truck is heavy, slow, and you might not look at those old yearbooks for 5 years. Wasted effort.</li><li><b>Lazy Loading (The Minimalist):</b> You move with just your essentials (bed, clothes). You leave the rest in storage.<br><i>Pros:</i> The move is fast and light.<br><i>Cons:</i> If you suddenly decide you need your \"High School Yearbook,\" you have to drive back to storage (make another DB trip) to get it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Mechanics: How it works (The Proxy)</b></p><ul><li>How does Java know to fetch data later? <b>Proxies.</b></li><li>When you Lazy load a User's orders, Hibernate doesn't give you a <code>List&lt;Order&gt;</code>. It gives you a <b>Proxy Object</b> (a placeholder/stub).</li><li>This Proxy looks like a list, but it's empty.</li><li><b>The Trigger:</b> The moment you call <code>user.getOrders().size()</code> or access the data, the Proxy \"wakes up,\" fires a SQL query to the database, fills itself with real data, and then gives it to you.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity\npublic class User {\n    @Id\n    private Long id;\n\n    // EAGER: \"I want the Profile immediately when I get the User\"\n    // Result: SELECT * FROM User LEFT JOIN Profile ...\n    @OneToOne(fetch = FetchType.EAGER)\n    private Profile profile;\n\n    // LAZY: \"Don't fetch Orders yet. Just give me a placeholder.\"\n    // Result: SELECT * FROM User ... (No Orders yet)\n    @OneToMany(fetch = FetchType.LAZY) \n    private List<Order> orders;\n}\n\n// Usage\nclass Main {\n    void test(EntityManager em) {\n        User u = em.find(User.class, 1L); // Query 1 fires here (User + Profile)\n        \n        System.out.println(u.getProfile().getBio()); // No new query (Already loaded)\n        \n        System.out.println(\"Wait for it...\");\n        \n        // Query 2 fires HERE (The \"Lazy Initialization\")\n        System.out.println(u.getOrders().size()); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Defaults (Memorize this):</b> JPA has default settings based on cardinality.<ul><li><code>@OneToOne</code>, <code>@ManyToOne</code> (Single Association) -> Default is <b>EAGER</b>.</li><li><code>@OneToMany</code>, <code>@ManyToMany</code> (Collection Association) -> Default is <b>LAZY</b>.</li><li><i>Tip:</i> Always explicitly set <code>@ManyToOne(fetch = FetchType.LAZY)</code>. Eager loading is almost always a performance trap in large apps.</li></ul></li><li><b>LazyInitializationException:</b> This is the most common error in Hibernate.<ul><li><b>Cause:</b> You fetched a Lazy entity, closed the Database Session (Transaction ended), and <i>then</i> tried to access the lazy data.</li><li><b>Result:</b> The Proxy tries to go back to the DB, finds the connection closed, and crashes.</li><li><b>Fix:</b> Keep the transaction open (using <code>@Transactional</code>) or use \"Join Fetch\".</li></ul></li><li><b>When to use which?</b><ul><li><b>Use Eager:</b> When you are 100% sure you will use the related data every single time you load the parent (e.g., User and UserPreferences).</li><li><b>Use Lazy:</b> For everything else. Especially for Lists/Collections. Loading 5000 Orders just to check a User's name is a disaster.</li></ul></li></ul>"
    }
  ]
},

  "Schema Evolution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Schema Evolution</b> is the process of managing changes to your database structure (tables, columns, types) over time as your application requirements change.</li><li>It is the art of \"Changing the tires on a moving car.\" You need to upgrade the database without crashing the application or losing data.</li></ul><br><p><b>Why use it? (The Challenge)</b></p><ul><li><b>Agile Development:</b> Requirements change. You need a new <code>is_verified</code> column today that you didn't need yesterday.</li><li><b>Zero Downtime:</b> In modern systems, you cannot just shut down the server. The old code and the new database schema must often coexist during deployment.</li><li><b>Compatibility:</b> You must ensure Backward Compatibility (New DB works with Old Code) and Forward Compatibility (Old DB works with New Code).</li></ul><br><p><b>The Strategy: Expand and Contract (Parallel Change)</b></p><ul><li>This is the Gold Standard pattern for safe schema evolution without downtime. It involves multiple small steps instead of one big \"Rename\" or \"Delete\".</li><li><b>Scenario:</b> Rename <code>full_name</code> to <code>display_name</code>.</li><li><b>Steps:</b><ol><li><b>Expand (Add):</b> Add <code>display_name</code> (nullable). DB has both.</li><li><b>Dual Write:</b> Deploy code that writes to both, but reads from old.</li><li><b>Backfill:</b> Copy data from old to new.</li><li><b>Switch Read:</b> Deploy code that reads from new.</li><li><b>Contract (Remove):</b> Stop writing to old. Remove old column.</li></ol></li></ul><br><p><b>Tools of the Trade:</b></p><ul><li><b>Flyway / Liquibase:</b> Version control tools for your database. They use a hidden table (<code>schema_version</code>) to track which scripts have run.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- File: V2__split_name_column.sql\n\n-- 1. Add new columns (Allow NULLs initially to prevent locking/errors)\nALTER TABLE users ADD COLUMN first_name VARCHAR(50);\nALTER TABLE users ADD COLUMN last_name VARCHAR(50);\n\n-- 2. Migrate existing data (The Backfill)\n-- Ideally, do this in batches for large tables to avoid locking\nUPDATE users SET first_name = SPLIT_PART(full_name, ' ', 1),\n    last_name = SPLIT_PART(full_name, ' ', 2);\n\n-- 3. Add constraints (After data is safe)\n-- ALTER TABLE users ALTER COLUMN first_name SET NOT NULL;"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Never Rename Columns directly:</b> <code>RENAME COLUMN</code> is a destructive action. The code looking for \"old\" will instantly crash. Use Expand & Contract.</li><li><b>Locking & Performance:</b> Adding a column with a <code>DEFAULT</code> value (in older DB versions) can lock the entire table. <b>Fix:</b> Add as <code>NULL</code> first -> Populate -> Add <code>NOT NULL</code> constraint.</li><li><b>Deprecation Phase:</b> If you delete a column, ensure the code has stopped using it for at least one full deployment cycle.</li><li><b>NoSQL is easier (but messier):</b> In MongoDB, you don't need migrations. You can have Document A with <code>name</code> and Document B with <code>firstName</code>. The complexity moves from the Database to the Application Code.</li></ul>"
    }
  ]
},

  "Threads vs Processes": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy:</b></p><ul><li><b>Process (The House):</b> A Process is the \"container.\" It has the address (Memory Space) and the resources (Kitchen/TV). It provides the environment to live in.</li><li><b>Thread (The Person):</b> A Thread is the \"worker\" inside the house. It actually does the things (cooking, cleaning).</li><li><b>Multi-threading:</b> Multiple people living in the same house. They share the same Fridge (<b>Heap Memory</b>) but have their own To-Do lists (<b>Stacks</b>).</li></ul><br><p><b>How Java \"Thinks\" of a Thread:</b></p>In Java, a Thread is not just a concept; it is an Object that wraps a real Operating System resource.<br><ul><li><b>1:1 Mapping:</b> When you call <code>t.start()</code>, the JVM asks the OS to create a real, native thread. One Java Thread = One OS Thread.</li><li><b>The Wrapper:</b> The Java Thread object (in Heap) is just the \"Remote Control.\" It holds metadata, but the actual execution happens in the OS.</li><li><b>The Job vs The Worker:</b><ul><li><b>Runnable Interface</b> = The Job (The specific logic/code to run).</li><li><b>Thread Class</b> = The Worker (The resource that executes the job).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Memory Architecture (Crucial for LLD):</b></p><ul><li><b>The Heap (Shared Space):</b> Where Objects live (<code>new HashMap()</code>). Visible to ALL threads. <i>Risk: Race Conditions.</i></li><li><b>The Stack (Private Space):</b> Where Method Calls and Local Variables live. Visible ONLY to the owner thread. <i>Risk: None (Thread-safe).</i></li></ul><br><p><b>Context Switching (The Cost):</b></p><ul><li><b>Process Switch:</b> Slow. CPU saves entire memory map and loads new app.</li><li><b>Thread Switch:</b> Fast. CPU stays in same memory address, just swaps Registers and Stack Pointer.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Way 1: The \"Job\" Approach (Recommended - implements Runnable)\n// Decouples the logic from the thread object.\n\n// 1. Define the Job\nRunnable myTask = () -> {\n    System.out.println(\"Thread is running: \" + Thread.currentThread().getName());\n};\n\n// 2. Hire the Worker (Thread) and give him the Job\nThread worker = new Thread(myTask);\nworker.start(); // STARTS the thread. Do not call run() directly!\n\n// Way 2: The \"Subclass\" Approach (Not Recommended - extends Thread)\n// Hardcodes the logic into the thread itself."
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>t.start()</code> and <code>t.run()</code>?</b><br><b>Answer:</b> <code>start()</code> creates a new separate thread (native OS call) and then calls <code>run()</code> inside that new thread. <code>run()</code> is just a normal method call on the <i>current</i> thread (no multi-threading).</li><li><b>Q2: Why did Chrome move to \"Process-per-Tab\"?</b><br><b>Answer:</b> Isolation. If one tab (Thread) crashed, the whole browser (Process) closed. Processes provide memory isolation and stability.</li><li><b>Q3: If a Thread throws a <code>StackOverflowError</code>, what crashes?</b><br><b>Answer:</b> Only that specific thread dies.</li><li><b>Q4: If a Thread throws an <code>OutOfMemoryError</code> (Heap Space), what crashes?</b><br><b>Answer:</b> The entire Application (Process) usually crashes (Shared Heap is full for everyone).</li><li><b>Q5: Why is <code>implements Runnable</code> better than <code>extends Thread</code>?</b><br><b>Answer:</b> Java allows single inheritance. If you extend <code>Thread</code>, you can't extend anything else. <code>Runnable</code> is an interface, allowing better flexibility and design (separation of Task from Runner).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/processthread.jpg"
        ],
        "caption": ""
      }
  ]
},

  "Thread Lifecycle": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy (The Gym Member):</b></p>A thread's life isn't just \"Running\" or \"Stopped.\" It moves through distinct phases managed by the OS Scheduler.<br><ul><li><b>New:</b> You just bought the gym membership. You haven't stepped inside yet.</li><li><b>Runnable (Ready + Running):</b> You are inside the gym. You might be lifting weights (<b>Running</b>) or waiting for your turn on the bench (<b>Ready</b>).</li><li><b>Blocked:</b> You want to use the Squat Rack, but someone else is using it. You wait passively for the resource (Lock).</li><li><b>Waiting:</b> You are resting on a bench and tell your trainer, \"Tap me when you are ready.\" You wait for a specific signal (Notification).</li><li><b>Timed Waiting:</b> You nap for exactly 10 minutes. You wake up automatically (Sleep).</li><li><b>Terminated:</b> You finished the workout and left. You cannot re-enter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>The 6 States (Technical Definitions - <code>Thread.State</code>):</b></p><ul><li><b>NEW:</b> Thread object created (<code>new Thread()</code>) but <code>start()</code> not called. No OS resources allocated.</li><li><b>RUNNABLE:</b> Includes both \"Ready to Run\" and \"Actually Running.\" The OS swaps them so fast Java groups them together.</li><li><b>BLOCKED:</b> <b>Passive Wait.</b> The thread tries to enter a <code>synchronized</code> block but the Lock is held by another thread. It uses 0% CPU.</li><li><b>WAITING:</b> <b>Active Voluntary Wait.</b> The thread explicitly paused itself (<code>Object.wait()</code>, <code>Thread.join()</code>) and waits for a signal (<code>notify()</code>).</li><li><b>TIMED_WAITING:</b> Same as WAITING, but with a timeout (<code>Thread.sleep(1000)</code>). Exits on timeout or interrupt.</li><li><b>TERMINATED:</b> Execution completed or crashed. The thread is dead.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class LifecycleDemo {\n    public static void main(String[] args) throws InterruptedException {\n        \n        // 1. NEW State\n        Thread t1 = new Thread(() -> {\n            try {\n                // 3. TIMED_WAITING State (during sleep)\n                Thread.sleep(1000); \n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        System.out.println(\"State 1: \" + t1.getState()); // Output: NEW\n\n        t1.start();\n        // 2. RUNNABLE State\n        System.out.println(\"State 2: \" + t1.getState()); // Output: RUNNABLE\n\n        Thread.sleep(100); // Main thread pauses to ensure t1 starts sleeping\n        \n        System.out.println(\"State 3: \" + t1.getState()); // Output: TIMED_WAITING\n\n        t1.join(); // Main thread waits for t1 to finish\n        \n        // 4. TERMINATED State\n        System.out.println(\"State 4: \" + t1.getState()); // Output: TERMINATED\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between BLOCKED and WAITING? (Very Common)</b><br><b>Answer:</b> <b>BLOCKED</b> happens automatically when waiting for a <i>Lock</i> (resource busy). <b>WAITING</b> happens manually when you call <code>.wait()</code> expecting a <i>Signal/Notification</i> (logic flow).</li><li><b>Q2: Can we restart a dead thread?</b><br><b>Answer:</b> No. Once TERMINATED, it's gone. Calling <code>start()</code> again throws an exception.</li><li><b>Q3: Difference between <code>Thread.sleep()</code> and <code>Object.wait()</code>?</b><br><b>Answer:</b> <code>sleep()</code> <b>keeps</b> the lock (\"I'm napping with the key in my pocket\"). <code>wait()</code> <b>releases</b> the lock (\"I'm pausing, here is the key for someone else\").</li><li><b>Q4: What is <code>Thread.yield()</code>?</b><br><b>Answer:</b> A hint to the scheduler to let other threads run. It goes from Running -> Ready (stays in RUNNABLE). Rarely used.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/threadlifecycle.png"
        ],
        "caption": ""
      }
  ]
},

  "Locks": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Locks</b> are mechanisms used to enforce limits on access to a resource in an environment where there are many threads of execution.</li></ul><br><p><b>The Analogy: \"The Fitting Room\"</b></p><ul><li><b>The Shared Resource:</b> A clothing store has one <b>Fitting Room</b>.</li><li><b>The Threads:</b> Many <b>Customers</b> want to try on clothes.</li><li><b>The Lock:</b> The <b>Latch</b> on the fitting room door.</li><li><b>The Process:</b><ul><li><b>Acquire Lock:</b> Customer A enters and locks the door.</li><li><b>Critical Section:</b> Customer A changes clothes. Customer B must wait outside (Blocked).</li><li><b>Release Lock:</b> Customer A unlocks and leaves.</li><li><b>Next Turn:</b> Customer B sees the door is free and enters.</li></ul></li><li><b>Without a Lock (Race Condition):</b> Customer A is half-naked, and Customer B barges in. Chaos (Data Corruption) ensues.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Race Condition:</b> A bug where the output depends on the timing of uncontrollable events (threads). Happens when multiple threads Read-Modify-Write shared data simultaneously.</li><li><b>Critical Section:</b> The specific lines of code that access the shared resource. This section needs protection.</li><li><b>Monitor (Intrinsic Lock):</b> Every Object in Java has an internal lock built-in. When you use <code>synchronized</code>, the thread grabs this specific object's monitor. <b>Rule:</b> Only one thread can hold an object's monitor at a time.</li></ul><br><p><b>Types of Synchronization:</b></p><ul><li><b>Synchronized Method (Coarse-Grained):</b> Locks the entire method using <code>this</code>. <i>Downside:</i> Slow; freezes the whole object.</li><li><b>Synchronized Block (Fine-Grained) - BEST PRACTICE:</b> Locks only a specific part of the code. Allows other threads to access other parts of the object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class FittingRoom {\n    public void tryOnClothes(String customerName) {\n        System.out.println(customerName + \" entered the store.\");\n\n        // Only one person can be inside this block at a time\n        synchronized(this) { \n            System.out.println(customerName + \" locked the Fitting Room.\");\n            try {\n                Thread.sleep(1000); // Simulate changing clothes\n            } catch (InterruptedException e) {}\n            System.out.println(customerName + \" unlocked the Fitting Room.\");\n        }\n        \n        System.out.println(customerName + \" left the store.\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions (Locks):</b></p><ul><li><b>Q1: Can Thread A enter <code>synchronized methodA()</code> and Thread B enter <code>synchronized methodB()</code> on the SAME object at the same time?</b><br><b>Answer:</b> No. Both methods use the same lock (<code>this</code>). Thread B is blocked.</li><li><b>Q2: Can Thread A enter a synchronized method and Thread B enter a non-synchronized method on the same object?</b><br><b>Answer:</b> Yes. Normal methods are \"Open Doors\"â€”anyone can walk in.</li><li><b>Q3: What is the difference between Object Lock and Class Lock?</b><br><b>Answer:</b><ul><li><b>Object Lock:</b> Locks a specific instance (<code>new FittingRoom()</code>).</li><li><b>Class Lock:</b> Locks the Class definition itself (<code>FittingRoom.class</code>). It is a Global Lock for all instances.</li></ul></li><li><b>Q4: Why prefer Synchronized Blocks over Methods?</b><br><b>Answer:</b> Performance. Blocks allow you to keep the \"Critical Section\" as small as possible.</li></ul>"
    },
    {
      "type": "text",
      "content": "<hr><p><b>The Deadlock (The Nightmare Scenario)</b></p><p><b>1. The Core Analogy: Pen and Paper</b></p><ul><li><b>The Scenario:</b> You and your friend need to write a letter. You need both a Pen and Paper.</li><li><b>The Trap:</b><ul><li>You grab the Pen (Holding Lock A).</li><li>Friend grabs the Paper (Holding Lock B).</li><li>You wait for the Paper.</li><li>Friend waits for the Pen.</li></ul></li><li><b>Result:</b> Neither of you will give up what you have. You stare at each other forever.</li></ul><br><br><p><b>2. Technical Definition & Conditions</b></p><ul><li><b>Deadlock:</b> A situation where two or more threads are blocked forever, waiting for each other.</li><li><b>The 4 Conditions (Coffman Conditions) - All must be true:</b><ol><li><b>Mutual Exclusion:</b> Only one thread can use the resource at a time.</li><li><b>Hold and Wait:</b> Holding a resource while waiting for another.</li><li><b>No Preemption:</b> Resources cannot be forcibly taken away.</li><li><b>Circular Wait:</b> A closed chain of threads waiting for each other.</li></ol></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// How to create a Deadlock\n\n// Thread 1\nsynchronized(LockA) {\n    System.out.println(\"Holding Lock A...\");\n    Thread.sleep(100); // Wait for Thread 2 to grab Lock B\n    \n    synchronized(LockB) { // WAITING FOREVER\n        System.out.println(\"Got Lock B\");\n    }\n}\n\n// Thread 2\nsynchronized(LockB) {\n    System.out.println(\"Holding Lock B...\");\n    Thread.sleep(100); // Wait for Thread 1 to grab Lock A\n    \n    synchronized(LockA) { // WAITING FOREVER\n        System.out.println(\"Got Lock A\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Deadlock Interview Questions:</b></p><ul><li><b>Q1: How do you prevent Deadlocks in code?</b><br><b>Answer:</b> The most practical way is <b>Lock Ordering</b>. Always acquire locks in the same order everywhere in your code. (e.g., Always Lock A then Lock B).</li><li><b>Q2: How do you detect a Deadlock in a running server?</b><br><b>Answer:</b> Take a <b>Thread Dump</b> (using tools like <code>jstack</code> or VisualVM). The tool will literally print a message saying: \"Found one Java-level deadlock\" and list the threads involved.</li><li><b>Q3: Can <code>synchronized</code> detect deadlocks and recover automatically?</b><br><b>Answer:</b> No. <code>synchronized</code> will wait forever. This is why we sometimes use <code>ReentrantLock</code> with <code>.tryLock()</code>, which allows us to say \"If I can't get the lock in 2 seconds, I'll give up,\" effectively breaking the deadlock.</li></ul>"
    }
  ]
},

  "ReentrantLock": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ReentrantLock</b> is a class in <code>java.util.concurrent.locks</code> that provides advanced locking capabilities beyond <code>synchronized</code>.</li></ul><br><p><b>The Analogy: \"The Security Badge\"</b></p><ul><li><b>The Scenario:</b> You work in a high-security building.</li><li><b>Reentrancy (Re-entering):</b><ul><li><b>Main Entrance:</b> You swipe your badge to enter. System: \"Welcome.\" (You hold the lock).</li><li><b>Server Room (Inside):</b> You need to enter a room <i>inside</i> the building. You swipe the same badge again.</li><li><b>Smart System (Reentrant):</b> It sees it's YOU (who already holds the lock) and lets you in immediately.</li><li><b>Dumb System (Non-Reentrant):</b> It says \"User is already in. Wait for User to leave.\" You are trapped waiting for yourself (Deadlock).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Hold Count:</b> The lock keeps a counter.<ul><li><code>lock()</code> -> Count increments (0 -> 1).</li><li><code>lock()</code> again (same thread) -> Count increments (1 -> 2).</li><li><code>unlock()</code> -> Count decrements (2 -> 1).</li><li>The lock is only released when Count reaches <b>0</b>.</li></ul></li><li><b>Fairness:</b><ul><li><b>Unfair (Default):</b> Faster. A new thread can \"cut in line\" if the lock is free.</li><li><b>Fair (<code>new ReentrantLock(true)</code>):</b> Slower. Strictly follows <b>FIFO</b>. The longest-waiting thread always gets the lock next.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SecuritySystem {\n    // 1. Create the Lock\n    // Pass 'true' to constructor for Fairness (FIFO)\n    private final ReentrantLock lock = new ReentrantLock(true); \n\n    public void accessResource() {\n        // 2. Lock Manually\n        lock.lock(); \n        \n        try {\n            // --- CRITICAL SECTION ---\n            System.out.println(\"Processing secure data...\");\n            \n            // Reentrancy Example:\n            // Calling another method that requires the SAME lock.\n            // This works fine because the lock is Reentrant.\n            internalAudit(); \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // 3. Unlock ALWAYS in finally\n            // Even if the code above crashes, this runs.\n            lock.unlock(); \n        }\n    }\n\n    public void internalAudit() {\n        lock.lock(); // Count goes 1 -> 2\n        try {\n            System.out.println(\"Auditing...\");\n        } finally {\n            lock.unlock(); // Count goes 2 -> 1\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the main difference between <code>synchronized</code> and <code>ReentrantLock</code>?</b><br><b>Answer:</b> Flexibility. <code>synchronized</code> is implicit and rigid (must wait forever). <code>ReentrantLock</code> is explicit (manual) and supports <b>Timeouts</b> (<code>tryLock</code>), <b>Fairness policies</b>, and multiple Condition variables.</li><li><b>Q2: What is <code>tryLock()</code> and why is it useful?</b><br><b>Answer:</b> <code>tryLock()</code> attempts to grab the lock but returns <code>false</code> immediately (or after a timeout) if it fails. Use it to prevent Deadlocks (\"If I can't get the lock in 2 seconds, I'll give up\").</li><li><b>Q3: Why shouldn't we use Fairness (true) all the time?</b><br><b>Answer:</b> <b>Performance.</b> Managing a strict queue takes CPU effort. Unfair locks have much higher throughput because they reduce context switching. Only use Fair locks if \"Starvation\" is a real problem.</li><li><b>Q4: What happens if you throw an Exception inside a <code>lock()</code> block without <code>finally</code>?</b><br><b>Answer:</b> The method exits, but <code>lock.unlock()</code> is never called. The lock remains held forever, hanging the system.</li></ul>"
    }
  ]
},

  "Volatile": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Notice Board vs. Personal Notepad Analogy:</b></li><li><b>The Setup:</b> Imagine an office with a Boss (Main Thread) and an Employee (Worker Thread).<ul><li><b>Main Memory (RAM):</b> A big Notice Board in the hallway.</li><li><b>CPU Cache:</b> The Employee's personal Notepad at their desk.</li></ul></li><li><b>The Problem (Without Volatile):</b> The Boss writes \"STOP WORKING\" on the Notice Board. The Employee looks at their Notepad, which still says \"KEEP WORKING.\" Result: The Employee works forever (Visibility Problem).</li><li><b>The Solution (With Volatile):</b> Declaring a variable <code>volatile</code> is a new rule: \"You are forbidden from writing this in your Notepad. You must walk to the Notice Board every single time you read or write this.\"</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Visibility:</b> <code>volatile</code> guarantees that changes made by one thread are immediately visible to other threads. It bypasses the CPU Cache (L1/L2) and goes straight to Main Memory (RAM).</li><li><b>Instruction Reordering (Memory Barrier):</b> Compilers like to rearrange code to make it faster. <code>volatile</code> acts as a wall. It prevents the compiler from reordering instructions across the variable.</li><li><b>Limitation:</b> It guarantees <b>Visibility</b>, but NOT <b>Atomicity</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Worker {\n    // WITHOUT 'volatile': \n    // The thread might cache 'running = true' and loop forever, \n    // even after you call stop().\n    private volatile boolean running = true; \n\n    public void run() {\n        System.out.println(\"Worker started.\");\n        \n        while (running) {\n            // \"Poll\" the variable. \n            // Because it is volatile, it checks Main Memory every single loop.\n        }\n        \n        System.out.println(\"Worker stopped.\");\n    }\n\n    public void stop() {\n        running = false; // Writes immediately to Main Memory\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The \"Count++\" Trap (What Volatile cannot do):</b></p><ul><li><b>Scenario:</b> You have <code>volatile int count = 0</code>. Two threads do <code>count++</code>.</li><li><b>The Bug:</b> <code>count++</code> is three steps: Read (0) -> Add (1) -> Write (1).</li><li><code>volatile</code> ensures they READ the latest value (0), but it doesn't stop them from running Step 2 at the exact same time. They both write 1.</li><li><b>Rule:</b> Never use <code>volatile</code> for counters or read-modify-write operations. Use <code>AtomicInteger</code> instead.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>volatile</code> and <code>synchronized</code>?</b><br><b>Answer:</b><ul><li><b>volatile:</b> Light. Guarantees <b>Visibility only</b>. No locking (non-blocking).</li><li><b>synchronized:</b> Heavy. Guarantees <b>Visibility AND Atomicity</b>. Forces threads to wait (blocking).</li></ul></li><li><b>Q2: Can we use volatile for a Singleton (Double-Checked Locking)?</b><br><b>Answer:</b> Yes. The instance variable must be <code>volatile</code> to prevent a half-initialized object from being visible to other threads due to instruction reordering.</li><li><b>Q3: When should you use volatile?</b><br><b>Answer:</b> Only in two cases: <br>1. <b>Flags</b> (boolean status like <code>stopRequested</code>).<br>2. <b>Single Writer, Many Readers</b> (One thread updates, many just read).</li></ul>"
    }
  ]
},


  "Atomic Ops": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Atomic Operations</b> are operations that appear to the rest of the system to occur instantaneously. They are indivisible.</li></ul><br><p><b>The Core Analogy: \"The Like Button\"</b></p><ul><li><b>The Scenario:</b> A post has 99 likes. Two friends click \"Like\" at the exact same millisecond.</li><li><b>Non-Atomic Way (The Glitch):</b><ul><li>Phone A reads: 99. Phone B reads: 99.</li><li>Phone A writes: 100. Phone B writes: 100.</li><li><b>Result:</b> 100 Likes. (One like was lost).</li></ul></li><li><b>Atomic Way (The Fix):</b> The hardware forces the operations into a strict line.</li><li><b>Result:</b> 99 -> 100 -> 101.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>CAS (Compare-And-Swap):</b> The secret sauce behind Atomic variables. It is a hardware instruction that is faster than locking.<br><i>Logic:</i> \"I think the current value is A. If it is A, change it to B. If it is NOT A (because someone changed it), tell me, and I will try again.\"</li><li><b>Optimistic Locking:</b> Atomics assume conflicts are rare. They don't lock the door; they just try to update and retry if they fail. This is <b>Non-Blocking</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicDemo {\n\n    // The \"Dangerous\" Way (int)\n    // int count = 0; // Not thread-safe. (Read-Modify-Write is 3 steps)\n\n    // The \"Safe\" Way (AtomicInteger)\n    // 1. Create the Atomic Variable\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        // 2. Atomic Increment\n        // Efficiently performs \"Read-Modify-Write\" in one shot using CAS.\n        // Returns the new value.\n        int newValue = count.incrementAndGet(); \n    }\n    \n    public int getCount() {\n        return count.get();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How are Atomics different from synchronized?</b><br><b>Answer:</b><ul><li><b>Atomics (CAS):</b> Optimistic. Non-blocking. Uses CPU instructions directly. Very fast for simple counters.</li><li><b>Synchronized:</b> Pessimistic. Blocking. Context switches threads. Better for complex logic.</li></ul></li><li><b>Q2: What is the \"ABA Problem\" in CAS?</b><br><b>Answer:</b> A famous bug. Thread 1 reads A. Thread 2 changes A -> B -> A. Thread 1 wakes up, sees A, and thinks \"Nothing changed!\", so it proceeds erroneously. <b>Fix:</b> Use <code>AtomicStampedReference</code> (Versions: A v1 -> B v2 -> A v3).</li><li><b>Q3: Can AtomicInteger replace synchronized blocks?</b><br><b>Answer:</b> Only for single variable updates. If you need to update balance AND transactionHistory together atomically, you still need <code>synchronized</code>.</li></ul>"
    }
  ]
},

  "ExecutorService": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ExecutorService</b> is the High-Level Interface in Java that manages a pool of threads, a work queue, and the lifecycle of task execution. It replaces the manual creation of threads.</li></ul><br><p><b>The Core Analogy: \"The Restaurant Manager\"</b></p><ul><li><b>The Old Way (<code>new Thread()</code>):</b> Customer enters. You hire a new chef. Chef cooks. You fire the chef. <i>Result:</i> Chaos and high cost.</li><li><b>The New Way (Thread Pool):</b> You hire a <b>Manager (ExecutorService)</b> and a <b>Fixed Crew</b> of 5 chefs.<ul><li>Customer enters. Manager gives the order to Chef 1.</li><li>If all chefs are busy, the Manager puts the order on the <b>Waiting Spike (Queue)</b>.</li><li>When Chef 1 is done, they pick the next ticket from the queue.</li></ul></li><li><b>Result:</b> Stability. You handle 1,000 customers with just 5 reused chefs.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why <code>new Thread()</code> is forbidden:</b><ul><li><b>Expensive:</b> Creating a thread takes OS resources (Stack Memory ~1MB).</li><li><b>Uncontrolled:</b> If you spawn 100k threads, you get <code>OutOfMemoryError</code>.</li></ul></li><li><b>Thread Pool:</b> A collection of pre-started threads that are reused for multiple tasks.</li></ul><br><p><b>Types of Pools (The \"Kitchen\" Types):</b></p><ul><li><b>FixedThreadPool(n):</b> Creates n threads. If busy, tasks queue up. <i>Best for:</i> Predictable, stable loads.</li><li><b>CachedThreadPool():</b> Creates new threads as needed. Kills them if idle for 60s. <i>Best for:</i> Short, bursty tasks. <i>Risk:</i> Can crash if load is infinite.</li><li><b>SingleThreadExecutor():</b> Only 1 thread. Tasks run sequentially. <i>Best for:</i> Ordering (logging).</li><li><b>ScheduledThreadPool():</b> Runs tasks after delay or periodically.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.*;\n\npublic class ManagerDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // 1. Hire the Manager (Fixed crew of 2 threads)\n        ExecutorService manager = Executors.newFixedThreadPool(2);\n\n        // 2. Submit a Task (Callable = Returns a Result)\n        // \"Future\" is the Claim Ticket/Receipt.\n        Future<String> receipt = manager.submit(() -> {\n            Thread.sleep(1000); // Simulate work\n            return \"Burger Ready!\";\n        });\n\n        System.out.println(\"Doing other work while burger cooks...\");\n\n        // 3. Get the Result (Blocking)\n        // This waits until the chef is done.\n        String result = receipt.get(); \n        System.out.println(result);\n\n        // 4. Close the Kitchen\n        manager.shutdown();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Difference between <code>execute()</code> and <code>submit()</code>?</b><br><b>Answer:</b> <code>execute()</code> is \"Fire and Forget\" (returns void). <code>submit()</code> returns a <b>Future</b>, allowing you to check status or get return values.</li><li><b>Q2: If a thread crashes (unchecked exception), what happens?</b><br><b>Answer:</b> The pool detects the thread died, discards it, and creates a <b>new one</b> to replace it. Pool size remains constant.</li><li><b>Q3: Risks of <code>CachedThreadPool</code> in production?</b><br><b>Answer:</b> <b>System Crash.</b> Since it creates a thread for <i>every</i> task if others are busy, a spike of 1M requests = 1M threads = <code>OutOfMemoryError</code>.</li><li><b>Q4: What is a Future?</b><br><b>Answer:</b> It's a placeholder object for a result that hasn't arrived yet (like a claim ticket). It allows the main thread to keep working and check for the result later using <code>future.get()</code>.</li></ul>"
    }
  ]
},


  "Concurrent Collections": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Concurrent Collections</b> are specialized data structures designed to be accessed and modified by multiple threads simultaneously without explicit external synchronization and without compromising data integrity.</li></ul><br><p><b>The Core Analogy: \"The Attendance Sheet\"</b></p><ul><li><b>The Scenario:</b> A classroom with 30 students and one attendance sheet.</li><li><b>The Old Way (Hashtable / Synchronized Map):</b><ul><li><b>The Rule:</b> The teacher holds the single sheet.</li><li><b>The Bottleneck:</b> If Student A is signing, Student Z must wait in line, even if they are signing at the bottom of the page.</li><li><b>Result:</b> Safe, but Slow (Coarse-grained locking).</li></ul></li><li><b>The New Way (ConcurrentHashMap):</b><ul><li><b>The Rule:</b> The teacher tears the sheet into 16 pieces (Buckets) and pastes them on different walls.</li><li><b>The Parallelism:</b> Student A goes to Wall 1. Student Z goes to Wall 16. They sign simultaneously.</li><li><b>Result:</b> Safe and Fast (Fine-grained locking).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why HashMap fails:</b> It is not thread-safe. If two threads modify it at once, it can corrupt the internal linked list (infinite loops) or lose data.</li><li><b>Why Hashtable is obsolete:</b> It uses a <b>Global Lock</b> (synchronized on the whole method). Only one thread can read/write at a time.</li><li><b>ConcurrentHashMap (The King):</b><ul><li><b>Lock Striping (Bucket Locking):</b> Instead of locking the whole map, it only locks the specific Bucket (index) you are writing to.</li><li><b>Read Operations (<code>get</code>):</b> Completely <b>Lock-Free</b>. They are non-blocking and very fast.</li><li><b>Iterators:</b> <b>Fail-Safe</b>. You can iterate over the map while other threads are adding/removing items without crashing.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentMapDemo {\n    public static void main(String[] args) {\n        \n        // Thread-safe map designed for high concurrency\n        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n        map.put(\"Apple\", 1);\n        map.put(\"Banana\", 2);\n\n        // Thread 1: Writing to 'Orange' bucket\n        new Thread(() -> {\n            map.put(\"Orange\", 3); \n            System.out.println(\"Added Orange\");\n        }).start();\n\n        // Thread 2: Reading 'Apple' bucket (Non-blocking)\n        // Works instantly even if Thread 1 is writing\n        new Thread(() -> {\n            System.out.println(\"Read Apple: \" + map.get(\"Apple\"));\n        }).start();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How does ConcurrentHashMap work internally in Java 8+?</b><br><b>Answer:</b> It no longer uses \"Segments.\" It uses a hybrid of <b>CAS</b> and <b>synchronized</b>.<ul><li><b>Empty Bucket:</b> Uses <b>CAS</b> to insert the new node (Lock-Free).</li><li><b>Collision:</b> If the slot has data, it locks <b>ONLY that specific Node</b> (using <code>synchronized</code>) to append to the list/tree.</li></ul></li><li><b>Q2: Why does ConcurrentHashMap NOT allow null keys or values?</b><br><b>Answer:</b> <b>Ambiguity.</b> In a normal map, <code>null</code> could mean \"Value is null\" OR \"Key doesn't exist.\" In multi-threading, you can't double-check with <code>containsKey()</code> because the map might change between the two calls. To prevent this race condition confusion, nulls are banned.</li><li><b>Q3: What is <code>ConcurrentModificationException</code>?</b><br><b>Answer:</b> A crash in normal collections (ArrayList) if you modify the list while iterating. <b>Fix:</b> Use <code>CopyOnWriteArrayList</code> or <code>ConcurrentHashMap</code> (Fail-Safe iterators).</li><li><b>Q4: Is <code>size()</code> accurate in ConcurrentHashMap?</b><br><b>Answer:</b> No, it is an <b>estimate</b>. Because threads are constantly adding/removing, the size might change before the method returns.</li></ul>"
    }
  ]
},

  "Thread-Safety": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Thread-Safety</b> means that code functions correctly (no data corruption, no crashes) when accessed by multiple threads simultaneously.</li></ul><br><p><b>The Core Analogy: \"The Kitchen Safety Hierarchy\"</b></p><ul><li><b>The Goal:</b> Multiple chefs (Threads) need to cook in the same building without ruining each other's food.</li><li><b>Strategy 1: Private Kitchens (Statelessness) - ðŸ¥‡ GOLD STANDARD:</b> Every chef gets their own private room and ingredients. <br><i>Result:</i> 100% Safe. No collisions possible.</li><li><b>Strategy 2: The Museum Display (Immutability) - ðŸ¥ˆ SILVER BULLET:</b> The recipe book is behind bulletproof glass. Chefs can read it, but no one can scribble on it. <br><i>Result:</i> 100% Safe. Read-only shared data never causes race conditions.</li><li><b>Strategy 3: The Locked Pot (Synchronization) - ðŸ¥‰ BRONZE:</b> There is one shared soup pot with a lock on the lid. <br><i>Result:</i> Safe, but Slow. Chefs must wait in line.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions & Code:</b></p><ul><li><b>Stateless Object:</b> An object with no instance variables (fields). It relies only on method arguments (Stack memory), which are inherently private to the thread.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// A. Stateless Service (The Best Way)\n// Safe because it has NO state (fields)\npublic class MathService {\n    \n    public int add(int a, int b) {\n        // 'a' and 'b' are local variables (Stack). \n        // Thread A's 'a' is totally different from Thread B's 'a'.\n        return a + b; \n    }\n}"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Immutable Object:</b> An object whose state cannot be changed after creation. All fields are <code>final</code> and there are no setters.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// B. Immutable Object (The Read-Only Way)\n// Safe because state CANNOT change\npublic final class UserConfig {\n    private final String url;\n    private final int timeout;\n\n    public UserConfig(String url, int timeout) {\n        this.url = url;\n        this.timeout = timeout;\n    }\n\n    public String getUrl() { return url; }\n    // NO SETTERS.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How do you make a Java class Thread-Safe? (The Hierarchy)</b><br><b>Answer:</b> (Always order by preference) <br>1. <b>Statelessness:</b> Can I remove the fields? (Best)<br>2. <b>Immutability:</b> Can I make fields final?<br>3. <b>Thread-Safe Tools:</b> Can I use <code>AtomicInteger</code> or <code>ConcurrentHashMap</code>?<br>4. <b>Locking:</b> If all else fails, use <code>synchronized</code>.</li><li><b>Q2: Are Spring Boot Controllers/Services Thread-Safe?</b><br><b>Answer:</b> By default, Spring beans are <b>Singletons</b> (shared by all threads). Therefore, they <b>MUST be Stateless</b>. If you put a mutable instance variable (like <code>private int count</code>) inside a Controller, it is a critical bug.</li><li><b>Q3: Is <code>SimpleDateFormat</code> thread-safe?</b><br><b>Answer:</b> <b>No.</b> It stores intermediate parsing results in instance variables. Use <code>java.time.DateTimeFormatter</code> (Immutable) instead.</li><li><b>Q4: What is <code>ThreadLocal</code>?</b><br><b>Answer:</b> It gives every thread its own private \"pocket\" for data (e.g., storing a User ID for the duration of a request), ensuring isolation without passing parameters everywhere.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/threadsafety.jpg"
        ],
        "caption": ""
      }
  ]
},


  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Museum Display Analogy:</b></li><li><b>Mutable Object:</b> You leave a precious manuscript on a table. Anyone can scribble on it. To protect it, you need a guard (Lock/Synchronization).</li><li><b>Immutable Object:</b> You put the manuscript inside a <b>bulletproof glass case</b>. 1,000 people can look at it (Read) simultaneously, but no one can touch it.</li><li><b>Result:</b> You don't need a guard. It is inherently safe because it is <b>Read-Only</b>.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Immutable Object:</b> An object whose state (data) cannot be modified after it is created.</li><li><b>The Golden Rule:</b> \"If you can't change it, you can't break it.\"</li><li><b>Key Characteristics:</b><ul><li>No \"Setters\" (e.g., <code>setName()</code>).</li><li>All fields are <code>private</code> and <code>final</code>.</li><li>The class is <code>final</code> (preventing subclasses from altering behavior).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Strategy (Create vs. Modify):</b></p><ul><li>If you need to \"change\" data in an immutable object, you <b>do NOT modify</b> the existing object. Instead, you <b>create a New Copy</b> with the updated value.</li><li><i>Example:</i> <code>String</code> in Java. <code>s.toUpperCase()</code> does not change <code>s</code>; it returns a completely new String object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n\n// 1. Make class final (No subclasses allowed)\npublic final class ImmutableUser {\n    \n    // 2. Make fields private and final (Must be set in constructor)\n    private final String name;\n    private final int age;\n    private final List<String> roles;\n\n    public ImmutableUser(String name, int age, List<String> roles) {\n        this.name = name;\n        this.age = age;\n        \n        // 3. DEEP COPY (Crucial Step!)\n        // If we just said \"this.roles = roles\", the caller could modify the \n        // original list later and break our immutability.\n        this.roles = new ArrayList<>(roles);\n    }\n\n    // 4. Getters Only (No Setters)\n    public String getName() { return name; }\n    public int getAge() { return age; }\n\n    public List<String> getRoles() {\n        // Return a copy or unmodifiable view so they can't touch our internal list\n        return new ArrayList<>(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Why is String immutable in Java?</b><br><b>Answer:</b><ul><li><b>Security:</b> Strings are used for Database URLs and passwords. If mutable, a hacker could change a filename after the security check but before file access.</li><li><b>Thread-Safety:</b> Safe to share across threads without locks.</li><li><b>String Pool:</b> Caching identical strings to save memory is only possible if they never change.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q2: What is the difference between <code>final</code> and Immutable?</b><br><b>Answer:</b><ul><li><b>final:</b> Refers to the <b>Reference</b> (\"I cannot point this variable to a new object\").</li><li><b>Immutable:</b> Refers to the <b>Object Content</b> (\"The data inside this object cannot change\").</li><li><i>Trap:</i> <code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> -> You cannot say <code>list = new List()</code>, BUT you CAN say <code>list.add(\"Hack\")</code>. The list is final but Mutable.</li></ul></li><li><b>Q3: How do you handle a Date or List field inside an Immutable class?</b><br><b>Answer:</b> You must use <b>Defensive Copies</b> (Deep Copy). Copy the incoming list in the Constructor, and return a copy in the Getter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q4: What are the downsides of Immutability?</b><br><b>Answer:</b> <b>Memory Overhead.</b> Creating a new object for every small change generates \"garbage\" (e.g., String concatenation in a loop). <b>Fix:</b> Use <code>StringBuilder</code> (Mutable) for heavy editing, then convert to <code>String</code>.</li></ul>"
    }
  ]
},

  "Checked vs Unchecked": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Distinction:</b></p><ul><li><b>Checked Exceptions (<code>Exception</code>):</b><ul><li><b>Nature:</b> Anticipated, recoverable events external to the program (e.g., File missing, Network down).</li><li><b>Compiler Rule:</b> <b>Mandatory Handling.</b> You must <code>try-catch</code> or <code>throws</code>.</li><li><b>Intent:</b> \"Don't ignore this; have a Plan B.\"</li></ul></li><li><b>Unchecked Exceptions (<code>RuntimeException</code>):</b><ul><li><b>Nature:</b> Logic errors (Bugs) or Unrecoverable system faults (e.g., NullPointer, Database Dead).</li><li><b>Compiler Rule:</b> <b>Optional Handling.</b> Compiler stays silent.</li><li><b>Intent:</b> \"Fix the code\" or \"Fail fast.\"</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Decision Matrix (How to choose):</b></p><table><thead><tr><th>Scenario</th><th>Type to Throw</th><th>Rationale</th></tr></thead><tbody><tr><td><b>Caller can recover</b> (Retry, Alternate Path)</td><td>Checked</td><td>Forces the dev to write recovery logic.</td></tr><tr><td><b>Programming Error</b> (Null arg, Bad cast)</td><td>Unchecked</td><td>No recovery possible; the code is broken.</td></tr><tr><td><b>System Failure</b> (DB dead, Config missing)</td><td>Unchecked</td><td>Caller can't fix a dead DB. Let it crash to the top.</td></tr><tr><td><b>Modern API (Spring)</b></td><td>Unchecked</td><td>Reduces boilerplate; handled by Global Exception Handler.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>The \"Wrap and Rethrow\" Pattern (Critical for LLD):</b></p><ul><li><b>Problem:</b> Checked exceptions (e.g., <code>SQLException</code>) leak implementation details to higher layers. The Service layer shouldn't know you are using SQL.</li><li><b>Solution:</b> Catch the Checked exception at the boundary, wrap it in a custom Unchecked exception, and throw.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// BAD (Leaky Abstraction - Service knows about SQL)\npublic User get(String id) throws SQLException { ... } \n\n// GOOD (Clean Abstraction - Service only knows Data Access failed)\npublic User get(String id) {\n    try {\n        // ... SQL logic ...\n    } catch (SQLException e) {\n        // Wrap & Rethrow. Preserves stack trace (e).\n        throw new DataAccessException(\"Failed to fetch user\", e);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Industry Trend:</b> Modern Java (Spring/Lombok) heavily prefers <b>Unchecked Exceptions</b>. Legacy Java used Checked exceptions too much, resulting in empty catch blocks. Ideally, use a Centralized Error Handler (<code>@ControllerAdvice</code>).</li><li><b>Layer Isolation:</b> Never let a Checked Exception from a low-level library (JDBC, File I/O) propagate to the Service layer. Wrap it.</li><li><b>The Spring Transaction Trap:</b> In Spring, <code>@Transactional</code> <b>only rolls back on Unchecked exceptions</b> by default. It commits if a Checked exception is thrown, unless you specify <code>rollbackFor = Exception.class</code>.</li></ul>"
    }
  ]
},

  "Custom Exceptions": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Semantic Clarity:</b> Replaces vague errors (<code>RuntimeException</code>) with specific business language (<code>UserNotFoundException</code>).</li><li><b>Granular Handling:</b> Allows the caller to catch specific scenarios (Catch <code>InvalidPassword</code>) while letting others bubble up.</li><li><b>Context Passing:</b> Custom exceptions can carry metadata (e.g., <code>failedAmount</code>, <code>userId</code>) to help with debugging or user feedback.</li></ul><br><p><b>The Design Pattern: Domain Hierarchy</b></p>Don't just create random exceptions. Structure them like your architecture.<br><ul><li><b>Root Layer:</b> <code>BaseAppException</code> (Extends RuntimeException).</li><li><b>Module Layer:</b> <code>BillingException</code>, <code>AuthException</code> (Extends BaseAppException).</li><li><b>Leaf Layer:</b> <code>InsufficientFundsException</code>, <code>TokenExpiredException</code> (Extends Module Exception).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The \"Smart\" Exception: Holds Logic & Data\n\n// 1. Base Class (Unchecked)\npublic abstract class PaymentException extends RuntimeException {\n    public PaymentException(String message) { super(message); }\n}\n\n// 2. Concrete Class with Context\npublic class InsufficientFundsException extends PaymentException {\n    \n    // DATA fields (Crucial for debugging/UI)\n    private final double currentBalance;\n    private final double attemptedAmount;\n\n    public InsufficientFundsException(double currentBalance, double attemptedAmount) {\n        super(\"Transaction declined: Balance \" + currentBalance + \" < \" + attemptedAmount);\n        this.currentBalance = currentBalance;\n        this.attemptedAmount = attemptedAmount;\n    }\n    \n    // Getters allowed...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Usage Benefits (Comparison):</b></p><table><thead><tr><th>Feature</th><th>Generic (Exception)</th><th>Custom (UserNotFound)</th></tr></thead><tbody><tr><td><b>Readability</b></td><td>Low (throw new RuntimeException(\"user missing\"))</td><td>High (throw new UserNotFound(id))</td></tr><tr><td><b>Catching</b></td><td>Catches everything (bugs & logic)</td><td>Catches only specific logic</td></tr><tr><td><b>API Response</b></td><td>Hard to map to 404/400</td><td>Easy 1:1 mapping</td></tr></tbody></table><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Don't Over-Engineer:</b> Rule of Thumb: Create a new class <i>only</i> if you intend to handle it differently (e.g., return a different HTTP status or trigger a specific retry logic).</li><li><b>Mapping to HTTP (API Layer):</b> Custom exceptions are the bridge between Logic and API.<ul><li><code>ResourceNotFoundException</code> $\\rightarrow$ 404 Not Found</li><li><code>BusinessRuleViolationException</code> $\\rightarrow$ 422 Unprocessable Entity</li><li><code>SystemFailureException</code> $\\rightarrow$ 500 Internal Server Error</li></ul></li><li><b>Security:</b> Never put sensitive data (passwords, PII) inside the exception message/fields, as these often get logged in plain text.</li></ul>"
    }
  ]
},

  "Propagation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Three Strategies:</b></p>When an exception occurs, you have three choices. Your choice defines the resilience and cleanliness of your architecture.<br><ul><li><b>1. Handle (Catch & Recover):</b><ul><li><b>Action:</b> Catch the error and implement a \"Plan B.\"</li><li><b>Use When:</b> You can fix the issue locally without bothering the user. (e.g., Cache fails $\\rightarrow$ Fetch from DB).</li></ul></li><li><b>2. Bubble Up (Propagate):</b><ul><li><b>Action:</b> Do nothing (or declare <code>throws</code>). Let the exception fly up the stack.</li><li><b>Use When:</b> Your method is a utility (e.g., File Reader) and has no context on how to solve business problems.</li></ul></li><li><b>3. Wrap & Rethrow (Translate) [Crucial for LLD]:</b><ul><li><b>Action:</b> Catch a low-level exception, wrap it in a high-level Domain exception, and throw the new one.</li><li><b>Use When:</b> Crossing architectural boundaries (e.g., Data Layer $\\rightarrow$ Service Layer).</li><li><b>Goal:</b> Prevent <b>Leaky Abstractions</b>.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Code Example: Wrap & Rethrow\n// This is the standard pattern for maintaining clean layers.\n\n// Layer: Repository (Low Level)\npublic void save(User user) {\n    try {\n        database.execute(sql);\n    } catch (SQLException e) {\n        // STOP! Do not let SQL details leak out.\n        // Wrap 'e' to keep the stack trace (Root Cause).\n        throw new UserStorageException(\"Save failed\", e);\n    }\n}\n\n// Layer: Service (High Level)\n// Service code stays clean. It doesn't know we use SQL.\npublic void register(User user) {\n    try {\n        repo.save(user);\n    } catch (UserStorageException e) { // catching the Domain Error\n        // Handle business logic failure\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Anti-Pattern: \"Log and Throw\":</b></p><ul><li><b>Avoid this:</b> <code>catch (e) { logger.error(e); throw e; }</code></li><li>It creates duplicate logs (once here, once at the global handler). <b>Rule:</b> Either log it and handle it (swallow), OR throw it. Never do both.</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Preserve Abstraction:</b> The Service Layer should never catch <code>SQLException</code> or <code>IOException</code>. It should only catch domain errors (<code>StorageException</code>). If you see low-level errors in high-level code, it's a \"Leaky Abstraction.\"</li><li><b>Swallowing Exceptions:</b> Never write an empty catch block (<code>catch (e) {}</code>). It buries the error. At minimum, log it.</li><li><b>Root Cause Analysis:</b> When Wrapping & Rethrowing, always pass the original exception into the constructor (<code>new MyEx(msg, originalEx)</code>). If you forget this, you lose the stack trace and won't know <i>why</i> the error happened.</li></ul>"
    }
  ]
},


  "Optional vs Null": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Problem: The \"Billion Dollar Mistake\"</b></p><ul><li><b>Ambiguity:</b> <code>null</code> is silent. It can mean \"Not Found,\" \"Not Initialized,\" or \"Error.\"</li><li><b>Risk:</b> Developers forget to check <code>if (x != null)</code>, leading to <b>NullPointerException (NPE)</b> which crashes the application at runtime.</li></ul><br><p><b>The Solution: Optional&lt;T&gt;</b></p><ul><li><b>Concept:</b> A container object (a \"box\") that may or may not contain a non-null value.</li><li><b>Intent:</b> It forces the client code to explicitly handle the \"case where the value is missing.\" You cannot access the value without \"opening the box.\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Patterns (The LLD Toolkit)</b></p>Instead of <code>if-else</code> blocks, use functional pipelines.<br><table><thead><tr><th>Method</th><th>Purpose</th><th>Scenario</th></tr></thead><tbody><tr><td><code>orElseThrow()</code></td><td>Get value or crash.</td><td>Validation: \"User must exist, or else 404.\"</td></tr><tr><td><code>ifPresent()</code></td><td>Do something if exists.</td><td>Side Effects: \"If email exists, send logic.\"</td></tr><tr><td><code>map()</code></td><td>Transform if exists.</td><td>DTOs: \"Convert User entity to DTO only if found.\"</td></tr><tr><td><code>orElse()</code></td><td>Default value.</td><td>Config: \"Use default timeout if config missing.\"</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Old Way (Null Checks - Error Prone)\nUser user = repo.find(\"karan\");\nif (user != null) {\n    Address addr = user.getAddress();\n    if (addr != null) {\n        return addr.getCity();\n    }\n}\nreturn \"Unknown\"; // Easy to miss a return path\n\n// The LLD Way (Optional Pipeline - Safe)\nreturn repo.find(\"karan\") // returns Optional<User>\n    .map(User::getAddress)\n    .map(Address::getCity)\n    .orElse(\"Unknown\");"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Return Type Only:</b> Strict rule for LLDâ€”Use <code>Optional</code> <b>only as a return type</b>. It signals to the caller \"This might be empty.\"</li><li><b>Don't use as Parameters:</b> Do not write <code>method(Optional&lt;String&gt; s)</code>. It makes the API clumsy. Overload the method instead.</li><li><b>Don't use as Fields:</b> Do not declare <code>private Optional&lt;String&gt; name</code> in a class.<ul><li><b>Reason 1:</b> It is not Serializable (breaks Redis/Caching).</li><li><b>Reason 2:</b> Memory overhead (creates a wrapper object for every field). Use <code>null</code> for fields, wrap in <code>Optional</code> in the getter.</li></ul></li></ul>"
    }
  ]
},

  "DTO vs Domain": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Separation of Worlds:</b></p><ul><li><b>Domain Model (Internal Representation):</b><ul><li><b>Context:</b> Database & Business Logic.</li><li><b>Nature:</b> \"Heavy.\" Contains annotations (<code>@Entity</code>), relationships (<code>@OneToMany</code>), and business methods.</li><li><b>Goal:</b> Maintain data integrity and business rules.</li></ul></li><li><b>DTO (Data Transfer Object) (External Contract):</b><ul><li><b>Context:</b> API & Client Communication.</li><li><b>Nature:</b> \"Light.\" Plain Java Objects (POJOs) with only fields and getters/setters. No logic.</li><li><b>Goal:</b> Efficient data transport and strict API contracts.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Why Separate Them? (Decoupling)</b></p><table><thead><tr><th>Factor</th><th>Use Domain Directly (Bad)</th><th>Use DTO (Good)</th></tr></thead><tbody><tr><td><b>Coupling</b></td><td>API breaks if DB Column name changes.</td><td>API is stable; only the Mapper changes.</td></tr><tr><td><b>Security</b></td><td>Accidental leak of password, salt, id.</td><td>Explicitly whitelist fields to expose.</td></tr><tr><td><b>Performance</b></td><td>Serializing Entity triggers <b>Lazy Loading</b> (N+1 queries).</td><td>DTO contains only fetched data.</td></tr><tr><td><b>Versioning</b></td><td>Hard to support v1 and v2 simultaneously.</td><td>Different DTOs for v1 (<code>UserV1DTO</code>) and v2.</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Entity (Internal - DB Linked)\n@Entity\npublic class User {\n    @Id private Long id;\n    private String email;\n    private String passwordHash; // Sensitive! Leaking this is a disaster.\n    private boolean isDeleted;   // Internal flag!\n}\n\n// The DTO (External - API Safe)\npublic class UserResponseDTO {\n    public String email;\n    public String status; // Calculated (\"Active\" vs \"Deleted\")\n    // Password is physically missing here. Safe.\n}\n\n// The Mapper (The Bridge)\npublic UserResponseDTO toDTO(User user) {\n    UserResponseDTO dto = new UserResponseDTO();\n    dto.email = user.getEmail();\n    dto.status = user.isDeleted() ? \"Inactive\" : \"Active\";\n    return dto;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Serialization Hazards:</b> Never return an <code>@Entity</code> directly in a Controller. JSON serializers (like Jackson) will try to access lazy-loaded fields (e.g., <code>user.getOrders()</code>), causing <b>Infinite Recursion</b> or <b>N+1 Database Queries</b>.</li><li><b>Boilerplate Reduction:</b> In interviews, mention using libraries like <b>MapStruct</b> or <b>ModelMapper</b>. It shows you know production standards for automating the mapping code.</li><li><b>Multiple Views:</b> You can have multiple DTOs for the same Entity to optimize payload size:<ul><li><code>UserSummaryDTO</code> (List View: ID + Name)</li><li><code>UserDetailDTO</code> (Profile View: ID + Name + Address + History)</li></ul></li></ul>"
    }
  ]
},

  "Validation Layer": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Two-Phase Validation Strategy:</b></p>To keep code clean and secure, validation is split into two distinct stages.<br><ul><li><b>Phase 1: Syntactic Validation (Format)</b><ul><li><b>Where:</b> DTO / Controller Layer.</li><li><b>What:</b> \"Does the data look right?\" (e.g., Is email format valid?)</li><li><b>Mechanism:</b> Annotations (<code>@NotNull</code>, <code>@Email</code>).</li><li><b>Goal:</b> <b>Fail Fast.</b> Don't bother the database if the format is garbage.</li></ul></li><li><b>Phase 2: Semantic Validation (Logic)</b><ul><li><b>Where:</b> Service / Domain Layer.</li><li><b>What:</b> \"Is the data valid in our system?\" (e.g., Is email unique?)</li><li><b>Mechanism:</b> Database queries / Business Rule checks.</li><li><b>Goal:</b> Ensure data integrity.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Security: Input Sanitization</b></p>Before validation starts, sanitize input to prevent attacks.<br><ul><li><b>XSS (Cross-Site Scripting):</b> Strip HTML tags from text inputs (<code>&lt;script&gt;</code>).</li><li><b>SQL Injection:</b> Use Prepared Statements (standard in JPA/Hibernate).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Phase 1: Syntactic (DTO Annotations)\npublic class SignupDTO {\n    @NotNull(message = \"Name required\")\n    private String name;\n\n    @Email(message = \"Bad email format\")\n    private String email; // Checks format only (foo@bar.com)\n}\n\n// Phase 2: Semantic (Service Logic)\npublic void register(SignupDTO dto) {\n    // 1. Semantic Check: Uniqueness\n    if (repo.existsByEmail(dto.getEmail())) {\n        throw new UserAlreadyExistsException(\"Email taken\");\n    }\n\n    // 2. Semantic Check: Business Rule\n    if (dto.getAge() < 18 && dto.getCountry().equals(\"US\")) {\n        throw new BusinessRuleException(\"Must be 18+ in US\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Separation of Concerns:</b> Never put DB checks (Semantic) inside the DTO or Controller. It couples your API layer to your Data layer.</li><li><b>Fail Fast Principle:</b> Always perform Syntactic validation before Semantic. Syntactic is cheap (CPU only); Semantic is expensive (I/O, DB calls).</li><li><b>The \"Validator Class\" Pattern:</b> If business rules are complex (e.g., Loan Approval with 20 checks), move the logic out of the Service and into a dedicated <code>LoanValidator</code> class to keep the Service readable.</li></ul>"
    }
  ]
},

  "Anti-Corruption Layer": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Concept:</b></p><ul><li><b>The Problem:</b> You are building a modern system (Clean Architecture) but need to integrate with a <b>Legacy System</b> (Spaghetti Code, Mainframe, XML) or a poorly designed 3rd Party API.</li><li><b>The Risk:</b> If you use the Legacy System's classes/models directly in your new code, the \"rot\" spreads. Your clean service layer becomes polluted with confusing names and structures.</li><li><b>The Solution:</b> Build a defensive wall (The <b>ACL</b>). It translates the \"Messy External Model\" into your \"Clean Internal Model.\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Components of an ACL:</b></p><ul><li><b>The Adapter (Facade):</b> The interface exposed to your new system. It speaks <i>your</i> language.</li><li><b>The Translator:</b> A private utility that maps <code>Legacy Object</code> $\\leftrightarrow$ <code>Modern Object</code>.</li><li><b>The Client:</b> The low-level network code that actually talks to the legacy system (SOAP, REST, etc.).</li></ul><br><p><b>Code Structure:</b></p>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The \"Clean\" Interface (What your Service uses)\n// Notice: It uses your clean domain language (sku, boolean)\npublic interface InventoryService {\n    boolean isProductInStock(String sku);\n}\n\n// 2. The ACL Implementation (The Translation Logic)\n// Notice: It encapsulates the mess (XML_ITEM_01, \"Y\"/\"N\" flags)\n@Service\npublic class LegacyInventoryACL implements InventoryService {\n    \n    @Autowired private LegacySoapClient client;\n\n    @Override\n    public boolean isProductInStock(String sku) {\n        // A. Translate Request (Clean -> Messy)\n        String legacyId = \"ID_\" + sku; \n        \n        // B. Call Legacy System\n        LegacyResponse response = client.fetchXML_ITEM_01(legacyId);\n        \n        // C. Translate Response (Messy -> Clean)\n        // Legacy system uses \"Y\"/\"N\", we want boolean\n        return \"Y\".equals(response.getVal_stk_flag());\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Decoupling is King:</b> The primary goal is that your core domain logic never imports a class from the legacy system. It only talks to the ACL interface.</li><li><b>Strangler Fig Pattern:</b> ACL is the enabler for the \"Strangler Fig\" migration strategy. You wrap the old system in an ACL. Over time, you replace the backend of the ACL with a new microservice, while the interface remains the same.</li><li><b>Cost vs. Benefit:</b> Don't use ACL for everything. If the external system is modern and clean (e.g., Stripe API), just use their SDK. ACL is specifically for isolating mess.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},


  "Idempotency": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>Math:</b> $f(f(x)) = f(x)$</li><li><b>Engineering:</b> Performing an operation multiple times produces the same result as performing it exactly once.</li><li><b>Goal:</b> Resilience against network failures (Timeouts) and automatic Retries.</li></ul><br><p><b>The Problem: \"The Double Charge\"</b></p><ul><li><b>Scenario:</b> User clicks \"Pay $100\". Server charges card. The <b>Network Fails</b> before the response returns.</li><li><b>The Retry:</b> Client thinks the request failed and sends it again.</li><li><b>Result:</b> Server charges the card again. User is angry.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>HTTP Methods Behavior:</b></p><table><thead><tr><th>Method</th><th>Idempotent?</th><th>Why?</th></tr></thead><tbody><tr><td><b>GET</b></td><td>Yes</td><td>Read-only. Reading 10 times changes nothing.</td></tr><tr><td><b>PUT</b></td><td>Yes</td><td>\"Set X=5\". Doing it 10 times results in X=5.</td></tr><tr><td><b>DELETE</b></td><td>Yes</td><td>\"Delete ID 5\". Doing it 10 times results in ID 5 gone.</td></tr><tr><td><b>POST</b></td><td><b>NO</b></td><td>\"Create Order\". Doing it 10 times creates 10 orders. Requires Idempotency Keys.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution: Idempotency Keys</b></p><ul><li><b>The Mechanism:</b> The server must recognize \"I have seen this request before.\"</li><li><b>Client:</b> Generates a unique ID (UUID) for the intent (e.g., <code>req_123</code>).</li><li><b>Server Logic:</b><ul><li><b>If Key Exists:</b> Return the saved response (Do not process again).</li><li><b>If Key New:</b> Process request $\\rightarrow$ Save Key + Response $\\rightarrow$ Return Result.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public Response processPayment(String key, Data data) {\n    // 1. Check Cache/DB\n    if (store.contains(key)) {\n        return store.get(key); // Return cached success\n    }\n\n    // 2. Lock (Critical for Concurrency)\n    // Prevent two threads processing the same key at the exact same ms\n    if (!lock.acquire(key)) {\n        throw new ConflictException(\"Processing\");\n    }\n\n    // 3. Process & Save\n    Result result = paymentService.charge(data);\n    store.save(key, result);\n    \n    return result;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>The \"Post\" Exception:</b> In REST, POST is the only method that is <b>not</b> idempotent by default. You must manually implement it for critical endpoints (Payments).</li><li><b>Concurrency Race Condition:</b> If a user clicks \"Submit\" twice instantly, two requests might hit the server before the first one is saved. You need a <b>Distributed Lock</b> (e.g., Redis Lock) on the Idempotency Key to prevent parallel processing.</li><li><b>Response Caching:</b> You don't just save \"Processed: True\". You must save the <b>actual JSON response</b>. When the retry comes, you return the exact same JSON body so the client doesn't crash parsing a different format.</li></ul>"
    }
  ]
},


  "Config-Driven Design": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Philosophy:</b></p><ul><li><b>Definition:</b> Writing code that adapts its behavior based on external configuration, rather than hardcoded logic.</li><li><b>The Goal:</b> Change Business Logic without changing Source Code.</li><li><b>The Benefit:</b> Reduces \"Time to Market.\" A Product Manager can toggle a feature or change a tax rate in seconds, without waiting for a developer to commit, build, test, and deploy.</li></ul><br><p><b>The Evolution of Config:</b></p><table><thead><tr><th>Level</th><th>Strategy</th><th>Pros/Cons</th></tr></thead><tbody><tr><td><b>Level 0</b></td><td>Hardcoded (<code>if (country == \"US\")</code>)</td><td><b>Bad.</b> Requires full code redeploy to change.</td></tr><tr><td><b>Level 1</b></td><td>Property Files (<code>application.yaml</code>)</td><td><b>Better.</b> Requires a service restart to apply changes.</td></tr><tr><td><b>Level 2</b></td><td>Dynamic Config (DB / Consul)</td><td><b>Best.</b> Changes apply in <b>Real-Time (Hot Reload)</b> without restart.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>Feature Toggles (Flags):</b></p>Decouple <b>Deployment</b> (moving code to server) from <b>Release</b> (showing code to users).<br><ul><li><b>Boolean Flags:</b> Turn features on/off. <code>if (featureFlags.isOn(\"dark_mode\"))</code>.</li><li><b>Kill Switch:</b> If a new feature causes bugs, turn it off instantly via config. No rollback needed.</li><li><b>Canary / Percentage Rollouts:</b> \"Enable New Checkout for 5% of users.\" Monitor logs. If safe, increase to 100%.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Environment Separation:</b></p>The \"Build Once, Deploy Anywhere\" Rule.<br><ul><li><b>Artifact:</b> The code (JAR/Docker Image) must be <b>identical</b> across Dev, Stage, and Prod.</li><li><b>Variable:</b> Only the Config changes.<br><i>Dev:</i> <code>DB_URL=localhost</code>, <code>LOG_LEVEL=DEBUG</code><br><i>Prod:</i> <code>DB_URL=rds-endpoint</code>, <code>LOG_LEVEL=INFO</code></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Bad Way (Hardcoded)\npublic double calculateTax(String country) {\n    if (\"US\".equals(country)) return 0.10; // Hardcoded!\n    if (\"IN\".equals(country)) return 0.18; // Redeploy needed to change\n    return 0;\n}\n\n// The LLD Way (Config-Driven)\n@Service\npublic class TaxService {\n    // Injected from DB or Config Server (Hot Reloadable)\n    private Map<String, Double> taxRates; \n\n    public double calculateTax(String country) {\n        // 1. Logic is generic\n        // 2. Behavior is defined by data\n        return taxRates.getOrDefault(country, 0.0);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Hot Reloading:</b> In High-Level Design (HLD), we use tools like <b>Spring Cloud Config</b> or <b>Consul</b> to push changes to running services. The service listens for the change event and refreshes its beans without downtime.</li><li><b>A/B Testing:</b> Config-Driven Design is the foundation of A/B testing. You feed Config A to User Group 1 and Config B to User Group 2 to measure which one performs better.</li><li><b>Complexity Warning:</b> Don't overdo it. Too many feature flags make the code a nightmare to test (20 flags = $2^{20}$ possible combinations). Clean up old flags once the feature is permanently 100% live.</li></ul>"
    }
  ]
},


  "Feature Toggles": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Concept:</b></p><ul><li><b>Definition:</b> A mechanism that allows you to modify system behavior without changing code.</li><li><b>The Mantra:</b> \"Deploy $\\neq$ Release.\"<ul><li><b>Deploy:</b> Installing code onto the server (Technical act).</li><li><b>Release:</b> Making the feature visible to users (Business act).</li></ul></li><li><b>Goal:</b> <b>Continuous Deployment.</b> You can push half-finished code to Production, kept hidden behind a \"False\" flag.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Common Types of Toggles:</b></p><table><thead><tr><th>Type</th><th>Purpose</th><th>Duration</th></tr></thead><tbody><tr><td><b>Release Toggle</b></td><td>Hide incomplete work. Allow trunk-based development.</td><td>Short-lived (Days/Weeks)</td></tr><tr><td><b>Ops Toggle (Kill Switch)</b></td><td>Safety valve. If a new endpoint spikes latency, turn it off.</td><td>Medium-lived</td></tr><tr><td><b>Experiment Toggle</b></td><td>A/B Testing. \"Show blue button to 50% users.\"</td><td>Short/Medium</td></tr><tr><td><b>Permission Toggle</b></td><td>Premium features. \"Only Gold users see this.\"</td><td>Long-lived (Years)</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Basic Strategy (If/Else Clutter)\n// Risk: Code becomes hard to read with nested if statements.\nif (featureFlags.isOn(\"new-search-algo\")) {\n    return newSearchService.search(query);\n} else {\n    return legacySearchService.search(query);\n}\n\n// 2. Advanced Strategy (Strategy Pattern - LLD Approved)\n// Solution: Inject the decision logic, keeping the core code clean.\n// The Factory decides which implementation to inject based on the Flag.\nSearchService service = featureManager.isOn(\"new-algo\") \n                      ? new NewSearchService() \n                      : new LegacySearchService();\nservice.search(query);"
    },
    {
      "type": "text",
      "content": "<br><p><b>Toggle Lifecycle (The \"Debt\" Trap):</b></p>Feature flags are <b>Technical Debt</b>. If you don't remove them after the feature is stable, your code becomes a graveyard of dead paths.<br><ol><li><b>Create:</b> Add flag <code>use_new_checkout</code>.</li><li><b>Deploy:</b> Code goes to Prod (Flag = False).</li><li><b>Enable:</b> Turn Flag = True (Gradual rollout).</li><li><b>Stabilize:</b> Ensure no bugs.</li><li><b>Cleanup:</b> <b>CRITICAL.</b> Delete the if/else block and the flag.</li></ol>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Performance (Caching):</b> Do not query the Database for a flag on every single request. <b>Solution:</b> Cache flags in memory (short TTL) or use a dedicated system (LaunchDarkly) that pushes updates to SDKs.</li><li><b>Testing Nightmare:</b> Every flag doubles your test cases ($2^n$). <b>Strategy:</b> Test only two states: \"All Flags On\" (Future) and \"All Flags Off\" (Current Prod).</li><li><b>Context-Awareness:</b> Smart toggles take context: <code>isEnabled(\"dark_mode\", userId=123)</code>. This allows specific user targeting (Canary Releases).</li></ul>"
    }
  ]
},


  "Env Separation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Golden Rule: \"Build Once, Deploy Anywhere\"</b></p><ul><li><b>Philosophy:</b> Your application binary (JAR, Docker Image) must be <b>immutable</b>.</li><li><b>The Artifact:</b> You build the artifact <i>once</i> in the CI pipeline. You do not rebuild it for Production.</li><li><b>The Variable:</b> The only thing that changes between environments is the <b>Configuration</b> (injected at runtime).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Hierarchy of Environments:</b></p><table><thead><tr><th>Env</th><th>Purpose</th><th>Config Characteristics</th></tr></thead><tbody><tr><td><b>Local/Dev</b></td><td>Coding & Unit Testing</td><td>DB=localhost, Logs=DEBUG, Auth=Mock</td></tr><tr><td><b>QA/Stage</b></td><td>Integration Testing (Mirror of Prod)</td><td>DB=TestRDS, Logs=INFO, Auth=Real</td></tr><tr><td><b>Prod</b></td><td>Real User Traffic</td><td>DB=ProdRDS, Logs=WARN, Auth=Real</td></tr></tbody></table><br><p><b>What Separates? (The Config)</b></p>Never hardcode these. They must be injected via Environment Variables or External Config Stores.<br><ul><li><b>Resources:</b> Database URLs, Redis endpoints, Queue topics.</li><li><b>Credentials:</b> API Keys, Passwords (use Secrets Manager, never plain text).</li><li><b>Behavior:</b> Log levels, Thread pool sizes, Feature flags.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>12-Factor App Methodology (Factor III):</b></p><ul><li><b>Rule:</b> Store config in the environment, not in the code.</li><li><b>Violation:</b> Committing <code>config-prod.properties</code> inside the Git repo.</li><li><b>Correct:</b> Application reads <code>System.getenv(\"DB_URL\")</code> at startup.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad (Hardcoded / Profile Hell)\n// If you have to rebuild the JAR to change this, you failed.\nString dbUrl = \"jdbc:mysql://prod-db:3306/users\"; \n\n// Good (Injected)\n// Spring Boot automatically maps env vars (APP_DB_URL) to this field\n@Value(\"${app.db.url}\")\nprivate String dbUrl; "
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Secrets Management:</b> Never commit passwords to Git. Use tools like <b>HashiCorp Vault</b> or <b>AWS Secrets Manager</b>. The app fetches the secret at runtime using an IAM role.</li><li><b>Parity:</b> Keep Dev and Prod as similar as possible. <b>Anti-Pattern:</b> Using H2 (In-Memory) for Dev and Oracle for Prod (leads to SQL dialect bugs). <b>Fix:</b> Use Docker to run the real DB locally.</li><li><b>Startup Validation:</b> Fail fast. If <code>DB_URL</code> is null, crash the app immediately on startup. Don't wait for the first user request to fail.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Class Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> The blueprint of your system. It represents the <b>Static Structure</b>â€”classes, data types, and the relationships between them.</li><li><b>Usage:</b> It maps directly to code (OOP). If you can draw it, you can code it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Anatomy of a Class Box:</b></p>A standard class is represented by a rectangle divided into three parts:<ol><li><b>Top:</b> Class Name.</li><li><b>Middle:</b> Attributes / Fields (<code>name: type</code>).</li><li><b>Bottom:</b> Methods / Functions (<code>methodName(param): returnType</code>).</li></ol>"
    },
    {
      "type": "text",
      "content": "<p><b>Types of Classifiers:</b></p><ul><li><b>Concrete Class:</b> Standard rectangle. Objects you can instantiate (<code>new User()</code>).</li><li><b>Abstract Class:</b> Name in <i>Italics</i> OR labeled <code>&lt;&lt;abstract&gt;&gt;</code>. Cannot be instantiated.</li><li><b>Interface:</b> Labeled <code>&lt;&lt;interface&gt;&gt;</code>. A contract defining \"what\" behaviors are required.</li><li><b>Enum (Enumeration):</b> Labeled <code>&lt;&lt;enumeration&gt;&gt;</code>. Lists constant values (Status, Role).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Member Notation (Visibility & Modifiers):</b></p><ul><li><b>Visibility:</b><ul><li><code>+</code> Public</li><li><code>-</code> Private</li><li><code>#</code> Protected</li><li><code>~</code> Package/Default</li></ul></li><li><b>Advanced Modifiers:</b><ul><li><b>Static Members:</b> <u>Underlined</u>. Shared by all instances.</li><li><b>Abstract Methods:</b> <i>Italicized</i>. Must be implemented by child.</li><li><b>Derived Attributes:</b> <code>/</code> prefix. Calculated on the fly (e.g., <code>/age</code> derived from <code>birthDate</code>).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Relationships (The Core of LLD):</b></p><table><thead><tr><th>Relationship</th><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td><b>Inheritance</b></td><td>Solid line + Hollow Triangle</td><td>\"Is-A\". Parent-Child. (<code>extends</code>)</td></tr><tr><td><b>Realization</b></td><td>Dashed line + Hollow Triangle</td><td>\"Can-Do\". Implements Interface. (<code>implements</code>)</td></tr><tr><td><b>Association</b></td><td>Solid Line</td><td>\"Uses\". Basic connection.</td></tr><tr><td><b>Aggregation</b></td><td>Solid Line + <b>Empty</b> Diamond</td><td>\"Has-A\" (Weak). Child survives Parent's death. (Team-Players).</td></tr><tr><td><b>Composition</b></td><td>Solid Line + <b>Filled</b> Diamond</td><td>\"Part-Of\" (Strong). Child dies with Parent. (House-Room).</td></tr><tr><td><b>Dependency</b></td><td>Dashed Line + Open Arrow</td><td>\"Temporarily Uses\". Changes in target affect source.</td></tr></tbody></table>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/umlsign.png"
        ],
        "caption": ""
      },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Composition vs. Aggregation:</b> Ask \"If I delete the Parent, does the Child survive?\" <br>Yes $\\rightarrow$ Aggregation (Empty Diamond). <br>No $\\rightarrow$ Composition (Filled Diamond).</li><li><b>Enums as First-Class Citizens:</b> Always draw a specific <code>&lt;&lt;enumeration&gt;&gt;</code> box for statuses (e.g., <code>OrderStatus</code>) and link it, rather than just writing <code>status: String</code>. This shows Type Safety.</li><li><b>Interface Segregation:</b> Clearly distinguish between extends (solid) and implements (dashed).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/classdiagram.jpg"
        ],
        "caption": ""
      }
  ]
},

  "UML Modifiers": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Visibility Modifiers (Access Control):</b></p>These symbols determine who can see and use the attribute or method. They map directly to OOP access keywords.<br><table><thead><tr><th>Symbol</th><th>Access Level</th><th>Java Equivalent</th><th>Meaning</th></tr></thead><tbody><tr><td><code>+</code></td><td><b>Public</b></td><td><code>public</code></td><td>Accessible by any other class.</td></tr><tr><td><code>-</code></td><td><b>Private</b></td><td><code>private</code></td><td>Accessible only inside the class itself.</td></tr><tr><td><code>#</code></td><td><b>Protected</b></td><td><code>protected</code></td><td>Accessible by the class and its children (subclasses).</td></tr><tr><td><code>~</code></td><td><b>Package</b></td><td>default</td><td>Accessible by classes in the same package.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Scope & Inheritance Modifiers:</b></p>These define how the member behaves regarding instances and inheritance.<br><ul><li><b>Static (Class Level):</b><ul><li><b>Notation:</b> <u>Underlined Text</u></li><li><b>Meaning:</b> Belongs to the Class, not an instance. Shared by all.</li><li><i>Example:</i> <u><code>+ userCount: int</code></u></li></ul></li><li><b>Abstract (Must Implement):</b><ul><li><b>Notation:</b> <i>Italicized Text</i> (or <code>{abstract}</code> tag)</li><li><b>Meaning:</b> No body. Subclasses must provide implementation.</li><li><i>Example:</i> <i><code>+ calculateTax(): double</code></i></li></ul></li><li><b>Final (Leaf):</b><ul><li><b>Notation:</b> <code>{leaf}</code> or <code>{frozen}</code> tag</li><li><b>Meaning:</b> Cannot be overridden (method) or extended (class).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Attribute-Specific Modifiers:</b></p><ul><li><b>Derived (Calculated):</b><ul><li><b>Notation:</b> <code>/</code> prefix before the name.</li><li><b>Meaning:</b> Computed on the fly; not stored in memory.</li><li><i>Example:</i> <code>/age</code> (derived from birthDate).</li></ul></li><li><b>Read-Only (Constant):</b><ul><li><b>Notation:</b> <code>{readOnly}</code> tag after the type.</li><li><b>Meaning:</b> Set once (usually in constructor) and immutable.</li></ul></li><li><b>Multiplicity (Collections):</b><ul><li><b>Notation:</b> <code>[min..max]</code> after the name.</li><li><b>Meaning:</b> Defines list size limits.</li><li><i>Example:</i> <code>- emailAddresses: String [1..*]</code> (At least one email required).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Defaults Matter:</b> Explicitly writing <code>-</code> (private) demonstrates you understand <b>Encapsulation</b>. Leaving it blank implies lazy design.</li><li><b>Derived Attributes:</b> Use the <code>/</code> notation for business logic fields like \"Total Price\" to clarify they are not database columns.</li><li><b>Static vs. Instance:</b> Always <u>underline</u> Singleton instances or utility methods to distinguish stateful objects from stateless helpers.</li></ul>"
    }
  ]
},

  "Cardinality": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>Concept:</b> Defines \"How many\" instances of one class are linked to instances of another class.</li><li><b>Synonym:</b> Often called \"Multiplicity\" in UML, while \"Cardinality\" is more common in Database Design.</li><li><b>Direction:</b> It is read from \"Source\" to \"Target.\"</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Notation Cheat Sheet:</b></p><table><thead><tr><th>Notation</th><th>Meaning</th><th>Description</th></tr></thead><tbody><tr><td><code>1</code></td><td><b>Exactly One</b></td><td>Mandatory. (e.g., An Order must have exactly 1 Customer).</td></tr><tr><td><code>0..1</code></td><td><b>Zero or One</b></td><td>Optional. (e.g., A User might have a Referral Code).</td></tr><tr><td><code>*</code> or <code>0..*</code></td><td><b>Zero to Many</b></td><td>Optional List. (e.g., A Library has many Books).</td></tr><tr><td><code>1..*</code></td><td><b>One to Many</b></td><td>Mandatory List. (e.g., An Order must have at least 1 Item).</td></tr><tr><td><code>m..n</code></td><td><b>Range</b></td><td>Bounded. (e.g., A Car has 2..4 Doors).</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Mapping to Code (Java)\n// Cardinality dictates whether you use a single Object or a Collection.\n\nclass Department {\n    // 1..* (One to Many)\n    // \"Many\" implies a Collection\n    private List<Employee> employees; \n}\n\nclass Employee {\n    // 1 (Many to One)\n    // \"One\" implies a direct Object reference\n    private Department department;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Relationship Types (Symmetry):</b></p><ul><li><b>One-to-One (1:1):</b> User â”€â”€â”€â”€ Profile. Usually merged into one table unless lazy loading is needed.</li><li><b>One-to-Many (1:N):</b> Team â”€â”€â”€â”€ Player. The most common type. Parent has a List; Child has a Parent reference.</li><li><b>Many-to-Many (M:N):</b> Student â”€â”€â”€â”€ Course. Requires a <b>Join Table</b> in the DB.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Database Design Implication:</b><ul><li><b>1..*:</b> Interviewer assumes a <b>Foreign Key</b> on the \"Many\" side.</li><li><b>*..*:</b> Interviewer assumes a hidden <b>Join Table</b> (Bridge Table).</li></ul></li><li><b>Constraint Handling:</b> If you write <code>1..*</code> (1 to Many), you must enforce it in the constructor (e.g., <code>if (items.isEmpty()) throw error</code>). Don't just draw it; validate it.</li><li><b>Unidirectional vs. Bidirectional:</b> In LLD, prefer <b>Unidirectional</b> (Source $\\rightarrow$ Target) to reduce coupling. Only make it Bidirectional if absolutely necessary for performance.</li></ul>"
    }
  ]
},

  "Use Case": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> A high-level view of <i>what</i> the system does (Functional Requirements), not <i>how</i> it does it.</li><li><b>Audience:</b> Non-technical stakeholders (PMs, Clients) and Developers.</li><li><b>Focus:</b> Interaction between \"Actors\" (Users/External Systems) and the \"System\" functions.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Components:</b></p><ul><li><b>Actor (Stick Figure):</b> Represents a <b>Role</b> (not a person). Can be Human (User) or System (External API, Timer).</li><li><b>Use Case (Oval):</b> Represents a distinct functionality or goal. <b>Naming:</b> Verb + Noun (e.g., <i>Place Order</i>).</li><li><b>System Boundary (Rectangle):</b> A box defining the scope. Inside = Your Code. Outside = Actors.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Relationships (The Critical Part):</b></p><table><thead><tr><th>Relationship</th><th>Notation</th><th>Meaning</th><th>Example</th></tr></thead><tbody><tr><td><b>Association</b></td><td>Solid Line</td><td>Interaction. Actor to Use Case.</td><td>Customer â€”â€” Login</td></tr><tr><td><b>Include</b></td><td>Dashed Arrow + <code>&lt;&lt;include&gt;&gt;</code></td><td><b>Mandatory.</b> Base always calls Included. (Reuse).</td><td>Checkout $\\rightarrow$ Verify Payment</td></tr><tr><td><b>Extend</b></td><td>Dashed Arrow + <code>&lt;&lt;extend&gt;&gt;</code></td><td><b>Optional.</b> Runs only if specific conditions met.</td><td>Order Food $\\leftarrow$ Use Coupon</td></tr><tr><td><b>Generalization</b></td><td>Solid Line + Hollow Triangle</td><td><b>Inheritance.</b> \"Is-A\".</td><td>Admin $\\rightarrow$ User</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Include vs. Extend (The Cheat Sheet):</b></p><ul><li><b>Include (Base $\\rightarrow$ Child):</b> \"I <b>need</b> this to finish my job.\" (Cannot bake cake without mixing).</li><li><b>Extend (Child $\\rightarrow$ Base):</b> \"I <b>might</b> add this to the job.\" (Baking a cake, maybe adding sprinkles).</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Actors aren't just People:</b> External APIs (SendGrid) and Time (Cron Jobs) are also Actors.</li><li><b>Granularity:</b> Don't model UI steps. <b>Bad:</b> \"Click Submit\". <b>Good:</b> \"Register User\".</li><li><b>The \"Login\" Trap:</b> Don't link everything to \"Login\" via <code>&lt;&lt;include&gt;&gt;</code>. It clutters the diagram. Use a parent actor \"Authenticated User\" instead.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/usecase.png"
        ],
        "caption": ""
      }
  ]
},

  "Sequence Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Captures the <b>Dynamic Behavior</b> of the system. It shows Time-Ordered interactions between objects.</li><li><b>Focus:</b> \"Who talks to whom, and in what order?\"</li><li><b>Usage:</b> Perfect for modeling API flows, Service-to-Service communication, and Race Conditions.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Core Components:</b></p><ul><li><b>Lifeline (Dashed Line):</b> Represents an object or actor existing over time. (e.g., <code>:OrderService</code>).</li><li><b>Activation Bar (Thin Rectangle):</b> Represents the period when the object is active (processing or waiting). Meaning: \"The CPU/Thread is busy here.\"</li><li><b>Messages (Arrows):</b><ul><li><b>Synchronous:</b> Solid line + <b>Filled</b> Arrowhead (Request & Wait).</li><li><b>Asynchronous:</b> Solid line + <b>Open</b> Arrowhead (Fire & Forget).</li><li><b>Return:</b> Dashed line + Open Arrowhead (Response).</li><li><b>Self Message:</b> Arrow looping back to same lifeline.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Interaction Fragments (Logic in Diagrams):</b></p>Since diagrams are static, we use frames to represent code logic.<br><table><thead><tr><th>Fragment</th><th>Keyword</th><th>Code Equivalent</th><th>Meaning</th></tr></thead><tbody><tr><td><b>Alternative</b></td><td><code>alt</code></td><td><code>if (...) { } else { }</code></td><td>Mutually exclusive choices.</td></tr><tr><td><b>Option</b></td><td><code>opt</code></td><td><code>if (...) { }</code></td><td>Single choice. Runs only if true.</td></tr><tr><td><b>Loop</b></td><td><code>loop</code></td><td><code>for / while</code></td><td>Repeats the interaction inside.</td></tr><tr><td><b>Parallel</b></td><td><code>par</code></td><td>Threads / Futures</td><td>Interactions happen simultaneously.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "text",
      "content": "Example Flow (User Login)\n\nUser -> Controller : login(id, pwd) [Sync]\nactivate Controller\n\nController -> Service : validate(id) [Sync]\nactivate Service\n\nService -> Database : SELECT User [Sync]\nactivate Database\nDatabase --> Service : UserObject [Return]\ndeactivate Database\n\nalt [Password Match]\n    Service --> Controller : Token\nelse [Password Fail]\n    Service --> Controller : Error\nend\n\ndeactivate Service\nController --> User : Response\ndeactivate Controller"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Sync vs. Async (The Arrowhead Rule):</b><ul><li><b>Filled Arrowhead ($\rightarrow$):</b> You are blocked waiting for an answer (HTTP GET).</li><li><b>Open Arrowhead ($\rightarrow$):</b> You send it and move on immediately (Kafka Event).</li></ul></li><li><b>Don't Model Everything:</b> Do not draw arrows for getters/setters (<code>getName()</code>). It clutters the diagram. Only model significant business logic.</li><li><b>Database as a Lifeline:</b> In LLD, always represent the Database (or Cache) as a separate Lifeline. It clarifies latency and I/O boundaries.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/sequencediagram.png"
        ],
        "caption": ""
      }
  ]
},
  "Activity Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Describes the <b>Flow of Control (Workflow)</b> within a system. It models the sequence of activities step-by-step.</li><li><b>Analogy:</b> It is \"Flowchart 2.0\" (Object-Oriented Flowchart).</li><li><b>Key Difference:</b> Activity Diagrams support <b>Concurrency (Parallel processing)</b>, whereas traditional flowcharts are strictly sequential.</li><li><b>Focus:</b> \"What happens next?\" (Algorithm logic or Business Process).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Core Symbols:</b></p><table><thead><tr><th>Symbol</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td>&#9679;</td><td><b>Start Node</b></td><td>The entry point.</td></tr><tr><td>[Rounded Rect]</td><td><b>Action</b></td><td>Represents a step (e.g., \"Validate Order\").</td></tr><tr><td>&rarr;</td><td><b>Control Flow</b></td><td>Shows order of execution.</td></tr><tr><td>&diams;</td><td><b>Decision/Merge</b></td><td><b>Decision:</b> Splits flow (If/Else). <br><b>Merge:</b> Recombines paths.</td></tr><tr><td>&#128280;</td><td><b>End Node</b></td><td>\"Bullseye\". Termination point.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Concurrency (The \"Superpower\"):</b></p>This is the main reason we use Activity Diagrams in LLD over simple flowcharts.<br><ul><li><b>Fork (Split):</b><ul><li><b>Notation:</b> Thick black bar with 1 input and <b>Multiple outputs</b>.</li><li><b>Meaning:</b> \"Do these things simultaneously\" (Multi-threading).</li><li><i>Example:</i> After Order Placed $\\rightarrow$ Send Email AND Update Inventory.</li></ul></li><li><b>Join (Sync):</b><ul><li><b>Notation:</b> Thick black bar with Multiple inputs and <b>1 output</b>.</li><li><b>Meaning:</b> \"Wait for <b>all</b> threads to finish before continuing.\"</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Swimlanes (Partitioning):</b></p><ul><li><b>Definition:</b> Vertical or horizontal columns that divide activities based on <b>Responsibility</b> (Who does it?).</li><li><b>Usage:</b> Separates actions by Class, System, or Actor.</li><li><i>Example:</i> <b>User</b> (Click Checkout) | <b>System</b> (Validate) | <b>Bank</b> (Process Payment).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Activity vs. Sequence:</b><ul><li><b>Sequence Diagram:</b> Focuses on <b>Objects talking</b> (Time & Messages). Use for API contracts.</li><li><b>Activity Diagram:</b> Focuses on <b>Internal Logic</b> (If/Else, Parallelism). Use for complex algorithms.</li></ul></li><li><b>Concurrency Modeling:</b> In multi-threaded designs (e.g., Web Crawler), explicitly use <b>Fork and Join</b> bars. It proves you understand parallel computing constraints.</li><li><b>Missing \"Else\":</b> When drawing a Decision Diamond, always draw the outgoing arrow for <b>both</b> outcomes (Yes and No). Leaving a \"dead end\" is a logical error.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/activitydiagram.jpg"
        ],
        "caption": ""
      }
  ]
},

  "State Machine": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Models the <b>lifecycle of a single object</b> as it changes states in response to events.</li><li><b>Focus:</b> \"How does an object change over time?\" (Status updates).</li><li><b>Usage:</b> Mandatory for objects with complex lifecycles like <b>Orders, Payments, TCP Connections</b>, or Game Characters.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Components:</b></p><ul><li><b>State (Rounded Rectangle):</b> Represents a condition (e.g., <code>Pending</code>, <code>Shipped</code>).</li><li><b>Initial State:</b> Solid black circle (&#9679;). Birth of the object.</li><li><b>Final State:</b> Bullseye symbol. Death of the object.</li><li><b>Transition (Arrow):</b> Movement from one state to another.<br><b>Syntax:</b> <code>Trigger [Guard] / Action</code><ul><li><b>Trigger:</b> The event (e.g., <code>paymentReceived</code>).</li><li><b>Guard:</b> Boolean condition (e.g., <code>[amount &gt; 0]</code>).</li><li><b>Action:</b> Operation executed during move (e.g., <code>sendEmail()</code>).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Internal State Activities:</b></p>A state is not just a label; logic happens inside it.<br><ul><li><b>entry / action:</b> Executed immediately upon entering.</li><li><b>do / activity:</b> Executed continuously while inside.</li><li><b>exit / action:</b> Executed immediately before leaving.</li></ul><br><b>Example: \"Ringing\" State (Phone)</b><pre>State: Ringing\n  entry / playSound()   (Starts ringing immediately)\n  do / flashLight()     (Keeps flashing while ringing)\n  exit / stopSound()    (Stops sound when picked up)</pre>"
    },
    {
      "type": "text",
      "content": "<p><b>Composite States (Superstates):</b></p><ul><li><b>Definition:</b> A state that contains other sub-states.</li><li><b>Usage:</b> Groups related states to simplify the diagram.</li><li><b>Example:</b> A <code>PaymentProcessing</code> state might internally contain <code>Validating</code>, <code>Charging</code>, and <code>Refunding</code>. Cancelling transitions out of the entire container.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Activity vs. State Machine (#1 Confusion):</b><ul><li><b>Activity Diagram:</b> Models a <b>Process/Workflow</b> (Steps of a job). Focus = Control Flow.</li><li><b>State Machine:</b> Models an <b>Object</b> (Status of an entity). Focus = Data/Status Change.</li><li><i>Rule:</i> Use Activity for \"Checkout Flow\", State Machine for \"Order Status\".</li></ul></li><li><b>The State Design Pattern:</b> If asked to code this, <b>do not</b> use massive if-else/switch statements. Use the <b>State Design Pattern (GOF)</b>, where each state is a separate class.</li><li><b>Completeness:</b> Ensure every state has a way out (except Final). A state with entry but no exit is a \"Dead State\" (Bug).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/statediagram.png"
        ],
        "caption": ""
      }
  ]
},

  "System Boundary": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> A visual line (box) that separates the <b>Internal System</b> (what you are building) from the <b>External Environment</b> (Users, 3rd Party APIs).</li><li><b>Goal:</b> Explicitly define the <b>Scope</b> of the project.</li><li><b>Interpretation:</b><ul><li><b>Inside the Box:</b> Your responsibility. You design and code this.</li><li><b>Outside the Box:</b> External entities (Actors) that interact with your system but are not controlled by it.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Notation & Structure:</b></p><ul><li><b>Shape:</b> A large rectangle.</li><li><b>Content:</b><ul><li><b>System Name:</b> Written at the top (e.g., \"ATM System\").</li><li><b>Inside:</b> All Use Cases (Ovals).</li><li><b>Outside:</b> All Actors (Stick figures).</li></ul></li><li><b>Crossing the Line:</b> Lines connecting Actors to Use Cases must cross the boundary. This represents an <b>Interface</b> (UI or API).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Example: ATM System</b></p><ul><li><b>Box:</b> Labeled \"ATM Banking System\".</li><li><b>Outside:</b> Actors (Customer, Bank Mainframe, Technician).</li><li><b>Inside:</b> Use Cases (Withdraw Cash, Check Balance).</li><li><b>Flow:</b> Customer connects to <i>Withdraw Cash</i> (Crossing the boundary). <i>Withdraw Cash</i> connects to <i>Bank Mainframe</i> (Crossing again).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Scope Creep Defense:</b> The System Boundary is your tool to define limits. If a stakeholder asks to fix an external API, point to the boundary: \"That is an external actor; we can only interface with it.\"</li><li><b>Interface Identification:</b> Every line crossing the boundary represents a requirement:<ul><li>Line to User $\\rightarrow$ <b>UI</b> (Screen/App).</li><li>Line to System $\\rightarrow$ <b>API Contract</b> (REST/gRPC).</li></ul></li><li><b>Microservices:</b> In large systems, you can have nested boundaries. The \"Payment Service\" is a boundary inside the larger \"E-Commerce Platform\".</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/systemboundary.svg"
        ],
        "caption": ""
      }
  ]
},

  "Sync vs Async": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Difference:</b></p><ul><li><b>Synchronous (Blocking):</b><ul><li><b>Behavior:</b> The caller sends a request and <b>waits</b> (blocks the thread) until the response arrives.</li><li><b>Flow:</b> Serial execution (Step A $\\rightarrow$ Step B).</li><li><b>Analogy:</b> <b>A Phone Call.</b> You cannot do anything else until the other person stops talking.</li></ul></li><li><b>Asynchronous (Non-Blocking):</b><ul><li><b>Behavior:</b> The caller sends a request and <b>immediately moves on</b>. The response is handled later (via Callback, Future, or Event).</li><li><b>Flow:</b> Parallel execution.</li><li><b>Analogy:</b> <b>Email.</b> You send a mail and go back to work. You check the inbox later.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Architecture Patterns:</b></p><table><thead><tr><th>Feature</th><th>Synchronous</th><th>Asynchronous</th></tr></thead><tbody><tr><td><b>Protocol</b></td><td>HTTP (REST), gRPC</td><td>Message Queues (Kafka, RabbitMQ), Webhooks</td></tr><tr><td><b>Coupling</b></td><td><b>Tight.</b> Caller needs Callee to be online now.</td><td><b>Loose.</b> Callee can be down; message waits in Queue.</td></tr><tr><td><b>Latency</b></td><td><b>Additive.</b> Total = $T_1 + T_2 + T_3$.</td><td><b>Parallel.</b> Total = $Max(T_1, T_2, T_3)$.</td></tr><tr><td><b>Use Case</b></td><td>Real-time feedback (Login, Search).</td><td>Background tasks (Email, Reports).</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Synchronous (Blocking the Thread)\n// The thread STOPS here for 2 seconds waiting for payment\nPaymentResult result = paymentService.process(order); \nsendEmail(result); // This line cannot run until payment is done\n\n// 2. Asynchronous (Non-Blocking)\n// Fire and Forget / Future\nCompletableFuture.supplyAsync(() -> paymentService.process(order))\n    .thenAccept(result -> sendEmail(result)); // Callback\n\n// The main thread continues IMMEDIATELY to this line\nSystem.out.println(\"Order submitted!\"); "
    },
    {
      "type": "text",
      "content": "<p><b>Failure Models:</b></p><ul><li><b>Sync:</b> If Service B is down, Service A receives an Exception immediately. (<b>Fail Fast</b>).</li><li><b>Async:</b> If Service B is down, the message sits in the Queue. Service A thinks \"Everything is fine.\" (<b>Eventual Consistency</b>).</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Thread Pool Exhaustion (The Sync Killer):</b> In Synchronous systems (Spring MVC), every request holds a thread. If the Database slows down, all threads get stuck waiting, and the server hangs. Async frameworks (WebFlux) solve this by releasing the thread during I/O.</li><li><b>Eventual Consistency:</b> In Async systems, the user might see \"Processing...\" instead of \"Done.\" You must design the UI to handle this lag.</li><li><b>Dead Letter Queues (DLQ):</b> In Async, since there is no immediate caller to catch an exception, failed messages must go to a generic \"Error Queue\" (DLQ) for manual inspection or retry.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/syncasync.png"
        ],
        "caption": ""
      }
  ]
},

  "SRP": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: Single Responsibility Principle</b></p><ul><li><b>The Principle:</b> A class should have <b>one, and only one, reason to change</b>.</li><li><b>The Misconception:</b> People think \"It should do only one thing.\" No, that applies to functions. A class can have many methods, but they must all serve the same purpose or stakeholder.</li><li><b>The Litmus Test:</b> Ask yourself, \"Who is responsible for requesting changes to this class?\" <br>If the answer is \"The DBA\" AND \"The UI Designer,\" you have violated SRP.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"God Class\"):</b></p>Here, the <code>Employee</code> class has three divergent reasons to change:<ol><li><b>Business Logic:</b> HR changes salary rules.</li><li><b>Database Logic:</b> DBA changes SQL schema.</li><li><b>Presentation Logic:</b> Frontend changes report format.</li></ol>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: \"God Class\"\npublic class Employee {\n    public double calculatePay() { ... } // Logic\n    public void saveToDatabase() { ... } // Persistence\n    public String generateReport() { ... } // Presentation\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Decoupling):</b></p>Split the responsibilities into specialized classes."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Business Data & Rules (Domain)\npublic class Employee {\n    public double calculatePay() { ... } \n}\n\n// 2. Persistence (Repository Pattern)\npublic class EmployeeRepository {\n    public void save(Employee e) { ... }\n}\n\n// 3. Presentation (View/DTO)\npublic class EmployeeReporter {\n    public String generate(Employee e) { ... }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>\"Reason to Change\":</b> This is the keyword. Don't just say \"it keeps code clean.\" Say: \"It isolates the impact of change. If the Database schema changes, I shouldn't risk breaking the Payroll calculation logic.\"</li><li><b>High Cohesion:</b> SRP leads to High Cohesion. This means all methods in a class are closely related and work towards a shared goal.</li><li><b>Balance:</b> Don't overdo it. If you split a class into 10 tiny classes that are never used apart, you've created \"Fragmented Logic\" (Unnecessary Complexity). Only split if there is a divergent reason to change.</li></ul>"
    }
  ]
},

  "Liskov Substitution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.</li><li><b>The Simple Rule:</b> It's not enough for a child class to \"Is-A\" parent; it must <b>\"Act-Like-A\"</b> parent.</li><li><b>The Warning:</b> If a subclass overrides a method to do nothing or throws an exception, you have likely violated LSP.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Penguin\" Problem):</b></p>In biology, a Penguin is a Bird. In OOP, if <code>Bird</code> has a <code>fly()</code> method, a Penguin cannot be a Bird.<br><br><b>Bad Code:</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Bird {\n    public void fly() { ... }\n}\n\nclass Penguin extends Bird {\n    @Override\n    public void fly() {\n        // LSP Violation! \n        // The calling code expects to fly, but gets a crash.\n        throw new UnsupportedOperationException(\"I can't fly!\");\n    }\n}\n\n// Why it breaks:\npublic void makeBirdFly(Bird bird) {\n    bird.fly(); // If I pass a Penguin here, the program crashes.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Segregation):</b></p>Don't force functionality on classes that can't support it. Break the hierarchy based on <b>Capability</b>, not just biology."
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Bird { ... }\n\ninterface Flyable {\n    void fly();\n}\n\nclass Sparrow extends Bird implements Flyable {\n    public void fly() { ... }\n}\n\nclass Penguin extends Bird {\n    // No fly method here. Safe.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>The \"Square is a Rectangle\" Paradox:</b> This is the most famous interview question.<ul><li><b>Math:</b> A Square is a Rectangle.</li><li><b>OOP:</b> A Square is <b>NOT</b> a Rectangle if the objects are mutable.</li><li><b>Why:</b> If you have <code>setHeight(10)</code> on a Rectangle, you expect width to stay the same. On a Square, <code>setHeight(10)</code> implicitly changes the width to 10 too. This \"side effect\" breaks the expectations of the client code.</li></ul></li><li><b>Design by Contract:</b> LSP forces you to honor the contract of the parent class.<ul><li><b>Preconditions</b> (Input requirements) cannot be strengthened in subclass.</li><li><b>Postconditions</b> (Output guarantees) cannot be weakened in subclass.</li></ul></li><li><b>Refactoring Tip:</b> If you see methods like <code>throw new NotImplementedException()</code>, strictly flag it as an LSP violation.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Interface Segregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Clients should not be forced to depend on interfaces they do not use.</li><li><b>The Motto:</b> \"Many specific interfaces are better than one general-purpose interface.\"</li><li><b>The Goal:</b> Reduce the side effects of changes. If you change a method in a \"Fat Interface,\" you shouldn't force classes that don't use that method to recompile or break.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Fat Interface\"):</b></p>This occurs when you create a \"God Interface\" that covers too many capabilities.<br><br><b>Scenario:</b> We have a <code>Worker</code> interface. Robots work, but they don't eat."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: Forcing behavior\ninterface Worker {\n    void work();\n    void eat(); // Robots can't implement this meaningfully\n}\n\nclass Robot implements Worker {\n    public void work() { ... }\n    \n    public void eat() {\n        // ISP Violation! \n        // The Robot class is forced to implement a dummy method.\n        // This usually triggers an LSP violation too.\n        throw new RuntimeException(\"I don't eat!\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Role Interfaces):</b></p>Split the interface based on the client's needs, not the object's capabilities."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Good Code: Segregated Interfaces\ninterface Workable {\n    void work();\n}\n\ninterface Feedable {\n    void eat();\n}\n\n// Humans implement both roles\nclass Human implements Workable, Feedable {\n    public void work() { ... }\n    public void eat() { ... }\n}\n\n// Robots implement only what they need\nclass Robot implements Workable {\n    public void work() { ... }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Pollution:</b> If your interface implementation has methods that return <code>null</code> or throw <code>NotImplementedException</code>, you are likely violating ISP.</li><li><b>Refactoring Pattern:</b> If you have a massive interface (e.g., <code>OrderService</code> with 50 methods), use ISP to break it down into <code>OrderReader</code>, <code>OrderWriter</code>, and <code>OrderManager</code>. This makes <b>mocking in unit tests</b> much easier (you only mock the small interface you need).</li><li><b>Connection to SRP:</b> ISP is essentially SRP applied to Interfaces. An interface should have a single responsibility or role.</li></ul>"
    }
  ]
},

  "Dependency Inversion": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> High-level modules (Business Logic) should not depend on Low-level modules (Database, I/O, Network). Both should depend on <b>Abstractions</b> (Interfaces).</li><li><b>The Goal:</b> <b>Decoupling.</b> You want to be able to swap out the \"details\" (e.g., switch from MySQL to MongoDB, or Stripe to PayPal) without touching a single line of your core business logic.</li><li><b>Inversion:</b> Traditionally, logic depends on the database. Here, we invert the dependency arrow so the database implementation \"conforms\" to the logic's interface needs.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Tight Coupling):</b></p>Here, the <code>OrderService</code> (High Level) imports and creates a <code>MySQLDatabase</code> (Low Level). If you want to switch to PostgreSQL, you have to rewrite the Service.<br><br><b>Bad Code:</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class MySQLDatabase {\n    public void save(String order) { ... }\n}\n\nclass OrderService {\n    // VIOLATION: Hard dependency on a specific implementation (MySQL)\n    // The Service is now \"married\" to MySQL.\n    private MySQLDatabase database = new MySQLDatabase();\n\n    public void processOrder(String order) {\n        database.save(order);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Depend on Interface):</b></p>The Service defines \"What I need\" (the Interface). The Database implements it. The Service creates nothing; it receives the implementation (Dependency Injection)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Abstraction (Owned by High-Level Logic)\ninterface OrderRepository {\n    void save(String order);\n}\n\n// 2. The Low-Level Detail (Depends on Abstraction)\nclass MySQLDatabase implements OrderRepository {\n    public void save(String order) { ... } // SQL logic\n}\n\nclass MongoDatabase implements OrderRepository {\n    public void save(String order) { ... } // Mongo logic\n}\n\n// 3. The High-Level Module (Depends on Abstraction)\nclass OrderService {\n    private OrderRepository repository;\n\n    // Injection via Constructor\n    public OrderService(OrderRepository repository) {\n        this.repository = repository;\n    }\n\n    public void processOrder(String order) {\n        repository.save(order); // Doesn't know if it's MySQL or Mongo\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>DIP vs. DI vs. Framework:</b><ul><li><b>DIP:</b> The Principle (The Concept).</li><li><b>DI:</b> The Mechanism (The pattern, e.g., Constructor Injection).</li><li><b>Spring/Guice:</b> The Framework (The tool that automates DI).</li></ul></li><li><b>Wire Everything in Main:</b> In a DIP-compliant app, the only place that knows about specific classes (like <code>new MySQLDatabase()</code>) is the entry point (Application Startup / Configuration). The rest of the app just speaks \"Interface.\"</li><li><b>Testing Power:</b> DIP is the primary reason <b>Unit Testing</b> is possible. Because <code>OrderService</code> depends on an interface, you can inject a <code>MockRepository</code> during tests to simulate DB failures without needing a real database.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
}

  

  

  

  
}






















