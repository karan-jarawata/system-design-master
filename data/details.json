{
  "Classes & Objects": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Class:</b> The blueprint or template. It defines the structure (attributes) and capabilities (methods) common to all objects of that type. It does not occupy memory for data (mostly) until instantiated.</li><li><b>Object:</b> The instance of the class. It is a concrete entity created based on the blueprint that occupies memory and holds specific data values.</li></ul><br><p><b>Why use them?</b></p><ul><li><b>Modeling:</b> To represent real-world entities (e.g., <code>User</code>, <code>Payment</code>, <code>Button</code>) in code.</li><li><b>Encapsulation:</b> To bundle data (state) and methods (behavior) together, protecting the internal state from unauthorized access.</li><li><b>Reusability:</b> You write the code once (Class) and create as many instances (Objects) as needed.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>State (Fields/Attributes):</b> Variables that hold data (e.g., color, speed).</li><li><b>Behavior (Methods):</b> Functions that operate on the state (e.g., <code>accelerate()</code>, <code>brake()</code>).</li><li><b>Identity:</b> Every object has a unique identity (memory address), even if two objects have the exact same data values.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Blueprint (Class)\npublic class Car {\n    // State\n    String color;\n    int speed;\n\n    // Constructor (Initialization)\n    public Car(String color) {\n        this.color = color;\n        this.speed = 0;\n    }\n\n    // Behavior\n    public void accelerate() {\n        this.speed += 10;\n    }\n}\n\n// The Usage\npublic class Main {\n    public static void main(String[] args) {\n        // 'c1' is a reference variable, 'new Car()' creates the Object in Heap\n        Car c1 = new Car(\"Red\"); \n        c1.accelerate(); \n        \n        Car c2 = new Car(\"Blue\"); // Distinct identity from c1\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Memory Allocation:</b><ul><li><b>Class:</b> Loaded into Method Area (Metaspace in modern Java).</li><li><b>Object:</b> Allocated on the <b>Heap</b>.</li><li><b>Reference:</b> The variable (e.g., <code>c1</code>) is stored on the <b>Stack</b> and points to the Heap address.</li></ul></li><li><b>The <code>this</code> keyword:</b> Refers to the current object instance. It resolves ambiguity between class fields and parameters.</li><li><b>Object Equality:</b><ul><li><code>==</code> checks if two references point to the same memory address (<b>Identity</b>).</li><li><code>.equals()</code> (if overridden) checks if two objects have the same content (<b>State</b>).</li></ul></li><li><b>Lifecycle:</b> Objects are created via constructors and destroyed by the Garbage Collector (GC) when they are no longer reachable.</li><li><b>Anemic vs. Rich Domain Models:</b><ul><li><b>Anemic:</b> Classes only have data (getters/setters) and no logic. (Common in DTOs).</li><li><b>Rich:</b> Classes contain both data and the business logic that modifies that data. (Preferred in good OOP/LLD).</li></ul></li></ul>"
      }
    ]
  },
  "Interfaces": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>An Interface is a contract:</b> It defines <i>what</i> a class can do, without specifying <i>how</i> it does it. It is a collection of abstract methods (mostly) and constants that a class must implement.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Abstraction:</b> It hides implementation details and exposes only the capability.</li><li><b>Decoupling:</b> You can change the implementation without changing the code that uses it (<i>Dependency Inversion Principle</i>).</li><li><b>Multiple Inheritance:</b> Java classes cannot extend multiple classes, but they can implement multiple interfaces.</li><li><b>Polymorphism:</b> You can treat different objects (e.g., <code>Dog</code>, <code>Cat</code>) as the same type (e.g., <code>Animal</code>) if they implement the same interface.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Methods:</b> Methods without a body (implicitly <code>public abstract</code>).</li><li><b>Constants:</b> Variables are implicitly <code>public static final</code>.</li><li><b>Java 8+ Evolution:</b><ul><li><b>Default Methods:</b> Methods with a body (using <code>default</code> keyword) to allow adding new methods without breaking existing implementations.</li><li><b>Static Methods:</b> Utility methods related to the interface.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Contract\ninterface PaymentProcessor {\n    void processPayment(double amount); // Abstract method\n    \n    // Java 8 Default method (Backward compatibility)\n    default void logTransaction() {\n        System.out.println(\"Logging tx...\");\n    }\n}\n\n// The Implementation A\nclass PaypalProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via PayPal: \" + amount);\n    }\n}\n\n// The Implementation B\nclass StripeProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via Stripe: \" + amount);\n    }\n}\n\n// Usage (Polymorphism)\nclass CheckoutService {\n    // We program to the Interface, not the implementation\n    PaymentProcessor processor; \n\n    public CheckoutService(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>\"Program to an Interface, not an Implementation\":</b> This is a golden rule in design patterns. Always use the interface type for variable references (e.g., <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>).</li><li><b>Interface Segregation Principle (ISP):</b> Clients should not be forced to depend on interfaces they do not use. It's better to have many specific interfaces (e.g., <code>Readable</code>, <code>Writable</code>) than one general-purpose interface (e.g., <code>FileHandler</code>).</li><li><b>Interface vs. Abstract Class:</b><ul><li><b>Interface:</b> Defines \"Can-Do\" capability (e.g., <code>Runnable</code>, <code>Serializable</code>). Supports multiple implementations.</li><li><b>Abstract Class:</b> Defines \"Is-A\" relationship (e.g., <code>Vehicle</code>, <code>Mammal</code>). Shares code/state among related classes.</li></ul></li><li><b>Marker Interfaces:</b> Interfaces with no methods (e.g., <code>Serializable</code>, <code>Cloneable</code>). They provide metadata to the compiler or runtime that the class is special.</li><li><b>Functional Interface:</b> An interface with exactly one abstract method. Used heavily in Lambda expressions (e.g., <code>Runnable</code>, <code>Comparator</code>).</li></ul>"
      }
    ]
  },
  "Inheritance": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Inheritance</b> is the mechanism by which one class (Child/Subclass) acquires the properties (fields) and behaviors (methods) of another class (Parent/Superclass). It establishes an \"Is-A\" relationship.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Code Reusability:</b> Write common code once in the parent class and reuse it in multiple child classes.</li><li><b>Extensibility:</b> You can extend existing logic without modifying the original class (<i>Open/Closed Principle</i>).</li><li><b>Method Overriding:</b> Child classes can provide a specific implementation of a method already defined in the parent class.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Superclass (Parent/Base):</b> The class whose features are inherited.</li><li><b>Subclass (Child/Derived):</b> The class that inherits the other class.</li><li><b><code>extends</code> Keyword:</b> Used in Java to inherit from a class.</li><li><b><code>super</code> Keyword:</b> Used to access members (methods/constructors) of the immediate parent class.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Parent Class\nclass Vehicle {\n    protected String brand = \"Ford\"; // protected: accessible to subclasses\n    public void honk() {\n        System.out.println(\"Tuut, tuut!\");\n    }\n}\n\n// Child Class\nclass Car extends Vehicle {\n    private String modelName = \"Mustang\";\n    \n    // Overriding parent behavior\n    @Override \n    public void honk() {\n        super.honk(); // Calls parent's honk first\n        System.out.println(\"Honk from \" + modelName);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.honk(); // OUTPUT: Tuut, tuut! \\n Honk from Mustang\n        // myCar.brand is accessible here only if Main is in same package or subclass\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Diamond Problem:</b> Java does not support Multiple Inheritance with Classes (inheriting from two classes that have the same method). It solves this via Interfaces.</li><li><b>Liskov Substitution Principle (LSP):</b> A child class must be substitutable for its parent class without breaking the application. If <code>Dog</code> extends <code>Animal</code>, you should be able to use <code>Dog</code> anywhere <code>Animal</code> is expected.</li><li><b>Constructors are NOT inherited:</b> But the child class constructor must call the parent constructor (implicitly or explicitly via <code>super()</code>) as the first statement.</li><li><b><code>final</code> Class:</b> If a class is marked <code>final</code>, it cannot be inherited (e.g., <code>String</code> class in Java).</li><li><b>Composition over Inheritance:</b> In modern LLD, prefer Composition (\"Has-A\") over Inheritance (\"Is-A\") if the relationship is not strictly hierarchical. Inheritance creates tight coupling; composition is more flexible.</li></ul>"
      }
    ]
  },
  "Polymorphism": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Polymorphism</b> (Greek for \"many forms\") is the ability of a single interface or method name to support different underlying forms (types or implementations). It allows objects of different classes to be treated as objects of a common superclass.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Flexibility:</b> You can write code that works with a general type (e.g., <code>Shape</code>) and it will automatically work with any new specific types you add later (e.g., <code>Pentagon</code>) without changing the code.</li><li><b>Clean Code:</b> Reduces <code>if-else</code> or <code>switch</code> statements checking for types.</li><li><b>Decoupling:</b> The caller doesn't need to know the specific class of the object it's working with.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Compile-time Polymorphism (Static Binding):</b><ul><li>Achieved via <b>Method Overloading</b>.</li><li>Same method name, different parameters (signature) within the same class.</li><li>Resolved by the compiler.</li></ul></li><li><b>Runtime Polymorphism (Dynamic Binding):</b><ul><li>Achieved via <b>Method Overriding</b>.</li><li>Same method name and parameters in a Parent and Child class.</li><li>Resolved at runtime based on the actual object created.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// 1. Compile-time (Overloading)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n\n// 2. Runtime (Overriding)\nclass Animal {\n    void speak() { System.out.println(\"Animal makes a sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void speak() { System.out.println(\"Woof\"); }\n}\n\nclass Cat extends Animal {\n    @Override\n    void speak() { System.out.println(\"Meow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Upcasting: Parent Reference -> Child Object\n        Animal myPet = new Dog(); \n        \n        // The method called depends on the OBJECT (Dog), not the reference (Animal)\n        myPet.speak(); // Output: Woof\n        \n        myPet = new Cat();\n        myPet.speak(); // Output: Meow\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Upcasting:</b> Assigning a Child object to a Parent reference (e.g., <code>Animal a = new Dog()</code>). This is safe and implicit.</li><li><b>Downcasting:</b> Assigning a Parent reference back to a Child reference (e.g., <code>Dog d = (Dog) a</code>). This requires an explicit cast and an <code>instanceof</code> check to avoid <code>ClassCastException</code>.</li><li><b>Dynamic Method Dispatch:</b> This is the mechanism Java uses at runtime to figure out which version of an overridden method to call.</li><li><b>Static methods are NOT polymorphic:</b> If you define a static method with the same name in Parent and Child, the Child hides the Parent's method (<i>Method Hiding</i>), but it does not override it. The method called depends on the reference type, not the object.</li><li><b>Fields are NOT polymorphic:</b> If a Child defines a variable with the same name as the Parent, the variable accessed depends on the reference type.</li></ul>"
      }
    ]
  },
  "Abstraction": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstraction</b> is the process of hiding the complex implementation details and showing only the essential features of an object. It focuses on <i>what</i> an object does instead of <i>how</i> it does it.</li><li><b>Analogy:</b> Think of a car. You use the steering wheel and pedals (<b>Abstraction/Interface</b>) to drive. You don't need to know how the fuel injection or combustion engine (<b>Implementation</b>) works to operate it.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Reduces Complexity:</b> It simplifies the interaction for the user (or client code) by filtering out unnecessary details.</li><li><b>Security:</b> Hides internal data and logic that shouldn't be touched directly.</li><li><b>Maintainability:</b> You can change the complex internal logic (e.g., upgrade the engine) without changing the simple interface (the steering wheel), so client code doesn't break.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated on its own (0-100% abstraction). It can have both abstract methods (no body) and concrete methods (with body).</li><li><b>Interface:</b> A pure template (100% abstraction prior to Java 8). Defines only method signatures.</li><li><b>Access Modifiers:</b> Keywords like <code>private</code> and <code>protected</code> help enforce abstraction by hiding internal members.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Abstract Class - partial abstraction\nabstract class BankService {\n    // Abstract method: Logic hidden, must be defined by child\n    abstract void calculateInterest(); \n\n    // Concrete method: Common logic shared by all\n    void login() {\n        System.out.println(\"User Logged in\");\n    }\n}\n\nclass SavingsAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 4%\");\n    }\n}\n\nclass CurrentAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 0%\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // BankService b = new BankService(); // ERROR: Cannot instantiate abstract class\n        \n        BankService myBank = new SavingsAccount();\n        myBank.login();             // Shared logic\n        myBank.calculateInterest(); // Specific logic\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation</b> is about hiding data (bundling data + methods).</li><li><b>Abstraction</b> is about hiding implementation complexity (design level).</li></ul></li><li><b>\"Is-A\" Relationship:</b> Abstract classes are still classes. Use them when child classes share a lot of code but also need specific behavior (e.g., <code>Bird</code> is an abstract class, <code>Sparrow</code> and <code>Penguin</code> extend it).</li><li><b>The 100% Rule:</b> Before Java 8, Interfaces provided 100% abstraction. Now, with default methods, this line is slightly blurred, but conceptually they are still pure contracts.</li><li><b>Design Decision:</b> If you need to add a new method in the future:<ul><li><b>Abstract Class:</b> You can add a concrete method with a default implementation, and existing child classes will work fine.</li><li><b>Interface:</b> Adding a new abstract method breaks all implementing classes (unless you use a <code>default</code> method).</li></ul></li></ul>"
      }
    ]
  },
  "Encapsulation": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Encapsulation</b> is the bundling of data (variables) and methods (functions) that operate on that data into a single unit (Class). Crucially, it involves restricting direct access to some of an object's components, often referred to as \"<i>Data Hiding</i>\".</li><li><b>Analogy:</b> Think of a medical capsule: The medicine (data) is enclosed inside the capsule shell (methods), preventing it from being consumed directly or contaminated.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Control & Validation:</b> You can validate data before assigning it. For example, preventing a generic age variable from being set to -5.</li><li><b>Security:</b> Hides internal implementation details and protects the object's integrity.</li><li><b>Flexibility (Loose Coupling):</b> You can change the internal data structure (e.g., changing a variable from <code>String</code> to <code>StringBuilder</code>) without breaking the code that uses the class, as long as the public methods remain the same.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Access Modifiers:</b> The tools used to enforce encapsulation.<ul><li><code>private</code>: Visible only within the class (Best for state).</li><li><code>protected</code>: Visible to package + subclasses.</li><li><code>public</code>: Visible to everyone (Best for methods/interface).</li><li><code>(default/package-private)</code>: Visible only within the package.</li></ul></li><li><b>Getters (Accessors):</b> Public methods to read private data.</li><li><b>Setters (Mutators):</b> Public methods to modify private data (usually with validation logic).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class User {\n    // 1. Data is Private (Hidden)\n    private String username;\n    private int age;\n\n    // 2. Public Constructor\n    public User(String username, int age) {\n        this.username = username;\n        setAge(age); // Use setter to enforce logic even during creation\n    }\n\n    // 3. Public Getters (Read-only access)\n    public String getUsername() {\n        return username;\n    }\n\n    // 4. Public Setters (Controlled Write access)\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age provided\");\n            // Optionally throw exception\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        User u = new User(\"John\", 25);\n        // u.age = -5; // ERROR: usage of private field\n        u.setAge(-5);  // Output: Invalid age provided. Data remains safe.\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Getters/Setters are NOT mandatory:</b> Pure encapsulation isn't just generating getters and setters for every field (that makes it anemic). True encapsulation often involves methods that do things (e.g., <code>activateAccount()</code> instead of <code>setStatus(\"Active\")</code>).</li><li><b>Immutability:</b> A powerful form of encapsulation. If you make all fields <code>private final</code> and provide no setters, the object state cannot change once created. This makes the code thread-safe and predictable (e.g., <code>String</code> class).</li><li><b>\"Tell, Don't Ask\":</b> A design principle related to encapsulation. Instead of asking an object for its data to perform a calculation (if <code>user.getAge() > 18</code>), tell the object to do it (if <code>user.isAdult()</code>).</li><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation:</b> Hiding Information (State).</li><li><b>Abstraction:</b> Hiding Complexity (Implementation).</li></ul></li></ul>"
      }
    ]
  },
  "Access Modifiers": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Access modifiers</b> are keywords that define the scope and visibility of a class, constructor, variable, method, or data member. They determine who can see and use a specific part of your code.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Encapsulation:</b> They are the primary tool to implement encapsulation (hiding internal state).</li><li><b>Security:</b> Prevents sensitive data or critical logic from being tampered with by external classes.</li><li><b>Maintainability:</b> By restricting access, you limit the \"blast radius\" of changes. If a method is private, you can change it freely knowing no other class relies on it.</li></ul><br><p><b>Key Components (The 4 Levels):</b></p><ul><li><b>Private (<code>private</code>):</b> Only within the Same Class. <br><i>Analogy: Your diary. Only you can read it.</i></li><li><b>Default (none):</b> Within the Same Package only. (Package-Private). <br><i>Analogy: Family fridge. Accessible to everyone in the house.</i></li><li><b>Protected (<code>protected</code>):</b> Same Package + Subclasses (even in different packages). <br><i>Analogy: Family inheritance. Kids get it even if they move out.</i></li><li><b>Public (<code>public</code>):</b> Everywhere (Global). <br><i>Analogy: A billboard. Visible to the world.</i></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// PACKAGE A\npackage com.test.a;\npublic class Parent {\n    public int publicVar = 1;\n    protected int protectedVar = 2;\n    int defaultVar = 3;   // No keyword = Default\n    private int privateVar = 4;\n    \n    public void show() {\n        // All accessible here\n        System.out.println(privateVar); \n    }\n}\n\n// PACKAGE B\npackage com.test.b;\nimport com.test.a.Parent;\n\nclass Child extends Parent {\n    void accessTest() {\n        System.out.println(publicVar);    // OK\n        System.out.println(protectedVar); // OK (Child Class)\n        // System.out.println(defaultVar);   // ERROR: Diff Package\n        // System.out.println(privateVar);   // ERROR: Private\n    }\n}\n\nclass Stranger {\n    void accessTest() {\n        Parent p = new Parent();\n        System.out.println(p.publicVar);  // OK\n        // System.out.println(p.protectedVar); // ERROR: Not a child\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Principle of Least Privilege:</b> Always start with the most restrictive modifier (<code>private</code>) and open it up (<code>protected</code> -> <code>public</code>) only when absolutely necessary. This reduces coupling.</li><li><b>Class vs. Member:</b><ul><li>Top-level classes can only be <code>public</code> or <code>default</code> (package-private). They cannot be <code>private</code> or <code>protected</code>.</li><li>Nested/Inner classes can be all four.</li></ul></li><li><b>Method Overriding Rule:</b> When overriding a method in a child class, you cannot reduce the visibility. If Parent is <code>protected</code>, Child must be <code>protected</code> or <code>public</code>. It cannot be <code>private</code>.</li><li><b>Interface Members:</b><ul><li>Variables in interfaces are implicitly <code>public static final</code>.</li><li>Methods in interfaces are implicitly <code>public</code> (unless <code>private</code> in Java 9+).</li></ul></li></ul>"
      }
    ]
  },
  "Object Lifecycle": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>The Object Lifecycle</b> describes the series of states an object goes through from its <b>Creation</b> (instantiation), to its <b>Usage</b> (performing actions), and finally to its <b>Destruction</b> (garbage collection/memory deallocation).</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Memory Management:</b> Understanding the lifecycle helps prevent <i>Memory Leaks</i> (objects staying in memory when no longer needed).</li><li><b>Resource Management:</b> Ensures external resources (file handles, database connections) are opened and closed correctly.</li><li><b>Performance:</b> Knowing how objects are promoted (e.g., from Young to Old Generation in Java) helps in tuning application performance.</li></ul><br><p><b>Key Components (The 3 Stages):</b></p><ul><li><b>Creation (Initialization):</b><ul><li><b>Loading:</b> The <code>.class</code> file is loaded into the Method Area.</li><li><b>Allocation:</b> Memory is allocated on the <b>Heap</b> for the object.</li><li><b>Initialization:</b> The constructor is called to initialize the state.</li></ul></li><li><b>Usage (Live):</b> The object is referenced by a variable on the <b>Stack</b> or by another live object. It actively performs tasks.</li><li><b>Destruction (Death):</b><ul><li><b>Unreachable:</b> All references to the object are removed (e.g., set to <code>null</code> or out of scope).</li><li><b>Garbage Collection (GC):</b> The GC identifies the object as unreachable and reclaims the memory.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "class Report {\n    String data;\n    \n    public Report() {\n        System.out.println(\"1. Object Created (Constructor)\");\n    }\n    \n    public void print() {\n        System.out.println(\"2. Object in Use\");\n    }\n\n    // Deprecated in modern Java, but good for understanding lifecycle concepts\n    @Override\n    protected void finalize() { \n        System.out.println(\"3. Object Destroyed/GC'd\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Step 1: Creation\n        Report r = new Report(); \n        \n        // Step 2: Usage\n        r.print();\n        \n        // Step 3: Making Eligible for Destruction\n        r = null; // Reference broken. Object is now \"Unreachable\"\n        \n        // Requesting GC (Note: This is just a request, not a command)\n        System.gc(); \n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Stack vs. Heap:</b><ul><li><b>Local Variables</b> (references) live on the <b>Stack</b>.</li><li><b>Objects</b> (actual data) live on the <b>Heap</b>.</li><li>When a stack frame (method) ends, the references pop off, leaving the heap objects eligible for GC if no other references exist.</li></ul></li><li><b>Reachability:</b> An object is only garbage collected if there is no chain of references leading to it from a \"GC Root\" (active thread, static variable, local variable).</li><li><b>Generational GC:</b><ul><li><b>Eden Space:</b> Where new objects are born.</li><li><b>Survivor Space:</b> Objects that survive a GC cycle.</li><li><b>Old/Tenured Gen:</b> Long-lived objects (caches, singletons) move here.</li></ul></li><li><b><code>finalize()</code> is Deprecated:</b> Never rely on <code>finalize()</code> for cleanup (it's unpredictable). Use <code>try-with-resources</code> (<code>AutoCloseable</code> interface) for deterministic cleanup of resources like streams or connections.</li><li><b>Static Variables:</b> These live for the entire life of the application (Class Lifecycle), effectively acting as GC Roots. Be carefulâ€”they are a common source of memory leaks.</li></ul>"
      }
    ]
  },
  "Stack vs Heap": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p>These are the two main areas of memory used by a program.<br><ul><li><b>Stack:</b> A structured, temporary scratchpad for method execution. It stores local primitives and reference variables. It follows the <b>LIFO</b> (Last-In, First-Out) order.</li><li><b>Heap:</b> A large, unstructured pool for dynamic data storage. It stores actual <b>Objects</b> and JRE classes. Memory here is managed by the Garbage Collector.</li></ul><br><p><b>Why use them? (The Roles)</b></p><ul><li><b>Stack (Control Flow):</b> Used to track \"where am I in the code?\". It manages function calls, parameters, and return addresses automatically. When a method finishes, its block is instantly cleared.</li><li><b>Heap (Data Persistence):</b> Used when data needs to live longer than a single function call or when the size of data isn't known at compile time (e.g., a list that grows based on user input).</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Structure:</b> Stack is Linear (LIFO); Heap is Hierarchical/Complex (Young/Old Gen).</li><li><b>Visibility:</b> Stack is <b>Thread-safe</b> (private to each thread). Heap is <b>Shared</b> (all threads share the same Heap, requires synchronization).</li><li><b>Speed:</b> Stack has extremely fast access. Heap is slower due to complex allocation and lookup.</li><li><b>Life Span:</b> Stack is short-lived (method execution). Heap is long-lived (until GC).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class MemoryDemo {\n    public static void main(String[] args) { // Main Stack Frame starts\n        int x = 10;           // 'x' (primitive) stored directly on Stack\n        int y = 20;           // 'y' (primitive) stored directly on Stack\n        \n        Person p = new Person(\"Alice\"); \n        // 1. 'new Person(\"Alice\")' -> Creates Object in HEAP\n        // 2. 'p' (reference variable) -> Stored on STACK, pointing to Heap address\n        \n        print(p); \n    } // Main Stack Frame pops off (x, y, p are gone). Heap object becomes eligible for GC.\n\n    public static void print(Person p) { // New Stack Frame created\n        // 'p' here is a copy of the reference, pointing to same Heap Object\n        System.out.println(p.name);\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The References Rule:</b><ul><li><b>Primitives (int, boolean):</b> Value sits directly on the <b>Stack</b> (if local).</li><li><b>Objects (String, List, Car):</b> The <b>Reference</b> sits on the Stack, but the <b>Actual Data</b> sits in the <b>Heap</b>.</li></ul></li><li><b>The Errors:</b><ul><li><b>StackOverflowError:</b> Happens due to deep/infinite recursion. The stack runs out of space for new frames.</li><li><b>OutOfMemoryError (Java Heap Space):</b> Happens when you create too many objects and the GC cannot free up enough space.</li></ul></li><li><b>String Pool:</b> A special area inside the Heap to store String literals for reusability.</li><li><b>Thread Safety:</b> Since Stack is private to a thread, local variables are inherently thread-safe. Heap objects are shared, so if multiple threads modify the same object, you need <b>Locks/Synchronization</b>.</li></ul>"
      }
    ]
  },
  "Association": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Association</b> is a structural relationship that defines a link between objects of one class and objects of another. It represents a \"Has-A\" or \"Uses-A\" relationship.</li><li>It is the most general term for connection; <b>Aggregation</b> and <b>Composition</b> are specific, stricter types of Association.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Modularity:</b> It allows classes to be independent but still interact. A <code>Teacher</code> class doesn't need to be inside a <code>Student</code> class, but they need to be associated.</li><li><b>Reusability:</b> You can reuse independent classes in different relationships (e.g., a <code>User</code> class can be associated with <code>Order</code> in one context and <code>Comment</code> in another).</li><li><b>Navigation:</b> It defines the direction of data flow (Unidirectional vs. Bidirectional).</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Cardinality (Multiplicity):</b> Defines \"how many.\"<ul><li><b>One-to-One:</b> One User has one Profile.</li><li><b>One-to-Many:</b> One Teacher teaches multiple Students.</li><li><b>Many-to-Many:</b> Many Students take many Courses.</li></ul></li><li><b>Direction:</b><ul><li><b>Unidirectional:</b> <code>Order</code> knows about <code>Customer</code>, but <code>Customer</code> doesn't strictly need to track every <code>Order</code> object internally.</li><li><b>Bidirectional:</b> Both classes hold references to each other (requires careful management to avoid infinite loops).</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Unidirectional Association (Bank -> Employee)\nclass Employee {\n    String name;\n    public Employee(String name) { this.name = name; }\n}\n\nclass Bank {\n    String name;\n    // Association: Bank \"Has-Many\" Employees\n    List<Employee> employees; \n\n    public Bank(String name) {\n        this.name = name;\n        this.employees = new ArrayList<>();\n    }\n    \n    public void addEmployee(Employee e) {\n        employees.add(e);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Employee e1 = new Employee(\"Alice\");\n        Bank b1 = new Bank(\"HDFC\");\n        \n        // Establishing the link\n        b1.addEmployee(e1); \n        \n        // Note: If Bank is destroyed, Employee CAN exist independently \n        // (This distinguishes generic Association/Aggregation from Composition)\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Lifecycle dependency is key:</b> In a generic Association, there is no owner. The objects have their own independent lifecycles. If you delete one, the other survives.</li><li><b>Reflexive Association:</b> A class can be associated with itself.<br><i>Example:</i> An <code>Employee</code> class having a field <code>supervisor</code> which is also of type <code>Employee</code>.</li><li><b>Association vs. Dependency:</b><ul><li><b>Association:</b> Stronger. Class A holds a reference to Class B as a field/variable (state).</li><li><b>Dependency:</b> Weaker. Class A uses Class B only as a parameter in a method or a local variable, but doesn't hold onto it.</li></ul></li><li><b>Mapping:</b> In databases (SQL), associations are implemented using Foreign Keys and Join Tables.</li></ul>"
    }
  ]
},
  "Aggregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Aggregation</b> is a specialized form of Association. It represents a \"Whole-Part\" relationship (Has-A), but with <b>Weak Ownership</b>.</li><li>The \"Part\" (Child) can exist independently of the \"Whole\" (Parent). If the Parent is destroyed, the Child survives.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Shared Resources:</b> Use it when an object needs to be part of a group but might belong to multiple groups or exist on its own.</li><li><b>Decoupled Lifecycles:</b> When destroying the container shouldn't destroy the items inside.</li><li><b>Real-world analogy:</b> A Team and Players. If the Team is dissolved, the Players don't die; they become free agents or join other teams.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Container (Whole):</b> Holds the reference to the collection of items.</li><li><b>The Component (Part):</b> The item being held.</li><li><b>Independent Lifecycle:</b> The key differentiator from Composition. The child is usually passed into the parent via the constructor or a setter (external creation).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Player {\n    String name;\n    public Player(String name) { this.name = name; }\n}\n\nclass Team {\n    String teamName;\n    List<Player> players; // Aggregation\n\n    public Team(String teamName, List<Player> players) {\n        this.teamName = teamName;\n        this.players = players; // Players are created OUTSIDE and passed in\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Create Parts independently\n        Player p1 = new Player(\"Dhoni\");\n        Player p2 = new Player(\"Kohli\");\n\n        // 2. Create Whole and add Parts\n        List<Player> squad = new ArrayList<>(Arrays.asList(p1, p2));\n        Team india = new Team(\"India\", squad);\n        \n        // 3. Destruction Scenario\n        india = null; // Team is destroyed\n        \n        // p1 and p2 STILL EXIST. They were not destroyed with the Team.\n        System.out.println(p1.name); // Works fine\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with an <b>Empty (White) Diamond</b> on the container side.<br><code>Team &lt;&gt;------- Player</code></li><li><b>Parameter Injection:</b> In Aggregation, objects are usually passed into the class (Dependency Injection) rather than being created inside the class using <code>new</code>.</li><li><b>Vs. Composition:</b> Ask this question: \"If I delete the Parent, does the Child die too?\"<ul><li><b>If No -> Aggregation</b> (e.g., Car and Driver).</li><li><b>If Yes -> Composition</b> (e.g., Car and Engine - conceptually, for that specific car).</li></ul></li></ul>"
    }
  ]
},
  "Composition": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Composition</b> is a restricted form of Aggregation. It represents a strong \"Whole-Part\" relationship.</li><li><b>Strong Ownership:</b> The \"Part\" (Child) belongs exclusively to the \"Whole\" (Parent).</li><li><b>Dependent Lifecycle:</b> If the Parent is destroyed, the Child is also destroyed. The child cannot exist independently.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Logical Consistency:</b> Use it when the parts have no meaning outside the whole (e.g., a <code>Room</code> has no identity without a <code>House</code>).</li><li><b>Encapsulation:</b> The parent strictly controls the creation and access of the child components.</li><li><b>Flexibility:</b> It is preferred over Inheritance (\"Composition over Inheritance\") because it allows you to assemble complex behaviors dynamically without the rigidity of class hierarchies.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Owner:</b> The class that manages the lifecycle.</li><li><b>Internal Creation:</b> The child objects are usually created inside the parent's constructor using <code>new</code>. They are not passed in from the outside.</li><li><b>Cascading Delete:</b> Logic that ensures cleaning up the parent cleans up the children.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Room {\n    String type;\n    public Room(String type) { this.type = type; }\n}\n\nclass House {\n    private final List<Room> rooms; // Composition\n\n    public House() {\n        // Rooms are created INSIDE the House. \n        // If House dies, nobody else holds a reference to these specific rooms.\n        this.rooms = new ArrayList<>();\n        this.rooms.add(new Room(\"Bedroom\"));\n        this.rooms.add(new Room(\"Kitchen\"));\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        House myHouse = new House();\n        \n        // 1. Destruction Scenario\n        myHouse = null; \n        \n        // The 'Room' objects created inside myHouse are now unreachable.\n        // They will be Garbage Collected along with the House.\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with a <b>Filled (Black) Diamond</b> on the container side.<br><code>House &lt;#&gt;------- Room</code></li><li><b>The \"Death\" Test:</b><ul><li>If you delete the <code>Order</code>, do the <code>LineItems</code> disappear? <b>Yes (Composition)</b>.</li><li>If you delete the <code>School</code>, do the <code>Students</code> disappear? <b>No (Aggregation)</b>.</li></ul></li><li><b>Composition over Inheritance:</b> This is a major design principle.<ul><li><b>Inheritance:</b> You inherit everything (good and bad) and it's static (fixed at compile time).</li><li><b>Composition:</b> You only include what you need, and you can change behavior at runtime (by swapping the composed object).</li></ul></li></ul>"
    }
  ]
},
  "Composition over Inheritance": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This principle states that classes should achieve code reuse by containing instances of other classes (Composition) rather than inheriting from them.</li><li>It attacks the biggest flaw of inheritance: <b>Tight Coupling</b>.</li></ul><br><p><b>The \"Banana, Gorilla & Jungle\" Problem:</b></p>(This is the most important analogy to remember)<br>Joe Armstrong (creator of Erlang) famously explained why Inheritance is dangerous:<br><i>\"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\"</i><ul><li><b>The Banana:</b> The small piece of functionality you actually needed (e.g., a method <code>calculateTax()</code>).</li><li><b>The Gorilla:</b> The Parent Class (<code>TaxCalculator</code>) that owns the method.</li><li><b>The Jungle:</b> The entire inheritance tree and all the extra data/dependencies the Parent Class carries with it (Grandparents, heavy database connections, unnecessary state).</li></ul><br>Inheritance forces you to load the whole jungle just to eat one banana. <b>Composition lets you just pick the banana.</b><br><br><p><b>Why use Composition?</b></p><ul><li><b>Precision:</b> You pick exactly the behaviors you want. You don't inherit \"baggage\" (variables or methods you don't need).</li><li><b>Flexibility:</b> You can change behaviors at runtime.<br><i>Inheritance:</i> You are born a Dog. You stay a Dog forever.<br><i>Composition:</i> You are an entity holding a <code>SoundBehavior</code>. You can swap it from \"Bark\" to \"Howl\" instantly.</li><li><b>Safety:</b> You avoid the <b>Fragile Base Class</b> problem. Changes in a superclass won't unexpectedly break your subclass because you aren't inextricably linked to its internal structure.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Jungle Way (Inheritance)\n\n// The Jungle (Huge, heavy class)\nclass BigHeavyService {\n    void connectDB() { ... } // Heavy logic\n    void logAnalytics() { ... } // Heavy logic\n    int add(int a, int b) { return a + b; } // THE BANANA (The only thing we want)\n}\n\n// The Gorilla holding the Banana\nclass MyCalculator extends BigHeavyService {\n    // I just wanted 'add()', but now I have DB connections and Analytics \n    // attached to my simple Calculator object. This is wasteful and risky.\n}"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Banana Way (Composition)\n\nclass Adder {\n    int add(int a, int b) { return a + b; } // Just the Banana\n}\n\nclass MyCalculator {\n    private Adder adder = new Adder(); // HAS-A relationship\n    \n    // I delegate the work to the specific component I need.\n    // No Jungle attached.\n    int calculate(int a, int b) {\n        return adder.add(a, b);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember:</b></p><ul><li><b>Is-A vs Has-A:</b><ul><li>If you can say \"A Manager is a Person\" -> Inheritance might be okay.</li><li>If you can say \"A Car has an Engine\" -> Use Composition.</li></ul></li><li><b>The \"Final\" Solution:</b> Many modern languages (like Kotlin or Rust) or libraries make classes <code>final</code> by default to force you to use Composition instead of trying to inherit.</li><li><b>Testing is Easier:</b> In Composition, you can easily mock the <code>Adder</code> component to test <code>MyCalculator</code>. In Inheritance, you often can't mock the Parent class easily without initializing its complex state.</li></ul>"
    }
  ]
},
  "Diamond Problem": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Diamond Problem</b> is an ambiguity that arises in Multiple Inheritance when a class inherits from two classes that both descend from the same superclass.</li><li>If the top superclass (\"Grandparent\") has a method, and both intermediate classes (\"Parents\") override it, the final subclass (\"Child\") doesn't know which version of the method to inherit.</li></ul><br><p><b>The Problem (Why is it tricky?)</b></p><ul><li><b>Ambiguity:</b> If Class B and Class C both extend Class A and override method <code>run()</code>, and Class D extends both B and C... when you call <code>d.run()</code>, should it run B's version or C's version? The compiler cannot decide.</li><li><b>Complexity:</b> It complicates method dispatch and memory layout (e.g., in C++, it can lead to multiple copies of the Grandparent class in memory unless \"virtual inheritance\" is used).</li></ul><br><p><b>Key Components (The Shape):</b></p><ul><li>The inheritance hierarchy looks like a diamond:<br><b>A</b> (Top / Grandparent)<br><b>B extends A</b> & <b>C extends A</b> (Middle / Parents)<br><b>D extends B, C</b> (Bottom / Child)</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "interface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from C\"); }\n}\n\n// PROBLEM: D implements both B and C. Both have 'hello()'.\n// COMPILER ERROR: \"class D inherits unrelated defaults for hello()...\"\nclass D implements B, C {\n    \n    // RESOLUTION: You MUST override the method to resolve ambiguity.\n    @Override\n    public void hello() {\n        // Option 1: Define new logic\n        // System.out.println(\"Hello from D\"); \n        \n        // Option 2: Explicitly choose a parent using 'super'\n        B.super.hello(); \n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        new D().hello(); // Output: Hello from B\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Why Java banned multiple class inheritance:</b> Specifically to avoid this ambiguity and keep the language simple (simplicity was a major design goal of Java vs. C++).</li><li><b>Interface Resolution Rules:</b> If there is a conflict between interfaces:<ul><li><b>Classes win:</b> If a class extends a Parent and implements an Interface, the Parent's method always wins (Rule of \"Class wins\").</li><li><b>Sub-interfaces win:</b> If B extends A, B is more specific.</li><li><b>Explicit Override:</b> If there is no clear winner (like the code above), the compiler forces you to override and clarify.</li></ul></li><li><b>Composition is the fix:</b> If you genuinely need behavior from two different classes, don't try to inherit from both. Have one class as a field inside your new class (Composition).</li></ul>"
    }
  ]
},
  "Dynamic Dispatch": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Dynamic Dispatch</b> (or Dynamic Method Dispatch) is the mechanism by which a call to an overridden method is resolved at <b>runtime</b> rather than compile-time.</li><li>The compiler doesn't know which method implementation to call; the JVM decides at the last moment based on the <i>actual object</i> being referred to, not the variable type.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Enables Polymorphism:</b> It is the technical engine that makes runtime polymorphism possible.</li><li><b>Extensibility:</b> You can add new subclasses (e.g., a new plugin) without recompiling the code that calls the plugin methods. The dispatch mechanism automatically finds the new code.</li><li><b>Cleaner Code:</b> Replaces massive <code>if (obj instanceof TypeA) ... else if (obj instanceof TypeB)</code> blocks.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Upcasting:</b> A Reference Variable of a Parent class holding an Object of a Child class.</li><li><b>Overriding:</b> The Child class must provide a specific implementation of a method defined in the Parent.</li><li><b>Virtual Method Table (vtable):</b> (Under the hood) The JVM maintains a table of method addresses for each class. When a method is called, it looks up the address in this table for the specific object type to find the correct code.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class GameCharacter {\n    void attack() { System.out.println(\"Basic Punch\"); }\n}\n\nclass Warrior extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Sword Slash\"); }\n}\n\nclass Archer extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Shoot Arrow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Compile time: 'c' is just a GameCharacter reference.\n        GameCharacter c;\n        \n        // 2. Runtime: The object is actually a Warrior.\n        c = new Warrior();\n        \n        // 3. Dynamic Dispatch: JVM checks heap object (Warrior) -> calls Sword Slash\n        c.attack(); \n        \n        // 4. Runtime: The object changes to Archer.\n        c = new Archer();\n        \n        // 5. Dynamic Dispatch: JVM checks heap object (Archer) -> calls Shoot Arrow\n        c.attack();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Does NOT apply to Static Methods:</b> Static methods are bound at compile-time (<i>Static Dispatch</i>) based on the reference type. You cannot override static methods (only hide them).</li><li><b>Does NOT apply to Private/Final Methods:</b> These cannot be overridden, so the compiler knows exactly which method to call at compile-time (Optimization).</li><li><b>Does NOT apply to Instance Variables:</b> Data is not polymorphic. If Parent and Child both have a variable <code>int x</code>, <code>parentRef.x</code> will always access the Parent's variable, even if the object is a Child.</li><li><b>Double Dispatch:</b> In some patterns (like <b>Visitor</b>), you need to dispatch based on two object types (the visitor and the element). Java only supports <b>Single Dispatch</b> (based on the receiver object), so we simulate Double Dispatch using two method calls.</li></ul>"
    }
  ]
},
  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Immutability:</b> An object is Immutable if its internal state (data) cannot be modified after it is created. Once initialized, it remains constant for its entire lifecycle. If you want to change something, you must create a new object.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Thread Safety:</b> Since the state cannot change, multiple threads can access the object simultaneously without synchronization (no locking needed).</li><li><b>Hash Keys:</b> They make perfect keys for <code>HashMap</code> or <code>HashSet</code>. If the key object changed (mutable), its hashcode would change, and you would lose the value in the map.</li><li><b>Caching:</b> You can safely cache and share references without worrying that one caller will modify the data and affect others.</li></ul><br><p><b>Key Components (The Recipe):</b></p>To create an immutable class in Java:<br><ul><li><b><code>final</code> Class:</b> Prevent subclasses (which might be mutable).</li><li><b><code>private final</code> Fields:</b> Ensure fields are assigned once and not accessible directly.</li><li><b>No Setters:</b> Remove any methods that modify state.</li><li><b>Deep Copy:</b> If the class holds a Mutable object (like a <code>List</code> or <code>Date</code>), you must perform a defensive copy in the Constructor and the Getter.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Final class\npublic final class ImmutableUser {\n    \n    // 2. Private Final fields\n    private final String name;\n    private final List<String> roles; \n\n    public ImmutableUser(String name, List<String> roles) {\n        this.name = name;\n        // 3. Defensive Copy (In): Don't trust the list passed by the caller\n        this.roles = new ArrayList<>(roles);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 4. No Setters\n    \n    public List<String> getRoles() {\n        // 5. Defensive Copy (Out): Return a copy or unmodifiable view\n        // return new ArrayList<>(roles);\n        return Collections.unmodifiableList(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>String is Immutable:</b> This is the most famous example. <code>String s = \"A\"; s = \"B\";</code> does not change \"A\"; it creates a new string \"B\" and points <code>s</code> to it.</li><li><b>Shallow vs. Deep Immutability:</b><ul><li><b>Shallow:</b> The fields are final, but they point to mutable objects (e.g., an immutable <code>Student</code> class holding a mutable <code>Address</code> object). This is dangerous.</li><li><b>Deep:</b> The object and everything it points to is immutable.</li></ul></li><li><b>Memory Overhead:</b> Since you create new objects for every change, it can generate garbage (pressure on GC). However, modern GCs are very efficient at collecting short-lived objects.</li><li><b>Builder Pattern:</b> Often used to construct complex immutable objects cleanly since you can't use setters after creation.</li></ul>"
    }
  ]
},
  "Abstract Class vs Interface": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated and is used to define a base for subclasses. It represents an \"Is-A\" relationship (Identity).</li><li><b>Interface:</b> A contract that defines a set of behaviors. It represents a \"Can-Do\" relationship (Capability).</li></ul><br><p><b>Why use them? (The Choice)</b></p><ul><li><b>Use Abstract Class when:</b> You want to share code and state (variables) among closely related classes (e.g., <code>Car</code> and <code>Truck</code> sharing <code>fuelLevel</code> and <code>startEngine()</code>).</li><li><b>Use Interface when:</b> You want to define a common capability for unrelated classes (e.g., <code>Bird</code> and <code>Airplane</code> both implement <code>Flyable</code>). It enables loose coupling.</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Relationship:</b> Abstract Class is \"Is-A\" (Inheritance); Interface is \"Can-Do\" (Capability).</li><li><b>State (Fields):</b> Abstract Class can have private, protected, non-static, mutable fields. Interface has only <code>public static final</code> (Constants) and no instance state.</li><li><b>Inheritance:</b> Abstract Class supports <b>Single Inheritance</b> (extends one class). Interface supports <b>Multiple Inheritance</b> (implements many).</li><li><b>Constructors:</b> Abstract Class has constructors to initialize state. Interface cannot have constructors.</li><li><b>Access Modifiers:</b> Abstract methods can be public, protected, private. Interface methods are implicitly <code>public</code> (Java 9 allows private for internal logic).</li><li><b>Speed:</b> Abstract Class is slightly faster (direct binding). Interface is slightly slower (lookup in interface table).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Abstract Class: Defines Identity & Shared State\nabstract class Animal {\n    String name; // State\n    \n    public Animal(String name) { this.name = name; } // Constructor\n    \n    abstract void makeSound(); // Abstract method\n    \n    void sleep() { // Concrete shared method\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\n// 2. Interface: Defines Capability\ninterface Pet {\n    void play(); // Abstract contract\n}\n\n// 3. Concrete Class: Combines both\nclass Dog extends Animal implements Pet {\n    public Dog(String name) { super(name); }\n    \n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n    \n    @Override\n    public void play() { System.out.println(\"Fetching ball\"); }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Java 8+ Blur:</b> With <code>default</code> and <code>static</code> methods in Interfaces, you can add code to interfaces. However, you still cannot have instance variables (state) in interfaces. State is the main tie-breaker.</li><li><b>Versioning:</b><ul><li>Adding a method to an <b>Interface</b> breaks all implementing classes (unless you make it <code>default</code>).</li><li>Adding a concrete method to an <b>Abstract Class</b> is safe (all children inherit it automatically).</li></ul></li><li><b>Design Rule:</b> \"Favor Interfaces over Abstract Classes\" (Item 20 in <i>Effective Java</i>). Use Abstract Classes only when you explicitly need to share variables or strictly control the hierarchy.</li><li><b>Marker Interface:</b> An interface with no methods (e.g., <code>Serializable</code>) used purely to \"mark\" a class with a specific property.</li></ul>"
    }
  ]
},
  "ER Diagrams": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>An <b>ER Diagram</b> (Entity-Relationship Diagram) is the structural blueprint of a database. It abstracts away technical details (like SQL types) to focus on the data and how it connects (the \"Nouns\" and \"Verbs\").</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Entities (The Nouns):</b><ul><li><b>Strong Entity:</b> Has its own Primary Key (Identity). Symbol: Single Rectangle. (e.g., <code>Student</code>).</li><li><b>Weak Entity:</b> Depends on a \"Strong Entity\" for existence. Does not have a full PK. Symbol: Double Rectangle. (e.g., <code>Apartment</code> needs <code>Building</code>).</li><li><b>Associative Entity:</b> An entity formed by resolving a Many-to-Many relationship. (e.g., <code>Enrollment</code> connecting Student and Course).</li></ul></li><li><b>Attributes (The Adjectives):</b><ul><li><b>Key Attribute:</b> Unique ID (Primary Key). Symbol: Underlined Text.</li><li><b>Composite:</b> Can be divided into sub-parts (e.g., <code>Address</code> -> City, Zip). Physical DBs store the sub-parts.</li><li><b>Multivalued:</b> Can have multiple values (e.g., <code>PhoneNumbers</code>). Symbol: Double Oval.</li><li><b>Derived:</b> Calculated from other attributes (e.g., Age from DOB). Symbol: Dashed Oval.</li></ul></li><li><b>Relationships (The Verbs):</b><ul><li><b>Binary:</b> Between two entities (Most common).</li><li><b>Recursive (Unary):</b> An entity relates to itself (e.g., Employee manages Employee). Symbol: Line looping back to same entity.</li><li><b>Generalization (IS-A):</b> Inheritance in DBs. A Superclass (Vehicle) has Subclasses (Car, Truck). Symbol: Triangle pointing to Superclass.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Cardinality & Participation (The Rules):</b></p><ul><li><b>Cardinality (Maximums - \"How many?\"):</b><ul><li><b>1:1 (One-to-One):</b> CEO manages Company.</li><li><b>1:N (One-to-Many):</b> Customer places Orders. (Most common).</li><li><b>M:N (Many-to-Many):</b> Actor acts in Movies.</li></ul></li><li><b>Participation (Minimums - \"Must they?\"):</b><ul><li><b>Total (Mandatory):</b> Every entity must be involved (e.g., Every Loan must belong to a Bank). Symbol: Double Line.</li><li><b>Partial (Optional):</b> Not every entity needs to be involved (e.g., Not every Employee manages a Department). Symbol: Single Line.</li></ul></li></ul><br><p><b>Notation Reality Check:</b></p><ul><li><b>Chen Notation:</b> Uses Diamonds & Ovals. Good for academic exams/whiteboarding.</li><li><b>Crow's Foot Notation:</b> Uses Forks & Circles. Standard for Industry LLD & SQL Tools.<br><code>||</code> (Exactly One), <code>|&lt;</code> (One or More), <code>0|</code> (Zero or One), <code>0&lt;</code> (Zero or More).</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- The M:N Trap: You cannot implement Many-to-Many in physical SQL.\n-- You must create a Join Table (Associative Entity).\n\n-- Logical: [Student] M <---> N [Course]\n\n-- Physical Implementation:\nCREATE TABLE Student (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100)\n);\n\nCREATE TABLE Course (\n    course_id INT PRIMARY KEY,\n    title VARCHAR(100)\n);\n\n-- The Associative Entity (Join Table)\nCREATE TABLE Enrollment (\n    enrollment_id INT PRIMARY KEY,\n    student_id INT,\n    course_id INT,\n    grade CHAR(1),\n    FOREIGN KEY (student_id) REFERENCES Student(student_id),\n    FOREIGN KEY (course_id) REFERENCES Course(course_id)\n);"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The M:N Trap:</b> You cannot implement a Many-to-Many relationship in a physical SQL database. You must create a <b>Join Table</b> (Associative Entity) to break it into two 1:N relationships.</li><li><b>Identifying Weak Entities:</b> Ask: \"If I delete the Parent, does this child disappear entirely and lose its identity?\" If yes, it's a <b>Weak Entity</b> (e.g., <code>InvoiceLineItem</code> inside <code>Invoice</code>).</li><li><b>Normalization:</b> ER Diagrams should typically reflect <b>3rd Normal Form (3NF)</b>. Avoid storing attributes in the wrong entity (e.g., <code>SupplierAddress</code> should be in <code>Supplier</code>, not <code>Product</code>).</li><li><b>Naming Convention:</b> Use <b>Singular Nouns</b> for Entities (<code>User</code>, not <code>Users</code>) and <b>Verbs</b> for Relationships (<code>Owns</code>, <code>Completes</code>).</li></ul>"
    },
     {
        "type": "gallery",
        "urls": [
          "images/erdiagram3.png",
          "images/erdiagram.png",
          "images/erdiagram2.png"
        ],
        "caption": ""
      }
  ]
},

  "Normalization": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Normalization</b> is the process of organizing columns and tables in a database to reduce data redundancy (duplication) and improve data integrity.</li><li>It is essentially \"Clean Code\" for Data. You break large, messy tables into smaller, focused tables and link them using relationships.</li></ul><br><p><b>Why use it? (The 3 Anomalies)</b></p>We normalize to avoid \"Anomalies\"â€”logical errors that happen when data is duplicated.<br><i>Imagine a single table: <code>Student_Course_Table</code> storing Student Name, Course Name, and Instructor Name.</i><ul><li><b>Update Anomaly:</b> If \"Professor Snape\" changes his phone number, and he teaches 100 students, you have to update 100 rows. If you miss one, your data is inconsistent.</li><li><b>Insertion Anomaly:</b> You cannot add a new Course (e.g., \"Defense Against Dark Arts\") unless a student enrolls in it, because the Primary Key includes <code>Student_ID</code>. No student = No course record.</li><li><b>Deletion Anomaly:</b> If the only student in \"History of Magic\" drops the class, you delete the row. Poof! You just lost the information that \"History of Magic\" exists as a course.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Normal Forms (The Steps):</b></p>There is a famous mnemonic by database pioneer Bill Kent to remember the first three rules:<br><i>\"The data depends on the Key (1NF), the Whole Key (2NF), and Nothing But the Key (3NF)... so help me Codd.\"</i><br><br><ul><li><b>First Normal Form (1NF) - \"Atomic Values\":</b><ul><li><b>Rule:</b> Every cell must hold a single value. No lists, arrays, or comma-separated strings.</li><li><b>Bad:</b> A column <code>Skills</code> containing \"Java, Python, C++\".</li><li><b>Good:</b> A separate table <code>User_Skills</code> with one row per skill.</li></ul></li><li><b>Second Normal Form (2NF) - \"No Partial Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 1NF.</li><li><b>The Issue:</b> This usually applies when you have a <b>Composite Primary Key</b> (a key made of 2+ columns).</li><li><b>Rule:</b> Non-key columns must depend on the <i>entire</i> primary key, not just part of it.</li></ul></li><li><b>Third Normal Form (3NF) - \"No Transitive Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 2NF.</li><li><b>The Issue:</b> A non-key column depends on another non-key column.</li><li><b>Rule:</b> A column should depend <i>only</i> on the Primary Key.</li></ul></li><li><b>Boyce-Codd Normal Form (BCNF):</b> A stricter version of 3NF. It handles rare cases where a Primary Key column depends on a Non-Key column.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- 2NF Example: Fix Partial Dependency\n-- Scenario: Composite PK is (Student_ID, Course_ID)\n\n-- BAD (Violation): Student_Name depends ONLY on Student_ID, not Course_ID.\nTable Grades {\n    Student_ID (PK),\n    Course_ID (PK),\n    Student_Name, -- Partial Dependency!\n    Grade\n}\n\n-- GOOD (Normalized):\nTable Students {\n    Student_ID (PK),\n    Student_Name\n}\nTable Grades {\n    Student_ID (FK),\n    Course_ID (FK),\n    Grade\n}\n\n-- 3NF Example: Fix Transitive Dependency\n-- Scenario: PK is Order_ID\n\n-- BAD (Violation): City depends on Zip_Code, which depends on Order_ID.\n-- Chain: Order_ID -> Zip_Code -> City\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code,\n    City -- Transitive Dependency!\n}\n\n-- GOOD (Normalized):\nTable Locations {\n    Zip_Code (PK),\n    City\n}\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code (FK)\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Denormalization (The Reality Check):</b></p><ul><li>In LLD and System Design, we sometimes intentionally break these rules. This is called <b>Denormalization</b>.</li><li><b>Why?</b> Normalization requires <b>JOINS</b>. To get a User's profile, address, and recent orders in 3NF, you might need 3-4 Joins. This is slow for reading.</li><li><b>Trade-off:</b><ul><li><b>Normalized:</b> Fast Writes (no duplication to update), Slow Reads (Joins), Consistent Data.</li><li><b>Denormalized:</b> Fast Reads (Pre-joined data), Slow Writes (update everywhere), Risk of Inconsistency.</li></ul></li></ul><br><p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>3NF is the Gold Standard:</b> For most generic backend interviews and \"clean\" designs, aim for 3NF. Going to 4NF or 5NF is usually academic overkill.</li><li><b>Identifying dependencies is key:</b> Ask \"Does knowing X tell me Y?\" If knowing <code>ZipCode</code> tells you the <code>City</code>, then City is dependent on ZipCode. If ZipCode is not the Primary Key, move City out!</li><li><b>NoSQL is often Denormalized:</b> In MongoDB or Cassandra, we often store the Address object inside the User document (breaking 1NF/3NF). We accept the redundancy to avoid Joins.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/Normalization.png"
        ],
        "caption": ""
      }
  ]
},

  "Entity vs Value Object": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This is a fundamental distinction in Domain-Driven Design (DDD) regarding how we model objects based on their identity and lifecycle.</li><li><b>Entity:</b> An object defined by its <b>Identity</b> (Who it is). It has a unique ID that persists over time, even if its details change.</li><li><b>Value Object:</b> An object defined by its <b>Attributes</b> (What it looks like). It has no unique ID; it is defined strictly by the values it holds.</li></ul><br><p><b>The Analogy: \"The Person vs. The Money\"</b></p><ul><li><b>Entity (The Person):</b> Imagine you meet a friend named John. If John changes his shirt, he is still John. If you meet another person named John who looks exactly like him, they are still two different people. <i>Conclusion: You care about which specific person it is.</i></li><li><b>Value Object (The Money):</b> Imagine you have a $10 bill. If you lend it to a friend and they pay you back with a different $10 bill, do you care? No. You define it by its properties (10 USD), not its serial number.</li></ul><br><p><b>Deep Dive: Key Differences</b></p><ul><li><b>Identity:</b><ul><li><b>Entity:</b> Defined by a Unique ID (Primary Key, UUID).</li><li><b>VO:</b> Defined by its State (All fields combined).</li></ul></li><li><b>Equality Check:</b><ul><li><b>Entity:</b> <code>a == b</code> if their IDs match.</li><li><b>VO:</b> <code>a.equals(b)</code> if all fields match.</li></ul></li><li><b>Mutability:</b><ul><li><b>Entity:</b> Mutable. Its state changes over time (lifecycle).</li><li><b>VO:</b> Immutable. Once created, it never changes. To change it, you create a new one.</li></ul></li><li><b>Lifespan:</b><ul><li><b>Entity:</b> Has a history and lifecycle (Created -> Active -> Deleted).</li><li><b>VO:</b> Ephemeral. Created when needed, discarded when done.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Value Object (Money)\n// Notice there is no id. Equality checks the values.\npublic final class Money {\n    private final BigDecimal amount;\n    private final String currency;\n\n    public Money(BigDecimal amount, String currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    // VO Logic: Equality depends on content\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Money money = (Money) o;\n        return amount.equals(money.amount) && \n               currency.equals(money.currency);\n    }\n}\n\n// Entity (Order)\n// Notice the id. Equality checks the ID.\npublic class Order {\n    private final String orderId; // Identity\n    private Money totalCost;      // Has-A Value Object\n    private String status;        // Mutable state\n\n    public Order(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public void changeStatus(String newStatus) {\n        this.status = newStatus; // Can change\n    }\n\n    // Entity Logic: Equality depends ONLY on ID\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Order order = (Order) o;\n        return orderId.equals(order.orderId);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Swap Test:</b> To decide between Entity vs. Value Object, ask: \"If I replace this object with another one having the exact same values, does it break my system?\"<ul><li><b>If Yes</b> (I need that specific one) -> <b>Entity</b>.</li><li><b>If No</b> (Any identical one works) -> <b>Value Object</b>.</li></ul></li><li><b>Immutability is King:</b> Value Objects should always be immutable. Do not add setters. If you need to change a coordinate (x, y) to (x+1, y), return a new <code>Point</code> object.</li><li><b>Database Mapping:</b><ul><li><b>Entities</b> usually get their own Table (Users, Orders).</li><li><b>Value Objects</b> are usually <b>Embedded</b> in the parent's table (e.g., <code>user_address_city</code>, <code>user_address_zip</code> inside the Users table) or stored as a JSON blob.</li></ul></li><li><b>Code Smell:</b> If you see a Value Object (like <code>Color</code> or <code>Date</code>) with an <code>id</code> field, something is wrong.</li></ul>"
    }
  ]
},

  "ORM Mapping": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ORM (Object-Relational Mapping)</b> is a technique (and a software layer) that sits between your Object-Oriented code (Java/Python classes) and your Relational Database (SQL tables).</li><li>It acts as a <b>Translator</b>.<br><i>Your Code speaks \"Objects\"</i> (Inheritance, Polymorphism).<br><i>The DB speaks \"Tables\"</i> (Rows, FKs, Joins).</li><li>The ORM automatically translates \"Save User Object\" into <code>INSERT INTO users...</code> and vice versa.</li></ul><br><p><b>Why use it? (The Impedance Mismatch)</b></p>The fundamental problem ORM solves is the friction caused because the two paradigms are conceptually different:<ul><li><b>Granularity:</b> Java has nested classes (<code>Address</code> inside <code>User</code>); SQL has flat columns. ORM maps this.</li><li><b>Inheritance:</b> SQL tables don't support inheritance (e.g., Manager extends Employee). ORM simulates this strategies like Single Table.</li><li><b>Identity:</b> Java uses memory addresses/equals; SQL uses Primary Keys.</li><li><b>Relationships:</b> Java uses references (<code>user.getOrders()</code>); SQL uses Foreign Keys (<code>user_id</code>).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Key Mapping Annotations (The \"How\" in JPA/Hibernate):</b></p><ul><li><b>Class Level:</b><ul><li><code>@Entity</code>: \"Hey ORM, treat this class as a database table.\"</li><li><code>@Table(name=\"users\")</code>: \"Map this class specifically to the <code>users</code> table.\"</li></ul></li><li><b>Field Level:</b><ul><li><code>@Id</code>: \"This is the Primary Key.\"</li><li><code>@GeneratedValue</code>: \"Auto-increment this ID.\"</li><li><code>@Column(name=\"email_addr\")</code>: \"Map the email field to the <code>email_addr</code> column.\"</li><li><code>@Transient</code>: \"Ignore this field. Do not store it in the DB.\"</li></ul></li><li><b>Relationship Level:</b><ul><li><code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>: Defines the association logic.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity // 1. Mark as ORM Object\n@Table(name = \"employees\")\npublic class Employee {\n\n    @Id // 2. Primary Key\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    // 3. Mapping a Relationship\n    // \"Many Employees belong to One Department\"\n    @ManyToOne(fetch = FetchType.LAZY) \n    @JoinColumn(name = \"dept_id\") // The Foreign Key column in 'employees' table\n    private Department department;\n\n    // Standard Getters/Setters...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The N+1 Problem (Performance Killer):</b><ul><li><b>Scenario:</b> You fetch 100 <code>Department</code> objects. Then you loop through them and call <code>dept.getEmployees()</code> for each one.</li><li><b>What happens:</b> 1 Query to get Departments + 100 Queries (one per department) to get their employees = 101 Queries.</li><li><b>Fix:</b> Use \"Join Fetch\" (eagerly load data in the initial query using a JOIN) or Entity Graphs.</li></ul></li><li><b>Lazy vs. Eager Loading:</b><ul><li><b>Eager:</b> \"Bring the Jungle.\" When you fetch the User, the ORM effectively does a JOIN and fetches all their Orders immediately.</li><li><b>Lazy:</b> \"Bring the Banana.\" When you fetch User, the Orders list is just a proxy (empty placeholder). The DB query fires only when you touch <code>user.getOrders()</code>. <b>Best Practice:</b> Prefer Lazy loading.</li></ul></li><li><b>Caching (L1 vs L2):</b><ul><li><b>Level 1 (Session Cache):</b> Default. Within a single transaction, if you ask for User ID #1 twice, the ORM returns it from memory the second time.</li><li><b>Level 2 (Global Cache):</b> Optional (e.g., Redis). Shared across all users/sessions. Good for read-heavy, static data.</li></ul></li><li><b>Dirty Checking:</b> You don't always need to call <code>repository.save(user)</code>. If you modify a fetched object inside a <code>@Transactional</code> block, the ORM automatically detects the change and fires the UPDATE query when the transaction ends.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/ormmapping.png"
        ],
        "caption": ""
      }
  ]
},
  "Lazy vs Eager": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This concept dictates <i>when</i> related data is fetched from the database.</li><li><b>Eager Loading:</b> Fetches the main entity and its related entities immediately in a single go (usually via a massive JOIN).</li><li><b>Lazy Loading:</b> Fetches only the main entity. The related entities are fetched on-demand, only when you explicitly access them in your code.</li></ul><br><p><b>The Analogy: \"Moving Houses\"</b></p><ul><li><b>Eager Loading (The Over-Packer):</b> You move to a new house and pack everything you own (winter coats, old yearbooks, kitchen sink) into the truck immediately.<br><i>Pros:</i> Everything is there if you need it.<br><i>Cons:</i> The truck is heavy, slow, and you might not look at those old yearbooks for 5 years. Wasted effort.</li><li><b>Lazy Loading (The Minimalist):</b> You move with just your essentials (bed, clothes). You leave the rest in storage.<br><i>Pros:</i> The move is fast and light.<br><i>Cons:</i> If you suddenly decide you need your \"High School Yearbook,\" you have to drive back to storage (make another DB trip) to get it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Mechanics: How it works (The Proxy)</b></p><ul><li>How does Java know to fetch data later? <b>Proxies.</b></li><li>When you Lazy load a User's orders, Hibernate doesn't give you a <code>List&lt;Order&gt;</code>. It gives you a <b>Proxy Object</b> (a placeholder/stub).</li><li>This Proxy looks like a list, but it's empty.</li><li><b>The Trigger:</b> The moment you call <code>user.getOrders().size()</code> or access the data, the Proxy \"wakes up,\" fires a SQL query to the database, fills itself with real data, and then gives it to you.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity\npublic class User {\n    @Id\n    private Long id;\n\n    // EAGER: \"I want the Profile immediately when I get the User\"\n    // Result: SELECT * FROM User LEFT JOIN Profile ...\n    @OneToOne(fetch = FetchType.EAGER)\n    private Profile profile;\n\n    // LAZY: \"Don't fetch Orders yet. Just give me a placeholder.\"\n    // Result: SELECT * FROM User ... (No Orders yet)\n    @OneToMany(fetch = FetchType.LAZY) \n    private List<Order> orders;\n}\n\n// Usage\nclass Main {\n    void test(EntityManager em) {\n        User u = em.find(User.class, 1L); // Query 1 fires here (User + Profile)\n        \n        System.out.println(u.getProfile().getBio()); // No new query (Already loaded)\n        \n        System.out.println(\"Wait for it...\");\n        \n        // Query 2 fires HERE (The \"Lazy Initialization\")\n        System.out.println(u.getOrders().size()); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Defaults (Memorize this):</b> JPA has default settings based on cardinality.<ul><li><code>@OneToOne</code>, <code>@ManyToOne</code> (Single Association) -> Default is <b>EAGER</b>.</li><li><code>@OneToMany</code>, <code>@ManyToMany</code> (Collection Association) -> Default is <b>LAZY</b>.</li><li><i>Tip:</i> Always explicitly set <code>@ManyToOne(fetch = FetchType.LAZY)</code>. Eager loading is almost always a performance trap in large apps.</li></ul></li><li><b>LazyInitializationException:</b> This is the most common error in Hibernate.<ul><li><b>Cause:</b> You fetched a Lazy entity, closed the Database Session (Transaction ended), and <i>then</i> tried to access the lazy data.</li><li><b>Result:</b> The Proxy tries to go back to the DB, finds the connection closed, and crashes.</li><li><b>Fix:</b> Keep the transaction open (using <code>@Transactional</code>) or use \"Join Fetch\".</li></ul></li><li><b>When to use which?</b><ul><li><b>Use Eager:</b> When you are 100% sure you will use the related data every single time you load the parent (e.g., User and UserPreferences).</li><li><b>Use Lazy:</b> For everything else. Especially for Lists/Collections. Loading 5000 Orders just to check a User's name is a disaster.</li></ul></li></ul>"
    }
  ]
},

  "Schema Evolution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Schema Evolution</b> is the process of managing changes to your database structure (tables, columns, types) over time as your application requirements change.</li><li>It is the art of \"Changing the tires on a moving car.\" You need to upgrade the database without crashing the application or losing data.</li></ul><br><p><b>Why use it? (The Challenge)</b></p><ul><li><b>Agile Development:</b> Requirements change. You need a new <code>is_verified</code> column today that you didn't need yesterday.</li><li><b>Zero Downtime:</b> In modern systems, you cannot just shut down the server. The old code and the new database schema must often coexist during deployment.</li><li><b>Compatibility:</b> You must ensure Backward Compatibility (New DB works with Old Code) and Forward Compatibility (Old DB works with New Code).</li></ul><br><p><b>The Strategy: Expand and Contract (Parallel Change)</b></p><ul><li>This is the Gold Standard pattern for safe schema evolution without downtime. It involves multiple small steps instead of one big \"Rename\" or \"Delete\".</li><li><b>Scenario:</b> Rename <code>full_name</code> to <code>display_name</code>.</li><li><b>Steps:</b><ol><li><b>Expand (Add):</b> Add <code>display_name</code> (nullable). DB has both.</li><li><b>Dual Write:</b> Deploy code that writes to both, but reads from old.</li><li><b>Backfill:</b> Copy data from old to new.</li><li><b>Switch Read:</b> Deploy code that reads from new.</li><li><b>Contract (Remove):</b> Stop writing to old. Remove old column.</li></ol></li></ul><br><p><b>Tools of the Trade:</b></p><ul><li><b>Flyway / Liquibase:</b> Version control tools for your database. They use a hidden table (<code>schema_version</code>) to track which scripts have run.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- File: V2__split_name_column.sql\n\n-- 1. Add new columns (Allow NULLs initially to prevent locking/errors)\nALTER TABLE users ADD COLUMN first_name VARCHAR(50);\nALTER TABLE users ADD COLUMN last_name VARCHAR(50);\n\n-- 2. Migrate existing data (The Backfill)\n-- Ideally, do this in batches for large tables to avoid locking\nUPDATE users SET first_name = SPLIT_PART(full_name, ' ', 1),\n    last_name = SPLIT_PART(full_name, ' ', 2);\n\n-- 3. Add constraints (After data is safe)\n-- ALTER TABLE users ALTER COLUMN first_name SET NOT NULL;"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Never Rename Columns directly:</b> <code>RENAME COLUMN</code> is a destructive action. The code looking for \"old\" will instantly crash. Use Expand & Contract.</li><li><b>Locking & Performance:</b> Adding a column with a <code>DEFAULT</code> value (in older DB versions) can lock the entire table. <b>Fix:</b> Add as <code>NULL</code> first -> Populate -> Add <code>NOT NULL</code> constraint.</li><li><b>Deprecation Phase:</b> If you delete a column, ensure the code has stopped using it for at least one full deployment cycle.</li><li><b>NoSQL is easier (but messier):</b> In MongoDB, you don't need migrations. You can have Document A with <code>name</code> and Document B with <code>firstName</code>. The complexity moves from the Database to the Application Code.</li></ul>"
    }
  ]
},

  "Threads vs Processes": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy:</b></p><ul><li><b>Process (The House):</b> A Process is the \"container.\" It has the address (Memory Space) and the resources (Kitchen/TV). It provides the environment to live in.</li><li><b>Thread (The Person):</b> A Thread is the \"worker\" inside the house. It actually does the things (cooking, cleaning).</li><li><b>Multi-threading:</b> Multiple people living in the same house. They share the same Fridge (<b>Heap Memory</b>) but have their own To-Do lists (<b>Stacks</b>).</li></ul><br><p><b>How Java \"Thinks\" of a Thread:</b></p>In Java, a Thread is not just a concept; it is an Object that wraps a real Operating System resource.<br><ul><li><b>1:1 Mapping:</b> When you call <code>t.start()</code>, the JVM asks the OS to create a real, native thread. One Java Thread = One OS Thread.</li><li><b>The Wrapper:</b> The Java Thread object (in Heap) is just the \"Remote Control.\" It holds metadata, but the actual execution happens in the OS.</li><li><b>The Job vs The Worker:</b><ul><li><b>Runnable Interface</b> = The Job (The specific logic/code to run).</li><li><b>Thread Class</b> = The Worker (The resource that executes the job).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Memory Architecture (Crucial for LLD):</b></p><ul><li><b>The Heap (Shared Space):</b> Where Objects live (<code>new HashMap()</code>). Visible to ALL threads. <i>Risk: Race Conditions.</i></li><li><b>The Stack (Private Space):</b> Where Method Calls and Local Variables live. Visible ONLY to the owner thread. <i>Risk: None (Thread-safe).</i></li></ul><br><p><b>Context Switching (The Cost):</b></p><ul><li><b>Process Switch:</b> Slow. CPU saves entire memory map and loads new app.</li><li><b>Thread Switch:</b> Fast. CPU stays in same memory address, just swaps Registers and Stack Pointer.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Way 1: The \"Job\" Approach (Recommended - implements Runnable)\n// Decouples the logic from the thread object.\n\n// 1. Define the Job\nRunnable myTask = () -> {\n    System.out.println(\"Thread is running: \" + Thread.currentThread().getName());\n};\n\n// 2. Hire the Worker (Thread) and give him the Job\nThread worker = new Thread(myTask);\nworker.start(); // STARTS the thread. Do not call run() directly!\n\n// Way 2: The \"Subclass\" Approach (Not Recommended - extends Thread)\n// Hardcodes the logic into the thread itself."
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>t.start()</code> and <code>t.run()</code>?</b><br><b>Answer:</b> <code>start()</code> creates a new separate thread (native OS call) and then calls <code>run()</code> inside that new thread. <code>run()</code> is just a normal method call on the <i>current</i> thread (no multi-threading).</li><li><b>Q2: Why did Chrome move to \"Process-per-Tab\"?</b><br><b>Answer:</b> Isolation. If one tab (Thread) crashed, the whole browser (Process) closed. Processes provide memory isolation and stability.</li><li><b>Q3: If a Thread throws a <code>StackOverflowError</code>, what crashes?</b><br><b>Answer:</b> Only that specific thread dies.</li><li><b>Q4: If a Thread throws an <code>OutOfMemoryError</code> (Heap Space), what crashes?</b><br><b>Answer:</b> The entire Application (Process) usually crashes (Shared Heap is full for everyone).</li><li><b>Q5: Why is <code>implements Runnable</code> better than <code>extends Thread</code>?</b><br><b>Answer:</b> Java allows single inheritance. If you extend <code>Thread</code>, you can't extend anything else. <code>Runnable</code> is an interface, allowing better flexibility and design (separation of Task from Runner).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/processthread.jpg"
        ],
        "caption": ""
      }
  ]
},

  "Thread Lifecycle": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept & Analogy (The Gym Member):</b></p>A thread's life isn't just \"Running\" or \"Stopped.\" It moves through distinct phases managed by the OS Scheduler.<br><ul><li><b>New:</b> You just bought the gym membership. You haven't stepped inside yet.</li><li><b>Runnable (Ready + Running):</b> You are inside the gym. You might be lifting weights (<b>Running</b>) or waiting for your turn on the bench (<b>Ready</b>).</li><li><b>Blocked:</b> You want to use the Squat Rack, but someone else is using it. You wait passively for the resource (Lock).</li><li><b>Waiting:</b> You are resting on a bench and tell your trainer, \"Tap me when you are ready.\" You wait for a specific signal (Notification).</li><li><b>Timed Waiting:</b> You nap for exactly 10 minutes. You wake up automatically (Sleep).</li><li><b>Terminated:</b> You finished the workout and left. You cannot re-enter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>The 6 States (Technical Definitions - <code>Thread.State</code>):</b></p><ul><li><b>NEW:</b> Thread object created (<code>new Thread()</code>) but <code>start()</code> not called. No OS resources allocated.</li><li><b>RUNNABLE:</b> Includes both \"Ready to Run\" and \"Actually Running.\" The OS swaps them so fast Java groups them together.</li><li><b>BLOCKED:</b> <b>Passive Wait.</b> The thread tries to enter a <code>synchronized</code> block but the Lock is held by another thread. It uses 0% CPU.</li><li><b>WAITING:</b> <b>Active Voluntary Wait.</b> The thread explicitly paused itself (<code>Object.wait()</code>, <code>Thread.join()</code>) and waits for a signal (<code>notify()</code>).</li><li><b>TIMED_WAITING:</b> Same as WAITING, but with a timeout (<code>Thread.sleep(1000)</code>). Exits on timeout or interrupt.</li><li><b>TERMINATED:</b> Execution completed or crashed. The thread is dead.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class LifecycleDemo {\n    public static void main(String[] args) throws InterruptedException {\n        \n        // 1. NEW State\n        Thread t1 = new Thread(() -> {\n            try {\n                // 3. TIMED_WAITING State (during sleep)\n                Thread.sleep(1000); \n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        System.out.println(\"State 1: \" + t1.getState()); // Output: NEW\n\n        t1.start();\n        // 2. RUNNABLE State\n        System.out.println(\"State 2: \" + t1.getState()); // Output: RUNNABLE\n\n        Thread.sleep(100); // Main thread pauses to ensure t1 starts sleeping\n        \n        System.out.println(\"State 3: \" + t1.getState()); // Output: TIMED_WAITING\n\n        t1.join(); // Main thread waits for t1 to finish\n        \n        // 4. TERMINATED State\n        System.out.println(\"State 4: \" + t1.getState()); // Output: TERMINATED\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between BLOCKED and WAITING? (Very Common)</b><br><b>Answer:</b> <b>BLOCKED</b> happens automatically when waiting for a <i>Lock</i> (resource busy). <b>WAITING</b> happens manually when you call <code>.wait()</code> expecting a <i>Signal/Notification</i> (logic flow).</li><li><b>Q2: Can we restart a dead thread?</b><br><b>Answer:</b> No. Once TERMINATED, it's gone. Calling <code>start()</code> again throws an exception.</li><li><b>Q3: Difference between <code>Thread.sleep()</code> and <code>Object.wait()</code>?</b><br><b>Answer:</b> <code>sleep()</code> <b>keeps</b> the lock (\"I'm napping with the key in my pocket\"). <code>wait()</code> <b>releases</b> the lock (\"I'm pausing, here is the key for someone else\").</li><li><b>Q4: What is <code>Thread.yield()</code>?</b><br><b>Answer:</b> A hint to the scheduler to let other threads run. It goes from Running -> Ready (stays in RUNNABLE). Rarely used.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/threadlifecycle.png"
        ],
        "caption": ""
      }
  ]
},

  "Locks": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Locks</b> are mechanisms used to enforce limits on access to a resource in an environment where there are many threads of execution.</li></ul><br><p><b>The Analogy: \"The Fitting Room\"</b></p><ul><li><b>The Shared Resource:</b> A clothing store has one <b>Fitting Room</b>.</li><li><b>The Threads:</b> Many <b>Customers</b> want to try on clothes.</li><li><b>The Lock:</b> The <b>Latch</b> on the fitting room door.</li><li><b>The Process:</b><ul><li><b>Acquire Lock:</b> Customer A enters and locks the door.</li><li><b>Critical Section:</b> Customer A changes clothes. Customer B must wait outside (Blocked).</li><li><b>Release Lock:</b> Customer A unlocks and leaves.</li><li><b>Next Turn:</b> Customer B sees the door is free and enters.</li></ul></li><li><b>Without a Lock (Race Condition):</b> Customer A is half-naked, and Customer B barges in. Chaos (Data Corruption) ensues.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Race Condition:</b> A bug where the output depends on the timing of uncontrollable events (threads). Happens when multiple threads Read-Modify-Write shared data simultaneously.</li><li><b>Critical Section:</b> The specific lines of code that access the shared resource. This section needs protection.</li><li><b>Monitor (Intrinsic Lock):</b> Every Object in Java has an internal lock built-in. When you use <code>synchronized</code>, the thread grabs this specific object's monitor. <b>Rule:</b> Only one thread can hold an object's monitor at a time.</li></ul><br><p><b>Types of Synchronization:</b></p><ul><li><b>Synchronized Method (Coarse-Grained):</b> Locks the entire method using <code>this</code>. <i>Downside:</i> Slow; freezes the whole object.</li><li><b>Synchronized Block (Fine-Grained) - BEST PRACTICE:</b> Locks only a specific part of the code. Allows other threads to access other parts of the object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class FittingRoom {\n    public void tryOnClothes(String customerName) {\n        System.out.println(customerName + \" entered the store.\");\n\n        // Only one person can be inside this block at a time\n        synchronized(this) { \n            System.out.println(customerName + \" locked the Fitting Room.\");\n            try {\n                Thread.sleep(1000); // Simulate changing clothes\n            } catch (InterruptedException e) {}\n            System.out.println(customerName + \" unlocked the Fitting Room.\");\n        }\n        \n        System.out.println(customerName + \" left the store.\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions (Locks):</b></p><ul><li><b>Q1: Can Thread A enter <code>synchronized methodA()</code> and Thread B enter <code>synchronized methodB()</code> on the SAME object at the same time?</b><br><b>Answer:</b> No. Both methods use the same lock (<code>this</code>). Thread B is blocked.</li><li><b>Q2: Can Thread A enter a synchronized method and Thread B enter a non-synchronized method on the same object?</b><br><b>Answer:</b> Yes. Normal methods are \"Open Doors\"â€”anyone can walk in.</li><li><b>Q3: What is the difference between Object Lock and Class Lock?</b><br><b>Answer:</b><ul><li><b>Object Lock:</b> Locks a specific instance (<code>new FittingRoom()</code>).</li><li><b>Class Lock:</b> Locks the Class definition itself (<code>FittingRoom.class</code>). It is a Global Lock for all instances.</li></ul></li><li><b>Q4: Why prefer Synchronized Blocks over Methods?</b><br><b>Answer:</b> Performance. Blocks allow you to keep the \"Critical Section\" as small as possible.</li></ul>"
    },
    {
      "type": "text",
      "content": "<hr><p><b>The Deadlock (The Nightmare Scenario)</b></p><p><b>1. The Core Analogy: Pen and Paper</b></p><ul><li><b>The Scenario:</b> You and your friend need to write a letter. You need both a Pen and Paper.</li><li><b>The Trap:</b><ul><li>You grab the Pen (Holding Lock A).</li><li>Friend grabs the Paper (Holding Lock B).</li><li>You wait for the Paper.</li><li>Friend waits for the Pen.</li></ul></li><li><b>Result:</b> Neither of you will give up what you have. You stare at each other forever.</li></ul><br><br><p><b>2. Technical Definition & Conditions</b></p><ul><li><b>Deadlock:</b> A situation where two or more threads are blocked forever, waiting for each other.</li><li><b>The 4 Conditions (Coffman Conditions) - All must be true:</b><ol><li><b>Mutual Exclusion:</b> Only one thread can use the resource at a time.</li><li><b>Hold and Wait:</b> Holding a resource while waiting for another.</li><li><b>No Preemption:</b> Resources cannot be forcibly taken away.</li><li><b>Circular Wait:</b> A closed chain of threads waiting for each other.</li></ol></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// How to create a Deadlock\n\n// Thread 1\nsynchronized(LockA) {\n    System.out.println(\"Holding Lock A...\");\n    Thread.sleep(100); // Wait for Thread 2 to grab Lock B\n    \n    synchronized(LockB) { // WAITING FOREVER\n        System.out.println(\"Got Lock B\");\n    }\n}\n\n// Thread 2\nsynchronized(LockB) {\n    System.out.println(\"Holding Lock B...\");\n    Thread.sleep(100); // Wait for Thread 1 to grab Lock A\n    \n    synchronized(LockA) { // WAITING FOREVER\n        System.out.println(\"Got Lock A\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Deadlock Interview Questions:</b></p><ul><li><b>Q1: How do you prevent Deadlocks in code?</b><br><b>Answer:</b> The most practical way is <b>Lock Ordering</b>. Always acquire locks in the same order everywhere in your code. (e.g., Always Lock A then Lock B).</li><li><b>Q2: How do you detect a Deadlock in a running server?</b><br><b>Answer:</b> Take a <b>Thread Dump</b> (using tools like <code>jstack</code> or VisualVM). The tool will literally print a message saying: \"Found one Java-level deadlock\" and list the threads involved.</li><li><b>Q3: Can <code>synchronized</code> detect deadlocks and recover automatically?</b><br><b>Answer:</b> No. <code>synchronized</code> will wait forever. This is why we sometimes use <code>ReentrantLock</code> with <code>.tryLock()</code>, which allows us to say \"If I can't get the lock in 2 seconds, I'll give up,\" effectively breaking the deadlock.</li></ul>"
    }
  ]
},

  "ReentrantLock": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ReentrantLock</b> is a class in <code>java.util.concurrent.locks</code> that provides advanced locking capabilities beyond <code>synchronized</code>.</li></ul><br><p><b>The Analogy: \"The Security Badge\"</b></p><ul><li><b>The Scenario:</b> You work in a high-security building.</li><li><b>Reentrancy (Re-entering):</b><ul><li><b>Main Entrance:</b> You swipe your badge to enter. System: \"Welcome.\" (You hold the lock).</li><li><b>Server Room (Inside):</b> You need to enter a room <i>inside</i> the building. You swipe the same badge again.</li><li><b>Smart System (Reentrant):</b> It sees it's YOU (who already holds the lock) and lets you in immediately.</li><li><b>Dumb System (Non-Reentrant):</b> It says \"User is already in. Wait for User to leave.\" You are trapped waiting for yourself (Deadlock).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Hold Count:</b> The lock keeps a counter.<ul><li><code>lock()</code> -> Count increments (0 -> 1).</li><li><code>lock()</code> again (same thread) -> Count increments (1 -> 2).</li><li><code>unlock()</code> -> Count decrements (2 -> 1).</li><li>The lock is only released when Count reaches <b>0</b>.</li></ul></li><li><b>Fairness:</b><ul><li><b>Unfair (Default):</b> Faster. A new thread can \"cut in line\" if the lock is free.</li><li><b>Fair (<code>new ReentrantLock(true)</code>):</b> Slower. Strictly follows <b>FIFO</b>. The longest-waiting thread always gets the lock next.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SecuritySystem {\n    // 1. Create the Lock\n    // Pass 'true' to constructor for Fairness (FIFO)\n    private final ReentrantLock lock = new ReentrantLock(true); \n\n    public void accessResource() {\n        // 2. Lock Manually\n        lock.lock(); \n        \n        try {\n            // --- CRITICAL SECTION ---\n            System.out.println(\"Processing secure data...\");\n            \n            // Reentrancy Example:\n            // Calling another method that requires the SAME lock.\n            // This works fine because the lock is Reentrant.\n            internalAudit(); \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // 3. Unlock ALWAYS in finally\n            // Even if the code above crashes, this runs.\n            lock.unlock(); \n        }\n    }\n\n    public void internalAudit() {\n        lock.lock(); // Count goes 1 -> 2\n        try {\n            System.out.println(\"Auditing...\");\n        } finally {\n            lock.unlock(); // Count goes 2 -> 1\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the main difference between <code>synchronized</code> and <code>ReentrantLock</code>?</b><br><b>Answer:</b> Flexibility. <code>synchronized</code> is implicit and rigid (must wait forever). <code>ReentrantLock</code> is explicit (manual) and supports <b>Timeouts</b> (<code>tryLock</code>), <b>Fairness policies</b>, and multiple Condition variables.</li><li><b>Q2: What is <code>tryLock()</code> and why is it useful?</b><br><b>Answer:</b> <code>tryLock()</code> attempts to grab the lock but returns <code>false</code> immediately (or after a timeout) if it fails. Use it to prevent Deadlocks (\"If I can't get the lock in 2 seconds, I'll give up\").</li><li><b>Q3: Why shouldn't we use Fairness (true) all the time?</b><br><b>Answer:</b> <b>Performance.</b> Managing a strict queue takes CPU effort. Unfair locks have much higher throughput because they reduce context switching. Only use Fair locks if \"Starvation\" is a real problem.</li><li><b>Q4: What happens if you throw an Exception inside a <code>lock()</code> block without <code>finally</code>?</b><br><b>Answer:</b> The method exits, but <code>lock.unlock()</code> is never called. The lock remains held forever, hanging the system.</li></ul>"
    }
  ]
},

  "Volatile": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Notice Board vs. Personal Notepad Analogy:</b></li><li><b>The Setup:</b> Imagine an office with a Boss (Main Thread) and an Employee (Worker Thread).<ul><li><b>Main Memory (RAM):</b> A big Notice Board in the hallway.</li><li><b>CPU Cache:</b> The Employee's personal Notepad at their desk.</li></ul></li><li><b>The Problem (Without Volatile):</b> The Boss writes \"STOP WORKING\" on the Notice Board. The Employee looks at their Notepad, which still says \"KEEP WORKING.\" Result: The Employee works forever (Visibility Problem).</li><li><b>The Solution (With Volatile):</b> Declaring a variable <code>volatile</code> is a new rule: \"You are forbidden from writing this in your Notepad. You must walk to the Notice Board every single time you read or write this.\"</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Visibility:</b> <code>volatile</code> guarantees that changes made by one thread are immediately visible to other threads. It bypasses the CPU Cache (L1/L2) and goes straight to Main Memory (RAM).</li><li><b>Instruction Reordering (Memory Barrier):</b> Compilers like to rearrange code to make it faster. <code>volatile</code> acts as a wall. It prevents the compiler from reordering instructions across the variable.</li><li><b>Limitation:</b> It guarantees <b>Visibility</b>, but NOT <b>Atomicity</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Worker {\n    // WITHOUT 'volatile': \n    // The thread might cache 'running = true' and loop forever, \n    // even after you call stop().\n    private volatile boolean running = true; \n\n    public void run() {\n        System.out.println(\"Worker started.\");\n        \n        while (running) {\n            // \"Poll\" the variable. \n            // Because it is volatile, it checks Main Memory every single loop.\n        }\n        \n        System.out.println(\"Worker stopped.\");\n    }\n\n    public void stop() {\n        running = false; // Writes immediately to Main Memory\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The \"Count++\" Trap (What Volatile cannot do):</b></p><ul><li><b>Scenario:</b> You have <code>volatile int count = 0</code>. Two threads do <code>count++</code>.</li><li><b>The Bug:</b> <code>count++</code> is three steps: Read (0) -> Add (1) -> Write (1).</li><li><code>volatile</code> ensures they READ the latest value (0), but it doesn't stop them from running Step 2 at the exact same time. They both write 1.</li><li><b>Rule:</b> Never use <code>volatile</code> for counters or read-modify-write operations. Use <code>AtomicInteger</code> instead.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: What is the difference between <code>volatile</code> and <code>synchronized</code>?</b><br><b>Answer:</b><ul><li><b>volatile:</b> Light. Guarantees <b>Visibility only</b>. No locking (non-blocking).</li><li><b>synchronized:</b> Heavy. Guarantees <b>Visibility AND Atomicity</b>. Forces threads to wait (blocking).</li></ul></li><li><b>Q2: Can we use volatile for a Singleton (Double-Checked Locking)?</b><br><b>Answer:</b> Yes. The instance variable must be <code>volatile</code> to prevent a half-initialized object from being visible to other threads due to instruction reordering.</li><li><b>Q3: When should you use volatile?</b><br><b>Answer:</b> Only in two cases: <br>1. <b>Flags</b> (boolean status like <code>stopRequested</code>).<br>2. <b>Single Writer, Many Readers</b> (One thread updates, many just read).</li></ul>"
    }
  ]
},


  "Atomic Ops": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Atomic Operations</b> are operations that appear to the rest of the system to occur instantaneously. They are indivisible.</li></ul><br><p><b>The Core Analogy: \"The Like Button\"</b></p><ul><li><b>The Scenario:</b> A post has 99 likes. Two friends click \"Like\" at the exact same millisecond.</li><li><b>Non-Atomic Way (The Glitch):</b><ul><li>Phone A reads: 99. Phone B reads: 99.</li><li>Phone A writes: 100. Phone B writes: 100.</li><li><b>Result:</b> 100 Likes. (One like was lost).</li></ul></li><li><b>Atomic Way (The Fix):</b> The hardware forces the operations into a strict line.</li><li><b>Result:</b> 99 -> 100 -> 101.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>CAS (Compare-And-Swap):</b> The secret sauce behind Atomic variables. It is a hardware instruction that is faster than locking.<br><i>Logic:</i> \"I think the current value is A. If it is A, change it to B. If it is NOT A (because someone changed it), tell me, and I will try again.\"</li><li><b>Optimistic Locking:</b> Atomics assume conflicts are rare. They don't lock the door; they just try to update and retry if they fail. This is <b>Non-Blocking</b>.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicDemo {\n\n    // The \"Dangerous\" Way (int)\n    // int count = 0; // Not thread-safe. (Read-Modify-Write is 3 steps)\n\n    // The \"Safe\" Way (AtomicInteger)\n    // 1. Create the Atomic Variable\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        // 2. Atomic Increment\n        // Efficiently performs \"Read-Modify-Write\" in one shot using CAS.\n        // Returns the new value.\n        int newValue = count.incrementAndGet(); \n    }\n    \n    public int getCount() {\n        return count.get();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How are Atomics different from synchronized?</b><br><b>Answer:</b><ul><li><b>Atomics (CAS):</b> Optimistic. Non-blocking. Uses CPU instructions directly. Very fast for simple counters.</li><li><b>Synchronized:</b> Pessimistic. Blocking. Context switches threads. Better for complex logic.</li></ul></li><li><b>Q2: What is the \"ABA Problem\" in CAS?</b><br><b>Answer:</b> A famous bug. Thread 1 reads A. Thread 2 changes A -> B -> A. Thread 1 wakes up, sees A, and thinks \"Nothing changed!\", so it proceeds erroneously. <b>Fix:</b> Use <code>AtomicStampedReference</code> (Versions: A v1 -> B v2 -> A v3).</li><li><b>Q3: Can AtomicInteger replace synchronized blocks?</b><br><b>Answer:</b> Only for single variable updates. If you need to update balance AND transactionHistory together atomically, you still need <code>synchronized</code>.</li></ul>"
    }
  ]
},

  "ExecutorService": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ExecutorService</b> is the High-Level Interface in Java that manages a pool of threads, a work queue, and the lifecycle of task execution. It replaces the manual creation of threads.</li></ul><br><p><b>The Core Analogy: \"The Restaurant Manager\"</b></p><ul><li><b>The Old Way (<code>new Thread()</code>):</b> Customer enters. You hire a new chef. Chef cooks. You fire the chef. <i>Result:</i> Chaos and high cost.</li><li><b>The New Way (Thread Pool):</b> You hire a <b>Manager (ExecutorService)</b> and a <b>Fixed Crew</b> of 5 chefs.<ul><li>Customer enters. Manager gives the order to Chef 1.</li><li>If all chefs are busy, the Manager puts the order on the <b>Waiting Spike (Queue)</b>.</li><li>When Chef 1 is done, they pick the next ticket from the queue.</li></ul></li><li><b>Result:</b> Stability. You handle 1,000 customers with just 5 reused chefs.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why <code>new Thread()</code> is forbidden:</b><ul><li><b>Expensive:</b> Creating a thread takes OS resources (Stack Memory ~1MB).</li><li><b>Uncontrolled:</b> If you spawn 100k threads, you get <code>OutOfMemoryError</code>.</li></ul></li><li><b>Thread Pool:</b> A collection of pre-started threads that are reused for multiple tasks.</li></ul><br><p><b>Types of Pools (The \"Kitchen\" Types):</b></p><ul><li><b>FixedThreadPool(n):</b> Creates n threads. If busy, tasks queue up. <i>Best for:</i> Predictable, stable loads.</li><li><b>CachedThreadPool():</b> Creates new threads as needed. Kills them if idle for 60s. <i>Best for:</i> Short, bursty tasks. <i>Risk:</i> Can crash if load is infinite.</li><li><b>SingleThreadExecutor():</b> Only 1 thread. Tasks run sequentially. <i>Best for:</i> Ordering (logging).</li><li><b>ScheduledThreadPool():</b> Runs tasks after delay or periodically.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.*;\n\npublic class ManagerDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // 1. Hire the Manager (Fixed crew of 2 threads)\n        ExecutorService manager = Executors.newFixedThreadPool(2);\n\n        // 2. Submit a Task (Callable = Returns a Result)\n        // \"Future\" is the Claim Ticket/Receipt.\n        Future<String> receipt = manager.submit(() -> {\n            Thread.sleep(1000); // Simulate work\n            return \"Burger Ready!\";\n        });\n\n        System.out.println(\"Doing other work while burger cooks...\");\n\n        // 3. Get the Result (Blocking)\n        // This waits until the chef is done.\n        String result = receipt.get(); \n        System.out.println(result);\n\n        // 4. Close the Kitchen\n        manager.shutdown();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Difference between <code>execute()</code> and <code>submit()</code>?</b><br><b>Answer:</b> <code>execute()</code> is \"Fire and Forget\" (returns void). <code>submit()</code> returns a <b>Future</b>, allowing you to check status or get return values.</li><li><b>Q2: If a thread crashes (unchecked exception), what happens?</b><br><b>Answer:</b> The pool detects the thread died, discards it, and creates a <b>new one</b> to replace it. Pool size remains constant.</li><li><b>Q3: Risks of <code>CachedThreadPool</code> in production?</b><br><b>Answer:</b> <b>System Crash.</b> Since it creates a thread for <i>every</i> task if others are busy, a spike of 1M requests = 1M threads = <code>OutOfMemoryError</code>.</li><li><b>Q4: What is a Future?</b><br><b>Answer:</b> It's a placeholder object for a result that hasn't arrived yet (like a claim ticket). It allows the main thread to keep working and check for the result later using <code>future.get()</code>.</li></ul>"
    }
  ]
},


  "Concurrent Collections": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Concurrent Collections</b> are specialized data structures designed to be accessed and modified by multiple threads simultaneously without explicit external synchronization and without compromising data integrity.</li></ul><br><p><b>The Core Analogy: \"The Attendance Sheet\"</b></p><ul><li><b>The Scenario:</b> A classroom with 30 students and one attendance sheet.</li><li><b>The Old Way (Hashtable / Synchronized Map):</b><ul><li><b>The Rule:</b> The teacher holds the single sheet.</li><li><b>The Bottleneck:</b> If Student A is signing, Student Z must wait in line, even if they are signing at the bottom of the page.</li><li><b>Result:</b> Safe, but Slow (Coarse-grained locking).</li></ul></li><li><b>The New Way (ConcurrentHashMap):</b><ul><li><b>The Rule:</b> The teacher tears the sheet into 16 pieces (Buckets) and pastes them on different walls.</li><li><b>The Parallelism:</b> Student A goes to Wall 1. Student Z goes to Wall 16. They sign simultaneously.</li><li><b>Result:</b> Safe and Fast (Fine-grained locking).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions:</b></p><ul><li><b>Why HashMap fails:</b> It is not thread-safe. If two threads modify it at once, it can corrupt the internal linked list (infinite loops) or lose data.</li><li><b>Why Hashtable is obsolete:</b> It uses a <b>Global Lock</b> (synchronized on the whole method). Only one thread can read/write at a time.</li><li><b>ConcurrentHashMap (The King):</b><ul><li><b>Lock Striping (Bucket Locking):</b> Instead of locking the whole map, it only locks the specific Bucket (index) you are writing to.</li><li><b>Read Operations (<code>get</code>):</b> Completely <b>Lock-Free</b>. They are non-blocking and very fast.</li><li><b>Iterators:</b> <b>Fail-Safe</b>. You can iterate over the map while other threads are adding/removing items without crashing.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentMapDemo {\n    public static void main(String[] args) {\n        \n        // Thread-safe map designed for high concurrency\n        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n        map.put(\"Apple\", 1);\n        map.put(\"Banana\", 2);\n\n        // Thread 1: Writing to 'Orange' bucket\n        new Thread(() -> {\n            map.put(\"Orange\", 3); \n            System.out.println(\"Added Orange\");\n        }).start();\n\n        // Thread 2: Reading 'Apple' bucket (Non-blocking)\n        // Works instantly even if Thread 1 is writing\n        new Thread(() -> {\n            System.out.println(\"Read Apple: \" + map.get(\"Apple\"));\n        }).start();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How does ConcurrentHashMap work internally in Java 8+?</b><br><b>Answer:</b> It no longer uses \"Segments.\" It uses a hybrid of <b>CAS</b> and <b>synchronized</b>.<ul><li><b>Empty Bucket:</b> Uses <b>CAS</b> to insert the new node (Lock-Free).</li><li><b>Collision:</b> If the slot has data, it locks <b>ONLY that specific Node</b> (using <code>synchronized</code>) to append to the list/tree.</li></ul></li><li><b>Q2: Why does ConcurrentHashMap NOT allow null keys or values?</b><br><b>Answer:</b> <b>Ambiguity.</b> In a normal map, <code>null</code> could mean \"Value is null\" OR \"Key doesn't exist.\" In multi-threading, you can't double-check with <code>containsKey()</code> because the map might change between the two calls. To prevent this race condition confusion, nulls are banned.</li><li><b>Q3: What is <code>ConcurrentModificationException</code>?</b><br><b>Answer:</b> A crash in normal collections (ArrayList) if you modify the list while iterating. <b>Fix:</b> Use <code>CopyOnWriteArrayList</code> or <code>ConcurrentHashMap</code> (Fail-Safe iterators).</li><li><b>Q4: Is <code>size()</code> accurate in ConcurrentHashMap?</b><br><b>Answer:</b> No, it is an <b>estimate</b>. Because threads are constantly adding/removing, the size might change before the method returns.</li></ul>"
    }
  ]
},

  "Thread-Safety": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Thread-Safety</b> means that code functions correctly (no data corruption, no crashes) when accessed by multiple threads simultaneously.</li></ul><br><p><b>The Core Analogy: \"The Kitchen Safety Hierarchy\"</b></p><ul><li><b>The Goal:</b> Multiple chefs (Threads) need to cook in the same building without ruining each other's food.</li><li><b>Strategy 1: Private Kitchens (Statelessness) - ðŸ¥‡ GOLD STANDARD:</b> Every chef gets their own private room and ingredients. <br><i>Result:</i> 100% Safe. No collisions possible.</li><li><b>Strategy 2: The Museum Display (Immutability) - ðŸ¥ˆ SILVER BULLET:</b> The recipe book is behind bulletproof glass. Chefs can read it, but no one can scribble on it. <br><i>Result:</i> 100% Safe. Read-only shared data never causes race conditions.</li><li><b>Strategy 3: The Locked Pot (Synchronization) - ðŸ¥‰ BRONZE:</b> There is one shared soup pot with a lock on the lid. <br><i>Result:</i> Safe, but Slow. Chefs must wait in line.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Technical Definitions & Code:</b></p><ul><li><b>Stateless Object:</b> An object with no instance variables (fields). It relies only on method arguments (Stack memory), which are inherently private to the thread.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// A. Stateless Service (The Best Way)\n// Safe because it has NO state (fields)\npublic class MathService {\n    \n    public int add(int a, int b) {\n        // 'a' and 'b' are local variables (Stack). \n        // Thread A's 'a' is totally different from Thread B's 'a'.\n        return a + b; \n    }\n}"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Immutable Object:</b> An object whose state cannot be changed after creation. All fields are <code>final</code> and there are no setters.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// B. Immutable Object (The Read-Only Way)\n// Safe because state CANNOT change\npublic final class UserConfig {\n    private final String url;\n    private final int timeout;\n\n    public UserConfig(String url, int timeout) {\n        this.url = url;\n        this.timeout = timeout;\n    }\n\n    public String getUrl() { return url; }\n    // NO SETTERS.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: How do you make a Java class Thread-Safe? (The Hierarchy)</b><br><b>Answer:</b> (Always order by preference) <br>1. <b>Statelessness:</b> Can I remove the fields? (Best)<br>2. <b>Immutability:</b> Can I make fields final?<br>3. <b>Thread-Safe Tools:</b> Can I use <code>AtomicInteger</code> or <code>ConcurrentHashMap</code>?<br>4. <b>Locking:</b> If all else fails, use <code>synchronized</code>.</li><li><b>Q2: Are Spring Boot Controllers/Services Thread-Safe?</b><br><b>Answer:</b> By default, Spring beans are <b>Singletons</b> (shared by all threads). Therefore, they <b>MUST be Stateless</b>. If you put a mutable instance variable (like <code>private int count</code>) inside a Controller, it is a critical bug.</li><li><b>Q3: Is <code>SimpleDateFormat</code> thread-safe?</b><br><b>Answer:</b> <b>No.</b> It stores intermediate parsing results in instance variables. Use <code>java.time.DateTimeFormatter</code> (Immutable) instead.</li><li><b>Q4: What is <code>ThreadLocal</code>?</b><br><b>Answer:</b> It gives every thread its own private \"pocket\" for data (e.g., storing a User ID for the duration of a request), ensuring isolation without passing parameters everywhere.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/threadsafety.jpg"
        ],
        "caption": ""
      }
  ]
},


  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Museum Display Analogy:</b></li><li><b>Mutable Object:</b> You leave a precious manuscript on a table. Anyone can scribble on it. To protect it, you need a guard (Lock/Synchronization).</li><li><b>Immutable Object:</b> You put the manuscript inside a <b>bulletproof glass case</b>. 1,000 people can look at it (Read) simultaneously, but no one can touch it.</li><li><b>Result:</b> You don't need a guard. It is inherently safe because it is <b>Read-Only</b>.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Technical Definitions:</b></p><ul><li><b>Immutable Object:</b> An object whose state (data) cannot be modified after it is created.</li><li><b>The Golden Rule:</b> \"If you can't change it, you can't break it.\"</li><li><b>Key Characteristics:</b><ul><li>No \"Setters\" (e.g., <code>setName()</code>).</li><li>All fields are <code>private</code> and <code>final</code>.</li><li>The class is <code>final</code> (preventing subclasses from altering behavior).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Strategy (Create vs. Modify):</b></p><ul><li>If you need to \"change\" data in an immutable object, you <b>do NOT modify</b> the existing object. Instead, you <b>create a New Copy</b> with the updated value.</li><li><i>Example:</i> <code>String</code> in Java. <code>s.toUpperCase()</code> does not change <code>s</code>; it returns a completely new String object.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n\n// 1. Make class final (No subclasses allowed)\npublic final class ImmutableUser {\n    \n    // 2. Make fields private and final (Must be set in constructor)\n    private final String name;\n    private final int age;\n    private final List<String> roles;\n\n    public ImmutableUser(String name, int age, List<String> roles) {\n        this.name = name;\n        this.age = age;\n        \n        // 3. DEEP COPY (Crucial Step!)\n        // If we just said \"this.roles = roles\", the caller could modify the \n        // original list later and break our immutability.\n        this.roles = new ArrayList<>(roles);\n    }\n\n    // 4. Getters Only (No Setters)\n    public String getName() { return name; }\n    public int getAge() { return age; }\n\n    public List<String> getRoles() {\n        // Return a copy or unmodifiable view so they can't touch our internal list\n        return new ArrayList<>(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Questions & \"Gotchas\":</b></p><ul><li><b>Q1: Why is String immutable in Java?</b><br><b>Answer:</b><ul><li><b>Security:</b> Strings are used for Database URLs and passwords. If mutable, a hacker could change a filename after the security check but before file access.</li><li><b>Thread-Safety:</b> Safe to share across threads without locks.</li><li><b>String Pool:</b> Caching identical strings to save memory is only possible if they never change.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q2: What is the difference between <code>final</code> and Immutable?</b><br><b>Answer:</b><ul><li><b>final:</b> Refers to the <b>Reference</b> (\"I cannot point this variable to a new object\").</li><li><b>Immutable:</b> Refers to the <b>Object Content</b> (\"The data inside this object cannot change\").</li><li><i>Trap:</i> <code>final List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> -> You cannot say <code>list = new List()</code>, BUT you CAN say <code>list.add(\"Hack\")</code>. The list is final but Mutable.</li></ul></li><li><b>Q3: How do you handle a Date or List field inside an Immutable class?</b><br><b>Answer:</b> You must use <b>Defensive Copies</b> (Deep Copy). Copy the incoming list in the Constructor, and return a copy in the Getter.</li></ul>"
    },
    {
      "type": "text",
      "content": "<ul><li><b>Q4: What are the downsides of Immutability?</b><br><b>Answer:</b> <b>Memory Overhead.</b> Creating a new object for every small change generates \"garbage\" (e.g., String concatenation in a loop). <b>Fix:</b> Use <code>StringBuilder</code> (Mutable) for heavy editing, then convert to <code>String</code>.</li></ul>"
    }
  ]
},

  "Checked vs Unchecked": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Distinction:</b></p><ul><li><b>Checked Exceptions (<code>Exception</code>):</b><ul><li><b>Nature:</b> Anticipated, recoverable events external to the program (e.g., File missing, Network down).</li><li><b>Compiler Rule:</b> <b>Mandatory Handling.</b> You must <code>try-catch</code> or <code>throws</code>.</li><li><b>Intent:</b> \"Don't ignore this; have a Plan B.\"</li></ul></li><li><b>Unchecked Exceptions (<code>RuntimeException</code>):</b><ul><li><b>Nature:</b> Logic errors (Bugs) or Unrecoverable system faults (e.g., NullPointer, Database Dead).</li><li><b>Compiler Rule:</b> <b>Optional Handling.</b> Compiler stays silent.</li><li><b>Intent:</b> \"Fix the code\" or \"Fail fast.\"</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Decision Matrix (How to choose):</b></p><table><thead><tr><th>Scenario</th><th>Type to Throw</th><th>Rationale</th></tr></thead><tbody><tr><td><b>Caller can recover</b> (Retry, Alternate Path)</td><td>Checked</td><td>Forces the dev to write recovery logic.</td></tr><tr><td><b>Programming Error</b> (Null arg, Bad cast)</td><td>Unchecked</td><td>No recovery possible; the code is broken.</td></tr><tr><td><b>System Failure</b> (DB dead, Config missing)</td><td>Unchecked</td><td>Caller can't fix a dead DB. Let it crash to the top.</td></tr><tr><td><b>Modern API (Spring)</b></td><td>Unchecked</td><td>Reduces boilerplate; handled by Global Exception Handler.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>The \"Wrap and Rethrow\" Pattern (Critical for LLD):</b></p><ul><li><b>Problem:</b> Checked exceptions (e.g., <code>SQLException</code>) leak implementation details to higher layers. The Service layer shouldn't know you are using SQL.</li><li><b>Solution:</b> Catch the Checked exception at the boundary, wrap it in a custom Unchecked exception, and throw.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// BAD (Leaky Abstraction - Service knows about SQL)\npublic User get(String id) throws SQLException { ... } \n\n// GOOD (Clean Abstraction - Service only knows Data Access failed)\npublic User get(String id) {\n    try {\n        // ... SQL logic ...\n    } catch (SQLException e) {\n        // Wrap & Rethrow. Preserves stack trace (e).\n        throw new DataAccessException(\"Failed to fetch user\", e);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Industry Trend:</b> Modern Java (Spring/Lombok) heavily prefers <b>Unchecked Exceptions</b>. Legacy Java used Checked exceptions too much, resulting in empty catch blocks. Ideally, use a Centralized Error Handler (<code>@ControllerAdvice</code>).</li><li><b>Layer Isolation:</b> Never let a Checked Exception from a low-level library (JDBC, File I/O) propagate to the Service layer. Wrap it.</li><li><b>The Spring Transaction Trap:</b> In Spring, <code>@Transactional</code> <b>only rolls back on Unchecked exceptions</b> by default. It commits if a Checked exception is thrown, unless you specify <code>rollbackFor = Exception.class</code>.</li></ul>"
    }
  ]
},

  "Custom Exceptions": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Semantic Clarity:</b> Replaces vague errors (<code>RuntimeException</code>) with specific business language (<code>UserNotFoundException</code>).</li><li><b>Granular Handling:</b> Allows the caller to catch specific scenarios (Catch <code>InvalidPassword</code>) while letting others bubble up.</li><li><b>Context Passing:</b> Custom exceptions can carry metadata (e.g., <code>failedAmount</code>, <code>userId</code>) to help with debugging or user feedback.</li></ul><br><p><b>The Design Pattern: Domain Hierarchy</b></p>Don't just create random exceptions. Structure them like your architecture.<br><ul><li><b>Root Layer:</b> <code>BaseAppException</code> (Extends RuntimeException).</li><li><b>Module Layer:</b> <code>BillingException</code>, <code>AuthException</code> (Extends BaseAppException).</li><li><b>Leaf Layer:</b> <code>InsufficientFundsException</code>, <code>TokenExpiredException</code> (Extends Module Exception).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The \"Smart\" Exception: Holds Logic & Data\n\n// 1. Base Class (Unchecked)\npublic abstract class PaymentException extends RuntimeException {\n    public PaymentException(String message) { super(message); }\n}\n\n// 2. Concrete Class with Context\npublic class InsufficientFundsException extends PaymentException {\n    \n    // DATA fields (Crucial for debugging/UI)\n    private final double currentBalance;\n    private final double attemptedAmount;\n\n    public InsufficientFundsException(double currentBalance, double attemptedAmount) {\n        super(\"Transaction declined: Balance \" + currentBalance + \" < \" + attemptedAmount);\n        this.currentBalance = currentBalance;\n        this.attemptedAmount = attemptedAmount;\n    }\n    \n    // Getters allowed...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Usage Benefits (Comparison):</b></p><table><thead><tr><th>Feature</th><th>Generic (Exception)</th><th>Custom (UserNotFound)</th></tr></thead><tbody><tr><td><b>Readability</b></td><td>Low (throw new RuntimeException(\"user missing\"))</td><td>High (throw new UserNotFound(id))</td></tr><tr><td><b>Catching</b></td><td>Catches everything (bugs & logic)</td><td>Catches only specific logic</td></tr><tr><td><b>API Response</b></td><td>Hard to map to 404/400</td><td>Easy 1:1 mapping</td></tr></tbody></table><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Don't Over-Engineer:</b> Rule of Thumb: Create a new class <i>only</i> if you intend to handle it differently (e.g., return a different HTTP status or trigger a specific retry logic).</li><li><b>Mapping to HTTP (API Layer):</b> Custom exceptions are the bridge between Logic and API.<ul><li><code>ResourceNotFoundException</code> $\\rightarrow$ 404 Not Found</li><li><code>BusinessRuleViolationException</code> $\\rightarrow$ 422 Unprocessable Entity</li><li><code>SystemFailureException</code> $\\rightarrow$ 500 Internal Server Error</li></ul></li><li><b>Security:</b> Never put sensitive data (passwords, PII) inside the exception message/fields, as these often get logged in plain text.</li></ul>"
    }
  ]
},

  "Propagation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Three Strategies:</b></p>When an exception occurs, you have three choices. Your choice defines the resilience and cleanliness of your architecture.<br><ul><li><b>1. Handle (Catch & Recover):</b><ul><li><b>Action:</b> Catch the error and implement a \"Plan B.\"</li><li><b>Use When:</b> You can fix the issue locally without bothering the user. (e.g., Cache fails $\\rightarrow$ Fetch from DB).</li></ul></li><li><b>2. Bubble Up (Propagate):</b><ul><li><b>Action:</b> Do nothing (or declare <code>throws</code>). Let the exception fly up the stack.</li><li><b>Use When:</b> Your method is a utility (e.g., File Reader) and has no context on how to solve business problems.</li></ul></li><li><b>3. Wrap & Rethrow (Translate) [Crucial for LLD]:</b><ul><li><b>Action:</b> Catch a low-level exception, wrap it in a high-level Domain exception, and throw the new one.</li><li><b>Use When:</b> Crossing architectural boundaries (e.g., Data Layer $\\rightarrow$ Service Layer).</li><li><b>Goal:</b> Prevent <b>Leaky Abstractions</b>.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Code Example: Wrap & Rethrow\n// This is the standard pattern for maintaining clean layers.\n\n// Layer: Repository (Low Level)\npublic void save(User user) {\n    try {\n        database.execute(sql);\n    } catch (SQLException e) {\n        // STOP! Do not let SQL details leak out.\n        // Wrap 'e' to keep the stack trace (Root Cause).\n        throw new UserStorageException(\"Save failed\", e);\n    }\n}\n\n// Layer: Service (High Level)\n// Service code stays clean. It doesn't know we use SQL.\npublic void register(User user) {\n    try {\n        repo.save(user);\n    } catch (UserStorageException e) { // catching the Domain Error\n        // Handle business logic failure\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Anti-Pattern: \"Log and Throw\":</b></p><ul><li><b>Avoid this:</b> <code>catch (e) { logger.error(e); throw e; }</code></li><li>It creates duplicate logs (once here, once at the global handler). <b>Rule:</b> Either log it and handle it (swallow), OR throw it. Never do both.</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Preserve Abstraction:</b> The Service Layer should never catch <code>SQLException</code> or <code>IOException</code>. It should only catch domain errors (<code>StorageException</code>). If you see low-level errors in high-level code, it's a \"Leaky Abstraction.\"</li><li><b>Swallowing Exceptions:</b> Never write an empty catch block (<code>catch (e) {}</code>). It buries the error. At minimum, log it.</li><li><b>Root Cause Analysis:</b> When Wrapping & Rethrowing, always pass the original exception into the constructor (<code>new MyEx(msg, originalEx)</code>). If you forget this, you lose the stack trace and won't know <i>why</i> the error happened.</li></ul>"
    }
  ]
},


  "Optional vs Null": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Problem: The \"Billion Dollar Mistake\"</b></p><ul><li><b>Ambiguity:</b> <code>null</code> is silent. It can mean \"Not Found,\" \"Not Initialized,\" or \"Error.\"</li><li><b>Risk:</b> Developers forget to check <code>if (x != null)</code>, leading to <b>NullPointerException (NPE)</b> which crashes the application at runtime.</li></ul><br><p><b>The Solution: Optional&lt;T&gt;</b></p><ul><li><b>Concept:</b> A container object (a \"box\") that may or may not contain a non-null value.</li><li><b>Intent:</b> It forces the client code to explicitly handle the \"case where the value is missing.\" You cannot access the value without \"opening the box.\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Patterns (The LLD Toolkit)</b></p>Instead of <code>if-else</code> blocks, use functional pipelines.<br><table><thead><tr><th>Method</th><th>Purpose</th><th>Scenario</th></tr></thead><tbody><tr><td><code>orElseThrow()</code></td><td>Get value or crash.</td><td>Validation: \"User must exist, or else 404.\"</td></tr><tr><td><code>ifPresent()</code></td><td>Do something if exists.</td><td>Side Effects: \"If email exists, send logic.\"</td></tr><tr><td><code>map()</code></td><td>Transform if exists.</td><td>DTOs: \"Convert User entity to DTO only if found.\"</td></tr><tr><td><code>orElse()</code></td><td>Default value.</td><td>Config: \"Use default timeout if config missing.\"</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Old Way (Null Checks - Error Prone)\nUser user = repo.find(\"karan\");\nif (user != null) {\n    Address addr = user.getAddress();\n    if (addr != null) {\n        return addr.getCity();\n    }\n}\nreturn \"Unknown\"; // Easy to miss a return path\n\n// The LLD Way (Optional Pipeline - Safe)\nreturn repo.find(\"karan\") // returns Optional<User>\n    .map(User::getAddress)\n    .map(Address::getCity)\n    .orElse(\"Unknown\");"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Return Type Only:</b> Strict rule for LLDâ€”Use <code>Optional</code> <b>only as a return type</b>. It signals to the caller \"This might be empty.\"</li><li><b>Don't use as Parameters:</b> Do not write <code>method(Optional&lt;String&gt; s)</code>. It makes the API clumsy. Overload the method instead.</li><li><b>Don't use as Fields:</b> Do not declare <code>private Optional&lt;String&gt; name</code> in a class.<ul><li><b>Reason 1:</b> It is not Serializable (breaks Redis/Caching).</li><li><b>Reason 2:</b> Memory overhead (creates a wrapper object for every field). Use <code>null</code> for fields, wrap in <code>Optional</code> in the getter.</li></ul></li></ul>"
    }
  ]
},

  "DTO vs Domain": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Separation of Worlds:</b></p><ul><li><b>Domain Model (Internal Representation):</b><ul><li><b>Context:</b> Database & Business Logic.</li><li><b>Nature:</b> \"Heavy.\" Contains annotations (<code>@Entity</code>), relationships (<code>@OneToMany</code>), and business methods.</li><li><b>Goal:</b> Maintain data integrity and business rules.</li></ul></li><li><b>DTO (Data Transfer Object) (External Contract):</b><ul><li><b>Context:</b> API & Client Communication.</li><li><b>Nature:</b> \"Light.\" Plain Java Objects (POJOs) with only fields and getters/setters. No logic.</li><li><b>Goal:</b> Efficient data transport and strict API contracts.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Why Separate Them? (Decoupling)</b></p><table><thead><tr><th>Factor</th><th>Use Domain Directly (Bad)</th><th>Use DTO (Good)</th></tr></thead><tbody><tr><td><b>Coupling</b></td><td>API breaks if DB Column name changes.</td><td>API is stable; only the Mapper changes.</td></tr><tr><td><b>Security</b></td><td>Accidental leak of password, salt, id.</td><td>Explicitly whitelist fields to expose.</td></tr><tr><td><b>Performance</b></td><td>Serializing Entity triggers <b>Lazy Loading</b> (N+1 queries).</td><td>DTO contains only fetched data.</td></tr><tr><td><b>Versioning</b></td><td>Hard to support v1 and v2 simultaneously.</td><td>Different DTOs for v1 (<code>UserV1DTO</code>) and v2.</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Entity (Internal - DB Linked)\n@Entity\npublic class User {\n    @Id private Long id;\n    private String email;\n    private String passwordHash; // Sensitive! Leaking this is a disaster.\n    private boolean isDeleted;   // Internal flag!\n}\n\n// The DTO (External - API Safe)\npublic class UserResponseDTO {\n    public String email;\n    public String status; // Calculated (\"Active\" vs \"Deleted\")\n    // Password is physically missing here. Safe.\n}\n\n// The Mapper (The Bridge)\npublic UserResponseDTO toDTO(User user) {\n    UserResponseDTO dto = new UserResponseDTO();\n    dto.email = user.getEmail();\n    dto.status = user.isDeleted() ? \"Inactive\" : \"Active\";\n    return dto;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Serialization Hazards:</b> Never return an <code>@Entity</code> directly in a Controller. JSON serializers (like Jackson) will try to access lazy-loaded fields (e.g., <code>user.getOrders()</code>), causing <b>Infinite Recursion</b> or <b>N+1 Database Queries</b>.</li><li><b>Boilerplate Reduction:</b> In interviews, mention using libraries like <b>MapStruct</b> or <b>ModelMapper</b>. It shows you know production standards for automating the mapping code.</li><li><b>Multiple Views:</b> You can have multiple DTOs for the same Entity to optimize payload size:<ul><li><code>UserSummaryDTO</code> (List View: ID + Name)</li><li><code>UserDetailDTO</code> (Profile View: ID + Name + Address + History)</li></ul></li></ul>"
    }
  ]
},

  "Validation Layer": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Two-Phase Validation Strategy:</b></p>To keep code clean and secure, validation is split into two distinct stages.<br><ul><li><b>Phase 1: Syntactic Validation (Format)</b><ul><li><b>Where:</b> DTO / Controller Layer.</li><li><b>What:</b> \"Does the data look right?\" (e.g., Is email format valid?)</li><li><b>Mechanism:</b> Annotations (<code>@NotNull</code>, <code>@Email</code>).</li><li><b>Goal:</b> <b>Fail Fast.</b> Don't bother the database if the format is garbage.</li></ul></li><li><b>Phase 2: Semantic Validation (Logic)</b><ul><li><b>Where:</b> Service / Domain Layer.</li><li><b>What:</b> \"Is the data valid in our system?\" (e.g., Is email unique?)</li><li><b>Mechanism:</b> Database queries / Business Rule checks.</li><li><b>Goal:</b> Ensure data integrity.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Security: Input Sanitization</b></p>Before validation starts, sanitize input to prevent attacks.<br><ul><li><b>XSS (Cross-Site Scripting):</b> Strip HTML tags from text inputs (<code>&lt;script&gt;</code>).</li><li><b>SQL Injection:</b> Use Prepared Statements (standard in JPA/Hibernate).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Phase 1: Syntactic (DTO Annotations)\npublic class SignupDTO {\n    @NotNull(message = \"Name required\")\n    private String name;\n\n    @Email(message = \"Bad email format\")\n    private String email; // Checks format only (foo@bar.com)\n}\n\n// Phase 2: Semantic (Service Logic)\npublic void register(SignupDTO dto) {\n    // 1. Semantic Check: Uniqueness\n    if (repo.existsByEmail(dto.getEmail())) {\n        throw new UserAlreadyExistsException(\"Email taken\");\n    }\n\n    // 2. Semantic Check: Business Rule\n    if (dto.getAge() < 18 && dto.getCountry().equals(\"US\")) {\n        throw new BusinessRuleException(\"Must be 18+ in US\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Separation of Concerns:</b> Never put DB checks (Semantic) inside the DTO or Controller. It couples your API layer to your Data layer.</li><li><b>Fail Fast Principle:</b> Always perform Syntactic validation before Semantic. Syntactic is cheap (CPU only); Semantic is expensive (I/O, DB calls).</li><li><b>The \"Validator Class\" Pattern:</b> If business rules are complex (e.g., Loan Approval with 20 checks), move the logic out of the Service and into a dedicated <code>LoanValidator</code> class to keep the Service readable.</li></ul>"
    }
  ]
},

  "Anti-Corruption Layer": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Concept:</b></p><ul><li><b>The Problem:</b> You are building a modern system (Clean Architecture) but need to integrate with a <b>Legacy System</b> (Spaghetti Code, Mainframe, XML) or a poorly designed 3rd Party API.</li><li><b>The Risk:</b> If you use the Legacy System's classes/models directly in your new code, the \"rot\" spreads. Your clean service layer becomes polluted with confusing names and structures.</li><li><b>The Solution:</b> Build a defensive wall (The <b>ACL</b>). It translates the \"Messy External Model\" into your \"Clean Internal Model.\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Components of an ACL:</b></p><ul><li><b>The Adapter (Facade):</b> The interface exposed to your new system. It speaks <i>your</i> language.</li><li><b>The Translator:</b> A private utility that maps <code>Legacy Object</code> $\\leftrightarrow$ <code>Modern Object</code>.</li><li><b>The Client:</b> The low-level network code that actually talks to the legacy system (SOAP, REST, etc.).</li></ul><br><p><b>Code Structure:</b></p>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The \"Clean\" Interface (What your Service uses)\n// Notice: It uses your clean domain language (sku, boolean)\npublic interface InventoryService {\n    boolean isProductInStock(String sku);\n}\n\n// 2. The ACL Implementation (The Translation Logic)\n// Notice: It encapsulates the mess (XML_ITEM_01, \"Y\"/\"N\" flags)\n@Service\npublic class LegacyInventoryACL implements InventoryService {\n    \n    @Autowired private LegacySoapClient client;\n\n    @Override\n    public boolean isProductInStock(String sku) {\n        // A. Translate Request (Clean -> Messy)\n        String legacyId = \"ID_\" + sku; \n        \n        // B. Call Legacy System\n        LegacyResponse response = client.fetchXML_ITEM_01(legacyId);\n        \n        // C. Translate Response (Messy -> Clean)\n        // Legacy system uses \"Y\"/\"N\", we want boolean\n        return \"Y\".equals(response.getVal_stk_flag());\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Decoupling is King:</b> The primary goal is that your core domain logic never imports a class from the legacy system. It only talks to the ACL interface.</li><li><b>Strangler Fig Pattern:</b> ACL is the enabler for the \"Strangler Fig\" migration strategy. You wrap the old system in an ACL. Over time, you replace the backend of the ACL with a new microservice, while the interface remains the same.</li><li><b>Cost vs. Benefit:</b> Don't use ACL for everything. If the external system is modern and clean (e.g., Stripe API), just use their SDK. ACL is specifically for isolating mess.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},


  "Idempotency": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>Math:</b> $f(f(x)) = f(x)$</li><li><b>Engineering:</b> Performing an operation multiple times produces the same result as performing it exactly once.</li><li><b>Goal:</b> Resilience against network failures (Timeouts) and automatic Retries.</li></ul><br><p><b>The Problem: \"The Double Charge\"</b></p><ul><li><b>Scenario:</b> User clicks \"Pay $100\". Server charges card. The <b>Network Fails</b> before the response returns.</li><li><b>The Retry:</b> Client thinks the request failed and sends it again.</li><li><b>Result:</b> Server charges the card again. User is angry.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>HTTP Methods Behavior:</b></p><table><thead><tr><th>Method</th><th>Idempotent?</th><th>Why?</th></tr></thead><tbody><tr><td><b>GET</b></td><td>Yes</td><td>Read-only. Reading 10 times changes nothing.</td></tr><tr><td><b>PUT</b></td><td>Yes</td><td>\"Set X=5\". Doing it 10 times results in X=5.</td></tr><tr><td><b>DELETE</b></td><td>Yes</td><td>\"Delete ID 5\". Doing it 10 times results in ID 5 gone.</td></tr><tr><td><b>POST</b></td><td><b>NO</b></td><td>\"Create Order\". Doing it 10 times creates 10 orders. Requires Idempotency Keys.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution: Idempotency Keys</b></p><ul><li><b>The Mechanism:</b> The server must recognize \"I have seen this request before.\"</li><li><b>Client:</b> Generates a unique ID (UUID) for the intent (e.g., <code>req_123</code>).</li><li><b>Server Logic:</b><ul><li><b>If Key Exists:</b> Return the saved response (Do not process again).</li><li><b>If Key New:</b> Process request $\\rightarrow$ Save Key + Response $\\rightarrow$ Return Result.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public Response processPayment(String key, Data data) {\n    // 1. Check Cache/DB\n    if (store.contains(key)) {\n        return store.get(key); // Return cached success\n    }\n\n    // 2. Lock (Critical for Concurrency)\n    // Prevent two threads processing the same key at the exact same ms\n    if (!lock.acquire(key)) {\n        throw new ConflictException(\"Processing\");\n    }\n\n    // 3. Process & Save\n    Result result = paymentService.charge(data);\n    store.save(key, result);\n    \n    return result;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>The \"Post\" Exception:</b> In REST, POST is the only method that is <b>not</b> idempotent by default. You must manually implement it for critical endpoints (Payments).</li><li><b>Concurrency Race Condition:</b> If a user clicks \"Submit\" twice instantly, two requests might hit the server before the first one is saved. You need a <b>Distributed Lock</b> (e.g., Redis Lock) on the Idempotency Key to prevent parallel processing.</li><li><b>Response Caching:</b> You don't just save \"Processed: True\". You must save the <b>actual JSON response</b>. When the retry comes, you return the exact same JSON body so the client doesn't crash parsing a different format.</li></ul>"
    }
  ]
},


  "Config-Driven Design": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Philosophy:</b></p><ul><li><b>Definition:</b> Writing code that adapts its behavior based on external configuration, rather than hardcoded logic.</li><li><b>The Goal:</b> Change Business Logic without changing Source Code.</li><li><b>The Benefit:</b> Reduces \"Time to Market.\" A Product Manager can toggle a feature or change a tax rate in seconds, without waiting for a developer to commit, build, test, and deploy.</li></ul><br><p><b>The Evolution of Config:</b></p><table><thead><tr><th>Level</th><th>Strategy</th><th>Pros/Cons</th></tr></thead><tbody><tr><td><b>Level 0</b></td><td>Hardcoded (<code>if (country == \"US\")</code>)</td><td><b>Bad.</b> Requires full code redeploy to change.</td></tr><tr><td><b>Level 1</b></td><td>Property Files (<code>application.yaml</code>)</td><td><b>Better.</b> Requires a service restart to apply changes.</td></tr><tr><td><b>Level 2</b></td><td>Dynamic Config (DB / Consul)</td><td><b>Best.</b> Changes apply in <b>Real-Time (Hot Reload)</b> without restart.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": "<p><b>Feature Toggles (Flags):</b></p>Decouple <b>Deployment</b> (moving code to server) from <b>Release</b> (showing code to users).<br><ul><li><b>Boolean Flags:</b> Turn features on/off. <code>if (featureFlags.isOn(\"dark_mode\"))</code>.</li><li><b>Kill Switch:</b> If a new feature causes bugs, turn it off instantly via config. No rollback needed.</li><li><b>Canary / Percentage Rollouts:</b> \"Enable New Checkout for 5% of users.\" Monitor logs. If safe, increase to 100%.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Environment Separation:</b></p>The \"Build Once, Deploy Anywhere\" Rule.<br><ul><li><b>Artifact:</b> The code (JAR/Docker Image) must be <b>identical</b> across Dev, Stage, and Prod.</li><li><b>Variable:</b> Only the Config changes.<br><i>Dev:</i> <code>DB_URL=localhost</code>, <code>LOG_LEVEL=DEBUG</code><br><i>Prod:</i> <code>DB_URL=rds-endpoint</code>, <code>LOG_LEVEL=INFO</code></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Bad Way (Hardcoded)\npublic double calculateTax(String country) {\n    if (\"US\".equals(country)) return 0.10; // Hardcoded!\n    if (\"IN\".equals(country)) return 0.18; // Redeploy needed to change\n    return 0;\n}\n\n// The LLD Way (Config-Driven)\n@Service\npublic class TaxService {\n    // Injected from DB or Config Server (Hot Reloadable)\n    private Map<String, Double> taxRates; \n\n    public double calculateTax(String country) {\n        // 1. Logic is generic\n        // 2. Behavior is defined by data\n        return taxRates.getOrDefault(country, 0.0);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Hot Reloading:</b> In High-Level Design (HLD), we use tools like <b>Spring Cloud Config</b> or <b>Consul</b> to push changes to running services. The service listens for the change event and refreshes its beans without downtime.</li><li><b>A/B Testing:</b> Config-Driven Design is the foundation of A/B testing. You feed Config A to User Group 1 and Config B to User Group 2 to measure which one performs better.</li><li><b>Complexity Warning:</b> Don't overdo it. Too many feature flags make the code a nightmare to test (20 flags = $2^{20}$ possible combinations). Clean up old flags once the feature is permanently 100% live.</li></ul>"
    }
  ]
},


  "Feature Toggles": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Concept:</b></p><ul><li><b>Definition:</b> A mechanism that allows you to modify system behavior without changing code.</li><li><b>The Mantra:</b> \"Deploy $\\neq$ Release.\"<ul><li><b>Deploy:</b> Installing code onto the server (Technical act).</li><li><b>Release:</b> Making the feature visible to users (Business act).</li></ul></li><li><b>Goal:</b> <b>Continuous Deployment.</b> You can push half-finished code to Production, kept hidden behind a \"False\" flag.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Common Types of Toggles:</b></p><table><thead><tr><th>Type</th><th>Purpose</th><th>Duration</th></tr></thead><tbody><tr><td><b>Release Toggle</b></td><td>Hide incomplete work. Allow trunk-based development.</td><td>Short-lived (Days/Weeks)</td></tr><tr><td><b>Ops Toggle (Kill Switch)</b></td><td>Safety valve. If a new endpoint spikes latency, turn it off.</td><td>Medium-lived</td></tr><tr><td><b>Experiment Toggle</b></td><td>A/B Testing. \"Show blue button to 50% users.\"</td><td>Short/Medium</td></tr><tr><td><b>Permission Toggle</b></td><td>Premium features. \"Only Gold users see this.\"</td><td>Long-lived (Years)</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Basic Strategy (If/Else Clutter)\n// Risk: Code becomes hard to read with nested if statements.\nif (featureFlags.isOn(\"new-search-algo\")) {\n    return newSearchService.search(query);\n} else {\n    return legacySearchService.search(query);\n}\n\n// 2. Advanced Strategy (Strategy Pattern - LLD Approved)\n// Solution: Inject the decision logic, keeping the core code clean.\n// The Factory decides which implementation to inject based on the Flag.\nSearchService service = featureManager.isOn(\"new-algo\") \n                      ? new NewSearchService() \n                      : new LegacySearchService();\nservice.search(query);"
    },
    {
      "type": "text",
      "content": "<br><p><b>Toggle Lifecycle (The \"Debt\" Trap):</b></p>Feature flags are <b>Technical Debt</b>. If you don't remove them after the feature is stable, your code becomes a graveyard of dead paths.<br><ol><li><b>Create:</b> Add flag <code>use_new_checkout</code>.</li><li><b>Deploy:</b> Code goes to Prod (Flag = False).</li><li><b>Enable:</b> Turn Flag = True (Gradual rollout).</li><li><b>Stabilize:</b> Ensure no bugs.</li><li><b>Cleanup:</b> <b>CRITICAL.</b> Delete the if/else block and the flag.</li></ol>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Performance (Caching):</b> Do not query the Database for a flag on every single request. <b>Solution:</b> Cache flags in memory (short TTL) or use a dedicated system (LaunchDarkly) that pushes updates to SDKs.</li><li><b>Testing Nightmare:</b> Every flag doubles your test cases ($2^n$). <b>Strategy:</b> Test only two states: \"All Flags On\" (Future) and \"All Flags Off\" (Current Prod).</li><li><b>Context-Awareness:</b> Smart toggles take context: <code>isEnabled(\"dark_mode\", userId=123)</code>. This allows specific user targeting (Canary Releases).</li></ul>"
    }
  ]
},


  "Env Separation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Golden Rule: \"Build Once, Deploy Anywhere\"</b></p><ul><li><b>Philosophy:</b> Your application binary (JAR, Docker Image) must be <b>immutable</b>.</li><li><b>The Artifact:</b> You build the artifact <i>once</i> in the CI pipeline. You do not rebuild it for Production.</li><li><b>The Variable:</b> The only thing that changes between environments is the <b>Configuration</b> (injected at runtime).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Hierarchy of Environments:</b></p><table><thead><tr><th>Env</th><th>Purpose</th><th>Config Characteristics</th></tr></thead><tbody><tr><td><b>Local/Dev</b></td><td>Coding & Unit Testing</td><td>DB=localhost, Logs=DEBUG, Auth=Mock</td></tr><tr><td><b>QA/Stage</b></td><td>Integration Testing (Mirror of Prod)</td><td>DB=TestRDS, Logs=INFO, Auth=Real</td></tr><tr><td><b>Prod</b></td><td>Real User Traffic</td><td>DB=ProdRDS, Logs=WARN, Auth=Real</td></tr></tbody></table><br><p><b>What Separates? (The Config)</b></p>Never hardcode these. They must be injected via Environment Variables or External Config Stores.<br><ul><li><b>Resources:</b> Database URLs, Redis endpoints, Queue topics.</li><li><b>Credentials:</b> API Keys, Passwords (use Secrets Manager, never plain text).</li><li><b>Behavior:</b> Log levels, Thread pool sizes, Feature flags.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>12-Factor App Methodology (Factor III):</b></p><ul><li><b>Rule:</b> Store config in the environment, not in the code.</li><li><b>Violation:</b> Committing <code>config-prod.properties</code> inside the Git repo.</li><li><b>Correct:</b> Application reads <code>System.getenv(\"DB_URL\")</code> at startup.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad (Hardcoded / Profile Hell)\n// If you have to rebuild the JAR to change this, you failed.\nString dbUrl = \"jdbc:mysql://prod-db:3306/users\"; \n\n// Good (Injected)\n// Spring Boot automatically maps env vars (APP_DB_URL) to this field\n@Value(\"${app.db.url}\")\nprivate String dbUrl; "
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Secrets Management:</b> Never commit passwords to Git. Use tools like <b>HashiCorp Vault</b> or <b>AWS Secrets Manager</b>. The app fetches the secret at runtime using an IAM role.</li><li><b>Parity:</b> Keep Dev and Prod as similar as possible. <b>Anti-Pattern:</b> Using H2 (In-Memory) for Dev and Oracle for Prod (leads to SQL dialect bugs). <b>Fix:</b> Use Docker to run the real DB locally.</li><li><b>Startup Validation:</b> Fail fast. If <code>DB_URL</code> is null, crash the app immediately on startup. Don't wait for the first user request to fail.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Class Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> The blueprint of your system. It represents the <b>Static Structure</b>â€”classes, data types, and the relationships between them.</li><li><b>Usage:</b> It maps directly to code (OOP). If you can draw it, you can code it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Anatomy of a Class Box:</b></p>A standard class is represented by a rectangle divided into three parts:<ol><li><b>Top:</b> Class Name.</li><li><b>Middle:</b> Attributes / Fields (<code>name: type</code>).</li><li><b>Bottom:</b> Methods / Functions (<code>methodName(param): returnType</code>).</li></ol>"
    },
    {
      "type": "text",
      "content": "<p><b>Types of Classifiers:</b></p><ul><li><b>Concrete Class:</b> Standard rectangle. Objects you can instantiate (<code>new User()</code>).</li><li><b>Abstract Class:</b> Name in <i>Italics</i> OR labeled <code>&lt;&lt;abstract&gt;&gt;</code>. Cannot be instantiated.</li><li><b>Interface:</b> Labeled <code>&lt;&lt;interface&gt;&gt;</code>. A contract defining \"what\" behaviors are required.</li><li><b>Enum (Enumeration):</b> Labeled <code>&lt;&lt;enumeration&gt;&gt;</code>. Lists constant values (Status, Role).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Member Notation (Visibility & Modifiers):</b></p><ul><li><b>Visibility:</b><ul><li><code>+</code> Public</li><li><code>-</code> Private</li><li><code>#</code> Protected</li><li><code>~</code> Package/Default</li></ul></li><li><b>Advanced Modifiers:</b><ul><li><b>Static Members:</b> <u>Underlined</u>. Shared by all instances.</li><li><b>Abstract Methods:</b> <i>Italicized</i>. Must be implemented by child.</li><li><b>Derived Attributes:</b> <code>/</code> prefix. Calculated on the fly (e.g., <code>/age</code> derived from <code>birthDate</code>).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Relationships (The Core of LLD):</b></p><table><thead><tr><th>Relationship</th><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td><b>Inheritance</b></td><td>Solid line + Hollow Triangle</td><td>\"Is-A\". Parent-Child. (<code>extends</code>)</td></tr><tr><td><b>Realization</b></td><td>Dashed line + Hollow Triangle</td><td>\"Can-Do\". Implements Interface. (<code>implements</code>)</td></tr><tr><td><b>Association</b></td><td>Solid Line</td><td>\"Uses\". Basic connection.</td></tr><tr><td><b>Aggregation</b></td><td>Solid Line + <b>Empty</b> Diamond</td><td>\"Has-A\" (Weak). Child survives Parent's death. (Team-Players).</td></tr><tr><td><b>Composition</b></td><td>Solid Line + <b>Filled</b> Diamond</td><td>\"Part-Of\" (Strong). Child dies with Parent. (House-Room).</td></tr><tr><td><b>Dependency</b></td><td>Dashed Line + Open Arrow</td><td>\"Temporarily Uses\". Changes in target affect source.</td></tr></tbody></table>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/umlsign.png"
        ],
        "caption": ""
      },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Composition vs. Aggregation:</b> Ask \"If I delete the Parent, does the Child survive?\" <br>Yes $\\rightarrow$ Aggregation (Empty Diamond). <br>No $\\rightarrow$ Composition (Filled Diamond).</li><li><b>Enums as First-Class Citizens:</b> Always draw a specific <code>&lt;&lt;enumeration&gt;&gt;</code> box for statuses (e.g., <code>OrderStatus</code>) and link it, rather than just writing <code>status: String</code>. This shows Type Safety.</li><li><b>Interface Segregation:</b> Clearly distinguish between extends (solid) and implements (dashed).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/classdiagram.jpg"
        ],
        "caption": ""
      }
  ]
},

  "UML Modifiers": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Visibility Modifiers (Access Control):</b></p>These symbols determine who can see and use the attribute or method. They map directly to OOP access keywords.<br><table><thead><tr><th>Symbol</th><th>Access Level</th><th>Java Equivalent</th><th>Meaning</th></tr></thead><tbody><tr><td><code>+</code></td><td><b>Public</b></td><td><code>public</code></td><td>Accessible by any other class.</td></tr><tr><td><code>-</code></td><td><b>Private</b></td><td><code>private</code></td><td>Accessible only inside the class itself.</td></tr><tr><td><code>#</code></td><td><b>Protected</b></td><td><code>protected</code></td><td>Accessible by the class and its children (subclasses).</td></tr><tr><td><code>~</code></td><td><b>Package</b></td><td>default</td><td>Accessible by classes in the same package.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Scope & Inheritance Modifiers:</b></p>These define how the member behaves regarding instances and inheritance.<br><ul><li><b>Static (Class Level):</b><ul><li><b>Notation:</b> <u>Underlined Text</u></li><li><b>Meaning:</b> Belongs to the Class, not an instance. Shared by all.</li><li><i>Example:</i> <u><code>+ userCount: int</code></u></li></ul></li><li><b>Abstract (Must Implement):</b><ul><li><b>Notation:</b> <i>Italicized Text</i> (or <code>{abstract}</code> tag)</li><li><b>Meaning:</b> No body. Subclasses must provide implementation.</li><li><i>Example:</i> <i><code>+ calculateTax(): double</code></i></li></ul></li><li><b>Final (Leaf):</b><ul><li><b>Notation:</b> <code>{leaf}</code> or <code>{frozen}</code> tag</li><li><b>Meaning:</b> Cannot be overridden (method) or extended (class).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Attribute-Specific Modifiers:</b></p><ul><li><b>Derived (Calculated):</b><ul><li><b>Notation:</b> <code>/</code> prefix before the name.</li><li><b>Meaning:</b> Computed on the fly; not stored in memory.</li><li><i>Example:</i> <code>/age</code> (derived from birthDate).</li></ul></li><li><b>Read-Only (Constant):</b><ul><li><b>Notation:</b> <code>{readOnly}</code> tag after the type.</li><li><b>Meaning:</b> Set once (usually in constructor) and immutable.</li></ul></li><li><b>Multiplicity (Collections):</b><ul><li><b>Notation:</b> <code>[min..max]</code> after the name.</li><li><b>Meaning:</b> Defines list size limits.</li><li><i>Example:</i> <code>- emailAddresses: String [1..*]</code> (At least one email required).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Defaults Matter:</b> Explicitly writing <code>-</code> (private) demonstrates you understand <b>Encapsulation</b>. Leaving it blank implies lazy design.</li><li><b>Derived Attributes:</b> Use the <code>/</code> notation for business logic fields like \"Total Price\" to clarify they are not database columns.</li><li><b>Static vs. Instance:</b> Always <u>underline</u> Singleton instances or utility methods to distinguish stateful objects from stateless helpers.</li></ul>"
    }
  ]
},

  "Cardinality": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>Concept:</b> Defines \"How many\" instances of one class are linked to instances of another class.</li><li><b>Synonym:</b> Often called \"Multiplicity\" in UML, while \"Cardinality\" is more common in Database Design.</li><li><b>Direction:</b> It is read from \"Source\" to \"Target.\"</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Notation Cheat Sheet:</b></p><table><thead><tr><th>Notation</th><th>Meaning</th><th>Description</th></tr></thead><tbody><tr><td><code>1</code></td><td><b>Exactly One</b></td><td>Mandatory. (e.g., An Order must have exactly 1 Customer).</td></tr><tr><td><code>0..1</code></td><td><b>Zero or One</b></td><td>Optional. (e.g., A User might have a Referral Code).</td></tr><tr><td><code>*</code> or <code>0..*</code></td><td><b>Zero to Many</b></td><td>Optional List. (e.g., A Library has many Books).</td></tr><tr><td><code>1..*</code></td><td><b>One to Many</b></td><td>Mandatory List. (e.g., An Order must have at least 1 Item).</td></tr><tr><td><code>m..n</code></td><td><b>Range</b></td><td>Bounded. (e.g., A Car has 2..4 Doors).</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Mapping to Code (Java)\n// Cardinality dictates whether you use a single Object or a Collection.\n\nclass Department {\n    // 1..* (One to Many)\n    // \"Many\" implies a Collection\n    private List<Employee> employees; \n}\n\nclass Employee {\n    // 1 (Many to One)\n    // \"One\" implies a direct Object reference\n    private Department department;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Relationship Types (Symmetry):</b></p><ul><li><b>One-to-One (1:1):</b> User â”€â”€â”€â”€ Profile. Usually merged into one table unless lazy loading is needed.</li><li><b>One-to-Many (1:N):</b> Team â”€â”€â”€â”€ Player. The most common type. Parent has a List; Child has a Parent reference.</li><li><b>Many-to-Many (M:N):</b> Student â”€â”€â”€â”€ Course. Requires a <b>Join Table</b> in the DB.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Database Design Implication:</b><ul><li><b>1..*:</b> Interviewer assumes a <b>Foreign Key</b> on the \"Many\" side.</li><li><b>*..*:</b> Interviewer assumes a hidden <b>Join Table</b> (Bridge Table).</li></ul></li><li><b>Constraint Handling:</b> If you write <code>1..*</code> (1 to Many), you must enforce it in the constructor (e.g., <code>if (items.isEmpty()) throw error</code>). Don't just draw it; validate it.</li><li><b>Unidirectional vs. Bidirectional:</b> In LLD, prefer <b>Unidirectional</b> (Source $\\rightarrow$ Target) to reduce coupling. Only make it Bidirectional if absolutely necessary for performance.</li></ul>"
    }
  ]
},

  "Use Case": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> A high-level view of <i>what</i> the system does (Functional Requirements), not <i>how</i> it does it.</li><li><b>Audience:</b> Non-technical stakeholders (PMs, Clients) and Developers.</li><li><b>Focus:</b> Interaction between \"Actors\" (Users/External Systems) and the \"System\" functions.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Components:</b></p><ul><li><b>Actor (Stick Figure):</b> Represents a <b>Role</b> (not a person). Can be Human (User) or System (External API, Timer).</li><li><b>Use Case (Oval):</b> Represents a distinct functionality or goal. <b>Naming:</b> Verb + Noun (e.g., <i>Place Order</i>).</li><li><b>System Boundary (Rectangle):</b> A box defining the scope. Inside = Your Code. Outside = Actors.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Relationships (The Critical Part):</b></p><table><thead><tr><th>Relationship</th><th>Notation</th><th>Meaning</th><th>Example</th></tr></thead><tbody><tr><td><b>Association</b></td><td>Solid Line</td><td>Interaction. Actor to Use Case.</td><td>Customer â€”â€” Login</td></tr><tr><td><b>Include</b></td><td>Dashed Arrow + <code>&lt;&lt;include&gt;&gt;</code></td><td><b>Mandatory.</b> Base always calls Included. (Reuse).</td><td>Checkout $\\rightarrow$ Verify Payment</td></tr><tr><td><b>Extend</b></td><td>Dashed Arrow + <code>&lt;&lt;extend&gt;&gt;</code></td><td><b>Optional.</b> Runs only if specific conditions met.</td><td>Order Food $\\leftarrow$ Use Coupon</td></tr><tr><td><b>Generalization</b></td><td>Solid Line + Hollow Triangle</td><td><b>Inheritance.</b> \"Is-A\".</td><td>Admin $\\rightarrow$ User</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Include vs. Extend (The Cheat Sheet):</b></p><ul><li><b>Include (Base $\\rightarrow$ Child):</b> \"I <b>need</b> this to finish my job.\" (Cannot bake cake without mixing).</li><li><b>Extend (Child $\\rightarrow$ Base):</b> \"I <b>might</b> add this to the job.\" (Baking a cake, maybe adding sprinkles).</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Actors aren't just People:</b> External APIs (SendGrid) and Time (Cron Jobs) are also Actors.</li><li><b>Granularity:</b> Don't model UI steps. <b>Bad:</b> \"Click Submit\". <b>Good:</b> \"Register User\".</li><li><b>The \"Login\" Trap:</b> Don't link everything to \"Login\" via <code>&lt;&lt;include&gt;&gt;</code>. It clutters the diagram. Use a parent actor \"Authenticated User\" instead.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/usecase.png"
        ],
        "caption": ""
      }
  ]
},

  "Sequence Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Captures the <b>Dynamic Behavior</b> of the system. It shows Time-Ordered interactions between objects.</li><li><b>Focus:</b> \"Who talks to whom, and in what order?\"</li><li><b>Usage:</b> Perfect for modeling API flows, Service-to-Service communication, and Race Conditions.</li></ul>"
    },
    {
      "type": "text",
      "content": "<br><p><b>Core Components:</b></p><ul><li><b>Lifeline (Dashed Line):</b> Represents an object or actor existing over time. (e.g., <code>:OrderService</code>).</li><li><b>Activation Bar (Thin Rectangle):</b> Represents the period when the object is active (processing or waiting). Meaning: \"The CPU/Thread is busy here.\"</li><li><b>Messages (Arrows):</b><ul><li><b>Synchronous:</b> Solid line + <b>Filled</b> Arrowhead (Request & Wait).</li><li><b>Asynchronous:</b> Solid line + <b>Open</b> Arrowhead (Fire & Forget).</li><li><b>Return:</b> Dashed line + Open Arrowhead (Response).</li><li><b>Self Message:</b> Arrow looping back to same lifeline.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Interaction Fragments (Logic in Diagrams):</b></p>Since diagrams are static, we use frames to represent code logic.<br><table><thead><tr><th>Fragment</th><th>Keyword</th><th>Code Equivalent</th><th>Meaning</th></tr></thead><tbody><tr><td><b>Alternative</b></td><td><code>alt</code></td><td><code>if (...) { } else { }</code></td><td>Mutually exclusive choices.</td></tr><tr><td><b>Option</b></td><td><code>opt</code></td><td><code>if (...) { }</code></td><td>Single choice. Runs only if true.</td></tr><tr><td><b>Loop</b></td><td><code>loop</code></td><td><code>for / while</code></td><td>Repeats the interaction inside.</td></tr><tr><td><b>Parallel</b></td><td><code>par</code></td><td>Threads / Futures</td><td>Interactions happen simultaneously.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "code",
      "language": "text",
      "content": "Example Flow (User Login)\n\nUser -> Controller : login(id, pwd) [Sync]\nactivate Controller\n\nController -> Service : validate(id) [Sync]\nactivate Service\n\nService -> Database : SELECT User [Sync]\nactivate Database\nDatabase --> Service : UserObject [Return]\ndeactivate Database\n\nalt [Password Match]\n    Service --> Controller : Token\nelse [Password Fail]\n    Service --> Controller : Error\nend\n\ndeactivate Service\nController --> User : Response\ndeactivate Controller"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Sync vs. Async (The Arrowhead Rule):</b><ul><li><b>Filled Arrowhead ($\rightarrow$):</b> You are blocked waiting for an answer (HTTP GET).</li><li><b>Open Arrowhead ($\rightarrow$):</b> You send it and move on immediately (Kafka Event).</li></ul></li><li><b>Don't Model Everything:</b> Do not draw arrows for getters/setters (<code>getName()</code>). It clutters the diagram. Only model significant business logic.</li><li><b>Database as a Lifeline:</b> In LLD, always represent the Database (or Cache) as a separate Lifeline. It clarifies latency and I/O boundaries.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/sequencediagram.png"
        ],
        "caption": ""
      }
  ]
},
  "Activity Diagram": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Describes the <b>Flow of Control (Workflow)</b> within a system. It models the sequence of activities step-by-step.</li><li><b>Analogy:</b> It is \"Flowchart 2.0\" (Object-Oriented Flowchart).</li><li><b>Key Difference:</b> Activity Diagrams support <b>Concurrency (Parallel processing)</b>, whereas traditional flowcharts are strictly sequential.</li><li><b>Focus:</b> \"What happens next?\" (Algorithm logic or Business Process).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Core Symbols:</b></p><table><thead><tr><th>Symbol</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td>&#9679;</td><td><b>Start Node</b></td><td>The entry point.</td></tr><tr><td>[Rounded Rect]</td><td><b>Action</b></td><td>Represents a step (e.g., \"Validate Order\").</td></tr><tr><td>&rarr;</td><td><b>Control Flow</b></td><td>Shows order of execution.</td></tr><tr><td>&diams;</td><td><b>Decision/Merge</b></td><td><b>Decision:</b> Splits flow (If/Else). <br><b>Merge:</b> Recombines paths.</td></tr><tr><td>&#128280;</td><td><b>End Node</b></td><td>\"Bullseye\". Termination point.</td></tr></tbody></table>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Concurrency (The \"Superpower\"):</b></p>This is the main reason we use Activity Diagrams in LLD over simple flowcharts.<br><ul><li><b>Fork (Split):</b><ul><li><b>Notation:</b> Thick black bar with 1 input and <b>Multiple outputs</b>.</li><li><b>Meaning:</b> \"Do these things simultaneously\" (Multi-threading).</li><li><i>Example:</i> After Order Placed $\\rightarrow$ Send Email AND Update Inventory.</li></ul></li><li><b>Join (Sync):</b><ul><li><b>Notation:</b> Thick black bar with Multiple inputs and <b>1 output</b>.</li><li><b>Meaning:</b> \"Wait for <b>all</b> threads to finish before continuing.\"</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Swimlanes (Partitioning):</b></p><ul><li><b>Definition:</b> Vertical or horizontal columns that divide activities based on <b>Responsibility</b> (Who does it?).</li><li><b>Usage:</b> Separates actions by Class, System, or Actor.</li><li><i>Example:</i> <b>User</b> (Click Checkout) | <b>System</b> (Validate) | <b>Bank</b> (Process Payment).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Activity vs. Sequence:</b><ul><li><b>Sequence Diagram:</b> Focuses on <b>Objects talking</b> (Time & Messages). Use for API contracts.</li><li><b>Activity Diagram:</b> Focuses on <b>Internal Logic</b> (If/Else, Parallelism). Use for complex algorithms.</li></ul></li><li><b>Concurrency Modeling:</b> In multi-threaded designs (e.g., Web Crawler), explicitly use <b>Fork and Join</b> bars. It proves you understand parallel computing constraints.</li><li><b>Missing \"Else\":</b> When drawing a Decision Diamond, always draw the outgoing arrow for <b>both</b> outcomes (Yes and No). Leaving a \"dead end\" is a logical error.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/activitydiagram.jpg"
        ],
        "caption": ""
      }
  ]
},

  "State Machine": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> Models the <b>lifecycle of a single object</b> as it changes states in response to events.</li><li><b>Focus:</b> \"How does an object change over time?\" (Status updates).</li><li><b>Usage:</b> Mandatory for objects with complex lifecycles like <b>Orders, Payments, TCP Connections</b>, or Game Characters.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Core Components:</b></p><ul><li><b>State (Rounded Rectangle):</b> Represents a condition (e.g., <code>Pending</code>, <code>Shipped</code>).</li><li><b>Initial State:</b> Solid black circle (&#9679;). Birth of the object.</li><li><b>Final State:</b> Bullseye symbol. Death of the object.</li><li><b>Transition (Arrow):</b> Movement from one state to another.<br><b>Syntax:</b> <code>Trigger [Guard] / Action</code><ul><li><b>Trigger:</b> The event (e.g., <code>paymentReceived</code>).</li><li><b>Guard:</b> Boolean condition (e.g., <code>[amount &gt; 0]</code>).</li><li><b>Action:</b> Operation executed during move (e.g., <code>sendEmail()</code>).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Internal State Activities:</b></p>A state is not just a label; logic happens inside it.<br><ul><li><b>entry / action:</b> Executed immediately upon entering.</li><li><b>do / activity:</b> Executed continuously while inside.</li><li><b>exit / action:</b> Executed immediately before leaving.</li></ul><br><b>Example: \"Ringing\" State (Phone)</b><pre>State: Ringing\n  entry / playSound()   (Starts ringing immediately)\n  do / flashLight()     (Keeps flashing while ringing)\n  exit / stopSound()    (Stops sound when picked up)</pre>"
    },
    {
      "type": "text",
      "content": "<p><b>Composite States (Superstates):</b></p><ul><li><b>Definition:</b> A state that contains other sub-states.</li><li><b>Usage:</b> Groups related states to simplify the diagram.</li><li><b>Example:</b> A <code>PaymentProcessing</code> state might internally contain <code>Validating</code>, <code>Charging</code>, and <code>Refunding</code>. Cancelling transitions out of the entire container.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Activity vs. State Machine (#1 Confusion):</b><ul><li><b>Activity Diagram:</b> Models a <b>Process/Workflow</b> (Steps of a job). Focus = Control Flow.</li><li><b>State Machine:</b> Models an <b>Object</b> (Status of an entity). Focus = Data/Status Change.</li><li><i>Rule:</i> Use Activity for \"Checkout Flow\", State Machine for \"Order Status\".</li></ul></li><li><b>The State Design Pattern:</b> If asked to code this, <b>do not</b> use massive if-else/switch statements. Use the <b>State Design Pattern (GOF)</b>, where each state is a separate class.</li><li><b>Completeness:</b> Ensure every state has a way out (except Final). A state with entry but no exit is a \"Dead State\" (Bug).</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/statediagram.png"
        ],
        "caption": ""
      }
  ]
},

  "System Boundary": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Purpose:</b></p><ul><li><b>Definition:</b> A visual line (box) that separates the <b>Internal System</b> (what you are building) from the <b>External Environment</b> (Users, 3rd Party APIs).</li><li><b>Goal:</b> Explicitly define the <b>Scope</b> of the project.</li><li><b>Interpretation:</b><ul><li><b>Inside the Box:</b> Your responsibility. You design and code this.</li><li><b>Outside the Box:</b> External entities (Actors) that interact with your system but are not controlled by it.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Notation & Structure:</b></p><ul><li><b>Shape:</b> A large rectangle.</li><li><b>Content:</b><ul><li><b>System Name:</b> Written at the top (e.g., \"ATM System\").</li><li><b>Inside:</b> All Use Cases (Ovals).</li><li><b>Outside:</b> All Actors (Stick figures).</li></ul></li><li><b>Crossing the Line:</b> Lines connecting Actors to Use Cases must cross the boundary. This represents an <b>Interface</b> (UI or API).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Example: ATM System</b></p><ul><li><b>Box:</b> Labeled \"ATM Banking System\".</li><li><b>Outside:</b> Actors (Customer, Bank Mainframe, Technician).</li><li><b>Inside:</b> Use Cases (Withdraw Cash, Check Balance).</li><li><b>Flow:</b> Customer connects to <i>Withdraw Cash</i> (Crossing the boundary). <i>Withdraw Cash</i> connects to <i>Bank Mainframe</i> (Crossing again).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Scope Creep Defense:</b> The System Boundary is your tool to define limits. If a stakeholder asks to fix an external API, point to the boundary: \"That is an external actor; we can only interface with it.\"</li><li><b>Interface Identification:</b> Every line crossing the boundary represents a requirement:<ul><li>Line to User $\\rightarrow$ <b>UI</b> (Screen/App).</li><li>Line to System $\\rightarrow$ <b>API Contract</b> (REST/gRPC).</li></ul></li><li><b>Microservices:</b> In large systems, you can have nested boundaries. The \"Payment Service\" is a boundary inside the larger \"E-Commerce Platform\".</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/systemboundary.svg"
        ],
        "caption": ""
      }
  ]
},

  "Sync vs Async": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Core Difference:</b></p><ul><li><b>Synchronous (Blocking):</b><ul><li><b>Behavior:</b> The caller sends a request and <b>waits</b> (blocks the thread) until the response arrives.</li><li><b>Flow:</b> Serial execution (Step A $\\rightarrow$ Step B).</li><li><b>Analogy:</b> <b>A Phone Call.</b> You cannot do anything else until the other person stops talking.</li></ul></li><li><b>Asynchronous (Non-Blocking):</b><ul><li><b>Behavior:</b> The caller sends a request and <b>immediately moves on</b>. The response is handled later (via Callback, Future, or Event).</li><li><b>Flow:</b> Parallel execution.</li><li><b>Analogy:</b> <b>Email.</b> You send a mail and go back to work. You check the inbox later.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Architecture Patterns:</b></p><table><thead><tr><th>Feature</th><th>Synchronous</th><th>Asynchronous</th></tr></thead><tbody><tr><td><b>Protocol</b></td><td>HTTP (REST), gRPC</td><td>Message Queues (Kafka, RabbitMQ), Webhooks</td></tr><tr><td><b>Coupling</b></td><td><b>Tight.</b> Caller needs Callee to be online now.</td><td><b>Loose.</b> Callee can be down; message waits in Queue.</td></tr><tr><td><b>Latency</b></td><td><b>Additive.</b> Total = $T_1 + T_2 + T_3$.</td><td><b>Parallel.</b> Total = $Max(T_1, T_2, T_3)$.</td></tr><tr><td><b>Use Case</b></td><td>Real-time feedback (Login, Search).</td><td>Background tasks (Email, Reports).</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Synchronous (Blocking the Thread)\n// The thread STOPS here for 2 seconds waiting for payment\nPaymentResult result = paymentService.process(order); \nsendEmail(result); // This line cannot run until payment is done\n\n// 2. Asynchronous (Non-Blocking)\n// Fire and Forget / Future\nCompletableFuture.supplyAsync(() -> paymentService.process(order))\n    .thenAccept(result -> sendEmail(result)); // Callback\n\n// The main thread continues IMMEDIATELY to this line\nSystem.out.println(\"Order submitted!\"); "
    },
    {
      "type": "text",
      "content": "<p><b>Failure Models:</b></p><ul><li><b>Sync:</b> If Service B is down, Service A receives an Exception immediately. (<b>Fail Fast</b>).</li><li><b>Async:</b> If Service B is down, the message sits in the Queue. Service A thinks \"Everything is fine.\" (<b>Eventual Consistency</b>).</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Thread Pool Exhaustion (The Sync Killer):</b> In Synchronous systems (Spring MVC), every request holds a thread. If the Database slows down, all threads get stuck waiting, and the server hangs. Async frameworks (WebFlux) solve this by releasing the thread during I/O.</li><li><b>Eventual Consistency:</b> In Async systems, the user might see \"Processing...\" instead of \"Done.\" You must design the UI to handle this lag.</li><li><b>Dead Letter Queues (DLQ):</b> In Async, since there is no immediate caller to catch an exception, failed messages must go to a generic \"Error Queue\" (DLQ) for manual inspection or retry.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/syncasync.png"
        ],
        "caption": ""
      }
  ]
},

  "SRP": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: Single Responsibility Principle</b></p><ul><li><b>The Principle:</b> A class should have <b>one, and only one, reason to change</b>.</li><li><b>The Misconception:</b> People think \"It should do only one thing.\" No, that applies to functions. A class can have many methods, but they must all serve the same purpose or stakeholder.</li><li><b>The Litmus Test:</b> Ask yourself, \"Who is responsible for requesting changes to this class?\" <br>If the answer is \"The DBA\" AND \"The UI Designer,\" you have violated SRP.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"God Class\"):</b></p>Here, the <code>Employee</code> class has three divergent reasons to change:<ol><li><b>Business Logic:</b> HR changes salary rules.</li><li><b>Database Logic:</b> DBA changes SQL schema.</li><li><b>Presentation Logic:</b> Frontend changes report format.</li></ol>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: \"God Class\"\npublic class Employee {\n    public double calculatePay() { ... } // Logic\n    public void saveToDatabase() { ... } // Persistence\n    public String generateReport() { ... } // Presentation\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Decoupling):</b></p>Split the responsibilities into specialized classes."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Business Data & Rules (Domain)\npublic class Employee {\n    public double calculatePay() { ... } \n}\n\n// 2. Persistence (Repository Pattern)\npublic class EmployeeRepository {\n    public void save(Employee e) { ... }\n}\n\n// 3. Presentation (View/DTO)\npublic class EmployeeReporter {\n    public String generate(Employee e) { ... }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>\"Reason to Change\":</b> This is the keyword. Don't just say \"it keeps code clean.\" Say: \"It isolates the impact of change. If the Database schema changes, I shouldn't risk breaking the Payroll calculation logic.\"</li><li><b>High Cohesion:</b> SRP leads to High Cohesion. This means all methods in a class are closely related and work towards a shared goal.</li><li><b>Balance:</b> Don't overdo it. If you split a class into 10 tiny classes that are never used apart, you've created \"Fragmented Logic\" (Unnecessary Complexity). Only split if there is a divergent reason to change.</li></ul>"
    }
  ]
},

  "Open/Closed": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Software entities (classes, modules) should be <b>Open for Extension</b> but <b>Closed for Modification</b>.</li><li><b>The Goal:</b> You should be able to add new features to the system without editing existing, tested source code.</li><li><b>The Benefit:</b> <b>Stability.</b> If you don't touch the old code, you can't break the old code (Zero Regression Bugs).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Switch\" Statement):</b></p>This is the most common violation. If you see a generic class checking \"types\" with <code>if/else</code> or <code>switch</code>, it violates OCP.<br><br><b>Scenario:</b> Adding a new shape (Triangle) requires opening and modifying the <code>AreaCalculator</code> class."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: Rigid and Fragile\npublic class AreaCalculator {\n    public double calculate(Object shape) {\n        if (shape instanceof Circle) {\n            return 3.14 * ((Circle)shape).radius * ((Circle)shape).radius;\n        } else if (shape instanceof Square) {\n            return ((Square)shape).side * ((Square)shape).side;\n        }\n        // If I want to add Triangle, I MUST modify this file.\n        return 0;\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Polymorphism):</b></p>Move the behavior into the specific classes using an Interface. The calculator no longer cares what the shape is.<br><br><b>Scenario:</b> Adding a <code>Triangle</code> class. We create a new file <code>Triangle.java</code>. We do not touch <code>AreaCalculator.java</code>."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Good Code: Extensible and Robust\ninterface Shape {\n    double calculateArea();\n}\n\npublic class Circle implements Shape {\n    public double calculateArea() { return 3.14 * radius * radius; }\n}\n\npublic class AreaCalculator {\n    // This code is CLOSED. It never needs to change again.\n    public double calculate(Shape shape) {\n        return shape.calculateArea();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Polymorphism is Key:</b> OCP is usually implemented using Interfaces or Abstract Classes. If you use the Strategy Pattern, you are likely following OCP.</li><li><b>Plugin Architecture:</b> Mention this term. OCP is the foundation of plugins. Eclipse/IntelliJ doesn't rewrite their source code when you install a plugin; they just load your new class that implements their interface.</li><li><b>Bug Reduction:</b> Emphasize that OCP reduces the cost of QA (Testing). Since <code>AreaCalculator</code> wasn't touched, you theoretically don't need to re-test it when adding a Triangle.</li></ul>"
    }
  ]
},

  "Liskov Substitution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.</li><li><b>The Simple Rule:</b> It's not enough for a child class to \"Is-A\" parent; it must <b>\"Act-Like-A\"</b> parent.</li><li><b>The Warning:</b> If a subclass overrides a method to do nothing or throws an exception, you have likely violated LSP.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Penguin\" Problem):</b></p>In biology, a Penguin is a Bird. In OOP, if <code>Bird</code> has a <code>fly()</code> method, a Penguin cannot be a Bird.<br><br><b>Bad Code:</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Bird {\n    public void fly() { ... }\n}\n\nclass Penguin extends Bird {\n    @Override\n    public void fly() {\n        // LSP Violation! \n        // The calling code expects to fly, but gets a crash.\n        throw new UnsupportedOperationException(\"I can't fly!\");\n    }\n}\n\n// Why it breaks:\npublic void makeBirdFly(Bird bird) {\n    bird.fly(); // If I pass a Penguin here, the program crashes.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Segregation):</b></p>Don't force functionality on classes that can't support it. Break the hierarchy based on <b>Capability</b>, not just biology."
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Bird { ... }\n\ninterface Flyable {\n    void fly();\n}\n\nclass Sparrow extends Bird implements Flyable {\n    public void fly() { ... }\n}\n\nclass Penguin extends Bird {\n    // No fly method here. Safe.\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>The \"Square is a Rectangle\" Paradox:</b> This is the most famous interview question.<ul><li><b>Math:</b> A Square is a Rectangle.</li><li><b>OOP:</b> A Square is <b>NOT</b> a Rectangle if the objects are mutable.</li><li><b>Why:</b> If you have <code>setHeight(10)</code> on a Rectangle, you expect width to stay the same. On a Square, <code>setHeight(10)</code> implicitly changes the width to 10 too. This \"side effect\" breaks the expectations of the client code.</li></ul></li><li><b>Design by Contract:</b> LSP forces you to honor the contract of the parent class.<ul><li><b>Preconditions</b> (Input requirements) cannot be strengthened in subclass.</li><li><b>Postconditions</b> (Output guarantees) cannot be weakened in subclass.</li></ul></li><li><b>Refactoring Tip:</b> If you see methods like <code>throw new NotImplementedException()</code>, strictly flag it as an LSP violation.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Interface Segregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Clients should not be forced to depend on interfaces they do not use.</li><li><b>The Motto:</b> \"Many specific interfaces are better than one general-purpose interface.\"</li><li><b>The Goal:</b> Reduce the side effects of changes. If you change a method in a \"Fat Interface,\" you shouldn't force classes that don't use that method to recompile or break.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Fat Interface\"):</b></p>This occurs when you create a \"God Interface\" that covers too many capabilities.<br><br><b>Scenario:</b> We have a <code>Worker</code> interface. Robots work, but they don't eat."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: Forcing behavior\ninterface Worker {\n    void work();\n    void eat(); // Robots can't implement this meaningfully\n}\n\nclass Robot implements Worker {\n    public void work() { ... }\n    \n    public void eat() {\n        // ISP Violation! \n        // The Robot class is forced to implement a dummy method.\n        // This usually triggers an LSP violation too.\n        throw new RuntimeException(\"I don't eat!\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Role Interfaces):</b></p>Split the interface based on the client's needs, not the object's capabilities."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Good Code: Segregated Interfaces\ninterface Workable {\n    void work();\n}\n\ninterface Feedable {\n    void eat();\n}\n\n// Humans implement both roles\nclass Human implements Workable, Feedable {\n    public void work() { ... }\n    public void eat() { ... }\n}\n\n// Robots implement only what they need\nclass Robot implements Workable {\n    public void work() { ... }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Pollution:</b> If your interface implementation has methods that return <code>null</code> or throw <code>NotImplementedException</code>, you are likely violating ISP.</li><li><b>Refactoring Pattern:</b> If you have a massive interface (e.g., <code>OrderService</code> with 50 methods), use ISP to break it down into <code>OrderReader</code>, <code>OrderWriter</code>, and <code>OrderManager</code>. This makes <b>mocking in unit tests</b> much easier (you only mock the small interface you need).</li><li><b>Connection to SRP:</b> ISP is essentially SRP applied to Interfaces. An interface should have a single responsibility or role.</li></ul>"
    }
  ]
},

  "Dependency Inversion": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> High-level modules (Business Logic) should not depend on Low-level modules (Database, I/O, Network). Both should depend on <b>Abstractions</b> (Interfaces).</li><li><b>The Goal:</b> <b>Decoupling.</b> You want to be able to swap out the \"details\" (e.g., switch from MySQL to MongoDB, or Stripe to PayPal) without touching a single line of your core business logic.</li><li><b>Inversion:</b> Traditionally, logic depends on the database. Here, we invert the dependency arrow so the database implementation \"conforms\" to the logic's interface needs.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Tight Coupling):</b></p>Here, the <code>OrderService</code> (High Level) imports and creates a <code>MySQLDatabase</code> (Low Level). If you want to switch to PostgreSQL, you have to rewrite the Service.<br><br><b>Bad Code:</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class MySQLDatabase {\n    public void save(String order) { ... }\n}\n\nclass OrderService {\n    // VIOLATION: Hard dependency on a specific implementation (MySQL)\n    // The Service is now \"married\" to MySQL.\n    private MySQLDatabase database = new MySQLDatabase();\n\n    public void processOrder(String order) {\n        database.save(order);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Depend on Interface):</b></p>The Service defines \"What I need\" (the Interface). The Database implements it. The Service creates nothing; it receives the implementation (Dependency Injection)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Abstraction (Owned by High-Level Logic)\ninterface OrderRepository {\n    void save(String order);\n}\n\n// 2. The Low-Level Detail (Depends on Abstraction)\nclass MySQLDatabase implements OrderRepository {\n    public void save(String order) { ... } // SQL logic\n}\n\nclass MongoDatabase implements OrderRepository {\n    public void save(String order) { ... } // Mongo logic\n}\n\n// 3. The High-Level Module (Depends on Abstraction)\nclass OrderService {\n    private OrderRepository repository;\n\n    // Injection via Constructor\n    public OrderService(OrderRepository repository) {\n        this.repository = repository;\n    }\n\n    public void processOrder(String order) {\n        repository.save(order); // Doesn't know if it's MySQL or Mongo\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>DIP vs. DI vs. Framework:</b><ul><li><b>DIP:</b> The Principle (The Concept).</li><li><b>DI:</b> The Mechanism (The pattern, e.g., Constructor Injection).</li><li><b>Spring/Guice:</b> The Framework (The tool that automates DI).</li></ul></li><li><b>Wire Everything in Main:</b> In a DIP-compliant app, the only place that knows about specific classes (like <code>new MySQLDatabase()</code>) is the entry point (Application Startup / Configuration). The rest of the app just speaks \"Interface.\"</li><li><b>Testing Power:</b> DIP is the primary reason <b>Unit Testing</b> is possible. Because <code>OrderService</code> depends on an interface, you can inject a <code>MockRepository</code> during tests to simulate DB failures without needing a real database.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "DRY": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: DRY (Don't Repeat Yourself)</b></p><ul><li><b>The Principle:</b> \"Every piece of knowledge must have a <b>single, unambiguous, authoritative representation</b> within a system.\"</li><li><b>The Core Idea:</b> Logic duplication is the enemy of maintainability. If a business rule exists in two places and changes, you might forget to update one, causing bugs.</li><li><b>The Antonym:</b> <b>WET</b> (Write Everything Twice / We Enjoy Typing).</li></ul><br><p><b>The Analogy: \"The Restaurant Menu\"</b></p><ul><li><b>WET (Bad):</b> You write the price of the \"Cheeseburger\" on 50 different paper menus by hand. If the price changes, you have to find and erase 50 prices. You will likely miss one.</li><li><b>DRY (Good):</b> You have a central digital board. The menus just say \"See Board for Prices.\" You update the board once, and it reflects everywhere.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Copy-Paste Programming):</b></p>Here, the email validation logic is duplicated. If the business decides to ban specific domains, you have to find and fix every instance."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code: Duplicated Logic\npublic class RegistrationService {\n    public void register(String email) {\n        // Validation Logic Copy 1\n        if (!email.contains(\"@\") || email.length() < 5) {\n            throw new Error(\"Invalid\");\n        }\n        saveUser(email);\n    }\n}\n\npublic class UpdateProfileService {\n    public void updateEmail(String email) {\n        // Validation Logic Copy 2 (The duplication)\n        if (!email.contains(\"@\") || email.length() < 5) {\n            throw new Error(\"Invalid\");\n        }\n        updateUser(email);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Abstraction):</b></p>Centralize the logic. Now, if the validation rule changes, you update it in <b>one place</b>, and the whole system is updated."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Good Code: Single Source of Truth\npublic class Validator {\n    public static void validateEmail(String email) {\n        if (!email.contains(\"@\") || email.length() < 5) {\n            throw new Error(\"Invalid\");\n        }\n    }\n}\n\n// Usage\nValidator.validateEmail(userEmail); "
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Logic vs. Code Duplication (The Trap):</b> Be careful. Not all code that looks the same is duplication.<ul><li><b>True Duplication:</b> Two classes calculating \"Sales Tax\" the same way. Refactor this.</li><li><b>Incidental Duplication:</b> <code>ProductDTO</code> has <code>id, name</code> and <code>UserDTO</code> has <code>id, name</code>. They look similar, but represent different concepts. Do not merge them into a generic <code>BaseDTO</code>, or you will violate SRP later.</li></ul></li><li><b>The Rule of Three:</b> Don't abstract too early.<ul><li>1st time: Write it.</li><li>2nd time: Copy it (it's okay).</li><li>3rd time: <b>Refactor</b> it into a shared function.</li><li><i>Reason:</i> Premature abstraction creates complex, generic code that is hard to read.</li></ul></li><li><b>Database Normalization:</b> DRY applies to Databases too. Storing <code>CustomerName</code> in the <code>Orders</code> table is a data violation of DRY (Redundancy).</li></ul>"
    }
  ]
},

  "KISS": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: KISS (Keep It Simple, Stupid)</b></p><ul><li><b>The Principle:</b> Most systems work best if they are kept simple rather than made complex.</li><li><b>The Philosophy:</b> Complexity is a cost. Every extra class, layer of abstraction, or \"clever\" algorithm adds maintenance overhead and potential bugs.</li><li><b>The Goal:</b> Write code that a junior developer can understand in 5 minutes without asking you questions.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Over-Engineering / \"Clever\" Code):</b></p>Developers often try to show off by writing compact, \"clever\" one-liners or applying massive architecture to small problems.<br><br><b>Bad Code (The \"Clever\" One-Liner):</b><br>Hard to read, impossible to debug."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// What does this do? Only God and the author know.\nreturn list.stream().filter(x -> x > 5).map(x -> x * 2).reduce(0, (a, b) -> a + b) > 100 ? \"High\" : \"Low\";"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Explicit & Readable):</b></p>Break it down. <b>Clarity beats brevity.</b> Compilers optimize verbose code just fine; humans cannot optimize confused brains."
    },
    {
      "type": "code",
      "language": "java",
      "content": "int sum = 0;\nfor (int num : list) {\n    if (num > 5) {\n        sum += num * 2;\n    }\n}\n\nif (sum > 100) {\n    return \"High\";\n} else {\n    return \"Low\";\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Complexity vs. Necessity:</b> In an interview, if you use a complex Design Pattern (like Visitor or Interpreter), justify it. If a simple <code>if-else</code> works and is readable, use it. Applying patterns where they aren't needed is a <b>\"Resume Driven Development\"</b> red flag.</li><li><b>Debugging:</b> Simple code is easy to debug. \"Clever\" code hides bugs.</li><li><b>YAGNI Connection:</b> KISS often goes hand-in-hand with <b>YAGNI</b> (You Aren't Gonna Need It). Don't build a generic \"Rule Engine\" today if you only have one simple rule. Just write the <code>if</code> statement.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  
"YAGNI": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: YAGNI (You Aren't Gonna Need It)</b></p><ul><li><b>The Principle:</b> \"Always implement things when you <b>actually need them</b>, never when you just foresee that you need them.\"</li><li><b>The Origin:</b> A core practice of Extreme Programming (XP).</li><li><b>The Logic:</b> Predicting the future is hard. If you build a feature for a \"future use case,\" you are likely wrong about how it should work. You waste time building, testing, and maintaining it, only to rewrite it when the real requirement arrives.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Speculative Generality):</b></p>This happens when developers try to be \"future-proof\" by creating generic solutions for specific problems.<br><br><b>Scenario:</b> We need to save a User to a SQL Database. <br><b>Dev's Thought:</b> \"What if we switch to XML or Cloud later? I'll build a generic adapter system now.\""
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Over-engineered Interface for a future that hasn't happened\ninterface DataStore {\n    void saveSQL();\n    void saveXML(); // Not needed yet\n    void saveCloud(); // Not needed yet\n}\n\n// We implement empty methods just to satisfy the interface\nclass UserRepository implements DataStore {\n    public void saveSQL() { ... }\n    public void saveXML() { /* Empty */ } \n    public void saveCloud() { /* Empty */ }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Iterative Design):</b></p>Build exactly what is asked for today. If the requirement changes next month, refactor then."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Simple. Fits the current requirement perfectly.\nclass UserRepository {\n    public void save(User user) {\n        // SQL logic\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Cost of Carry:</b> Unused code is not free. It is <b>Technical Debt</b>. You have to read it, compile it, and test around it. If it has a bug, it breaks your build even though nobody uses it.</li><li><b>YAGNI vs. Scalability:</b> Do not confuse YAGNI with bad planning.<ul><li><b>Good Architecture:</b> Designing a system that <i>can</i> be easily extended (e.g., using Interfaces).</li><li><b>YAGNI Violation:</b> Actually <i>writing</i> the extension code before it's requested.</li></ul></li><li><b>TDD Connection:</b> Test-Driven Development (TDD) enforces YAGNI naturally. You only write code to pass the current failing test. You never write code for a test that doesn't exist yet.</li></ul>"
    }
  ]
},

  "Law of Demeter": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition: Law of Demeter (LoD)</b></p><ul><li><b>The Principle:</b> \"Talk only to your immediate friends.\" (Also known as the Principle of Least Knowledge).</li><li><b>The Rule:</b> A method <i>M</i> of an object <i>O</i> should only invoke methods of:<ul><li>The object <i>O</i> itself.</li><li>Objects passed as arguments to <i>M</i>.</li><li>Objects created within <i>M</i>.</li><li>Direct component objects (fields) of <i>O</i>.</li></ul></li><li><b>The Goal:</b> <b>Reduce coupling</b>. If Object A knows about Object C through Object B, then changing C breaks A. We want to avoid that.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (The \"Train Wreck\"):</b></p>When you see multiple dots in a single line (<code>a.getB().getC().doSomething()</code>), it's often a violation. You are reaching deep into the internal structure of another object.<br><br><b>Bad Code:</b><br>Scenario: A Paperboy wants payment. He reaches directly into the customer's wallet to take cash."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class Paperboy {\n    public void collectMoney(Customer customer) {\n        // VIOLATION: Paperboy knows Customer has a Wallet, \n        // AND knows Wallet has Cash.\n        double payment = customer.getWallet().getCash(); \n        \n        if (payment > 2.00) {\n            customer.getWallet().subtract(2.00);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Delegation):</b></p>Ask the intermediate object to do the work for you. \"Hey Customer, pay me.\" You don't care <i>how</i> they pay (Wallet, Pocket, Credit Card)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class Customer {\n    private Wallet wallet;\n\n    public void pay(double amount) {\n        // Customer manages their own internals (Encapsulation)\n        wallet.subtract(amount);\n    }\n}\n\npublic class Paperboy {\n    public void collectMoney(Customer customer) {\n        // Clean. Only talking to the immediate friend (Customer).\n        customer.pay(2.00);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Exceptions:</b></p><ul><li><b>Data Structures / DTOs:</b> If an object is just a data holder with no behavior, chaining <code>config.getDatabase().getUrl()</code> is usually acceptable because the structure <i>is</i> the contract.</li><li><b>Fluent Interfaces / Builders:</b> <code>Stream.of().filter().map()</code> is not a violation because every method returns the same type of object or a fresh object designed for chaining.</li></ul><br><p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>\"Tell, Don't Ask\":</b> LoD is closely related to this principle. Instead of asking an object for data to process it, tell the object to do the processing itself.</li><li><b>Refactoring Consequence:</b> Strictly following LoD can lead to \"Wrapper Methods\" in the middle class. Use judgment; if you write 50 wrappers just to expose internals, you might have a cohesion problem.</li><li><b>Testing Benefit:</b> It simplifies Unit Testing. In the \"Bad Code,\" to test Paperboy, you have to mock Customer <b>AND</b> Wallet. In the \"Good Code,\" you only mock Customer.</li></ul>"
    }
  ]
},

  "Fail-Fast": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> A system should stop normal operation <b>immediately</b> when it encounters an unexpected error or invalid state.</li><li><b>The Philosophy:</b> \"It is better to crash now and be noticed than to continue running with corrupted data.\"</li><li><b>The Goal:</b> Make bugs visible instantly. If you hide an error, it propagates deeper into the system, causing strange behavior that is nearly impossible to debug later.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Violation (Hiding the Bug):</b></p>This is often mistaken for \"Defensive Programming.\" The code tries to be \"nice\" by handling null silently, leading to silent failures.<br><br><b>Bad Code:</b><br>Scenario: A calculator that hides errors."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public int divide(Integer a, Integer b) {\n    if (b == null || b == 0) {\n        // VIOLATION: Failing silently. \n        // The caller thinks the result is 0, but it was actually an error.\n        System.out.println(\"Error occurred\");\n        return 0; \n    }\n    return a / b;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Solution (Guard Clauses):</b></p>Validate state at the boundary. If the input is bad, explode immediately."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public int divide(Integer a, Integer b) {\n    // Fail Fast: Validation is the very first step.\n    if (b == null) throw new IllegalArgumentException(\"B cannot be null\");\n    if (b == 0) throw new ArithmeticException(\"Cannot divide by zero\");\n\n    // If we reach here, we are 100% sure data is valid.\n    return a / b;\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Real-World Example: Java Iterators</b></p>In Java, <code>ArrayList</code> iterators are Fail-Fast. If one thread is reading a list and another thread adds an item to it, the iterator throws <code>ConcurrentModificationException</code> instantly. It does not try to guess; it crashes to prevent unpredictable behavior."
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>Debugging Speed:</b> Emphasize that Fail-Fast reduces debugging time. The stack trace points exactly to where the null entered, not 10 layers deeper.</li><li><b>Data Integrity:</b> In systems handling money or records (Database), Fail-Fast is critical. You never want to save a \"partially correct\" user profile. If one field is invalid, reject the whole save.</li><li><b>Circuit Breaker Pattern:</b> In Microservices, Fail-Fast is applied via Circuit Breakers. If a service is failing, stop calling it immediately (Open Circuit) rather than waiting for timeouts on every request.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Method Contracts": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>The Definition:</b></p><ul><li><b>The Principle:</b> Every method has a \"Contract\" that defines what it requires to work and what it guarantees in return.</li><li><b>The Metaphor:</b> It is a legal agreement between the <b>Caller (Client)</b> and the <b>Callee (Service)</b>.<ul><li><b>If</b> the Caller gives valid inputs (Preconditions).</li><li><b>Then</b> the Callee guarantees a valid result (Postconditions).</li></ul></li><li><b>Origin:</b> Bertrand Meyer's \"Design by Contract\" (DbC).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>The Three Pillars:</b></p><table><thead><tr><th>Component</th><th>Definition</th><th>Responsibility</th><th>Example</th></tr></thead><tbody><tr><td><b>Preconditions</b></td><td>What must be true <i>before</i> the method runs.</td><td>The <b>Caller</b></td><td>\"Input price > 0\", \"User logged in\".</td></tr><tr><td><b>Postconditions</b></td><td>What will be true <i>after</i> the method runs.</td><td>The <b>Callee</b></td><td>\"Return value is not null\", \"DB updated\".</td></tr><tr><td><b>Invariants</b></td><td>Conditions that remain true for the object's <i>entire lifecycle</i>.</td><td><b>Both</b></td><td>\"Balance $\\ge$ 0\".</td></tr></tbody></table>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Bad Code (Undefined Contract)\n// Caller doesn't know if negative money is allowed.\npublic void withdraw(double amount) {\n    this.balance -= amount;\n}\n\n// Good Code (Explicit Contract)\n/**\n * Withdraws money.\n * @pre amount > 0 AND amount <= balance\n * @post balance == old_balance - amount\n */\npublic void withdraw(double amount) {\n    // Enforcing Preconditions (Fail-Fast)\n    if (amount <= 0) throw new IllegalArgumentException(\"Amount must be positive\");\n    if (amount > balance) throw new IllegalStateException(\"Insufficient funds\");\n\n    this.balance -= amount;\n    \n    // Invariant check (Internal consistency)\n    assert this.balance >= 0; \n}"
    },
    {
      "type": "text",
      "content": "<p><b>LLD Interview Key Takeaways:</b></p><ul><li><b>LSP Connection:</b> Method contracts are the strict rule behind Liskov Substitution.<ul><li>A Subclass <b>cannot</b> require more (Stronger Preconditions). \"I used to accept any number, now I only accept even numbers.\" $\\rightarrow$ Breaks Client.</li><li>A Subclass <b>cannot</b> promise less (Weaker Postconditions). \"I used to save to DB, now I might just ignore it.\" $\\rightarrow$ Breaks Client.</li></ul></li><li><b>Validation Layer:</b> Explicit contracts explain where validation logic sits. Use annotations like <code>@NonNull</code> or <code>@Nullable</code> to make contracts visible in code.</li><li><b>Exception Documentation:</b> Your contract must include \"Side Effects\" (Exceptions). If your method throws <code>IOException</code>, that is part of the contract.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Singleton": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Bhai, ye pure system mein ek hi piece rahega, sab log ussi ko share karenge. No duplicates allowed!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> The Singleton pattern ensures that a class has <b>only one instance</b> and provides a global point of access to it. No matter how many times you ask for it, you get the exact same object back.</li><li><b>Why?</b> Creating multiple objects might break logic (e.g., conflicting writes) or waste resources (e.g., opening 10 DB connections instead of sharing one).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Clipboard</b></p><ul><li>If you copy text from Chrome, it goes to the <b>Clipboard</b>.</li><li>If you paste it into Notepad, it comes from the <b>same Clipboard</b>.</li><li>It wouldn't make sense to have 5 different Clipboards running at once; you wouldn't know which one holds your data! The system enforces a single shared instance.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (Double-Checked Locking)</b></p>This is the \"Gold Standard\" for interviews. It is <b>lazy</b> (creates object only when needed) and <b>thread-safe</b>."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class DatabaseConnection {\n\n    // 1. Static variable to hold the single instance.\n    // 'volatile' ensures changes are visible to all threads immediately.\n    private static volatile DatabaseConnection instance;\n\n    // 2. Private Constructor: No one outside can say \"new DatabaseConnection()\"\n    private DatabaseConnection() {\n        System.out.println(\"Connection Created!\");\n    }\n\n    // 3. Public method to get the instance\n    public static DatabaseConnection getInstance() {\n        // Check 1: If it exists, return it. Avoids expensive lock.\n        if (instance == null) {\n            \n            // Synchronized Block: Only one thread can enter here at a time.\n            synchronized (DatabaseConnection.class) {\n                \n                // Check 2: Double check! Maybe another thread created it\n                // while we were waiting for the lock.\n                if (instance == null) {\n                    instance = new DatabaseConnection();\n                }\n            }\n        }\n        return instance;\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>The \"Private Constructor\" is Key:</b> If you forget to make the constructor private, the interviewer will fail you immediately. That is the lock on the door preventing <code>new Class()</code>.</li><li><b>Why \"Double-Checked\"?</b><ul><li><b>First Check:</b> Performance (Don't freeze threads if the object already exists).</li><li><b>Second Check:</b> Correctness (Prevent race conditions where two threads enter the block simultaneously).</li></ul></li><li><b>Use Cases:</b><ul><li><b>Logging:</b> Write to one file sequentially.</li><li><b>Configuration:</b> Load <code>application.properties</code> once.</li><li><b>Hardware Interface:</b> Printer Spooler (Don't print two docs on top of each other).</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Factory Method": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Object banane ki headache, factory ki, tum bas use karo. Logic client se dur rakho!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Factory Method pattern allows you to create objects without specifying the exact class of object that will be created.</li><li><b>Problem:</b> If you use <code>new Truck()</code> everywhere in your code, and later you want to switch to <code>new Ship()</code>, you have to find and change that code in 100 places.</li><li><b>Solution:</b> You move the creation logic (the <code>new</code> keyword) into a special method. The client just calls <code>createTransport(\"Sea\")</code> and gets an object. It doesn't care if it's a Ship, Boat, or Submarine; it just knows it works.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Logistics Company</b></p><ul><li><b>Scenario:</b> You (the Client) want to send a parcel.</li><li><b>The Abstraction:</b> You don't care if the company uses a <b>Truck</b> (for road), a <b>Ship</b> (for sea), or a <b>Drone</b>.</li><li><b>The Factory:</b> You just tell the Logistics Manager: \"I need a delivery to London.\"</li><li><b>The Logic:</b> The Manager decides: \"London is overseas, so I will instantiate a <b>Ship</b> object.\" You just call the method <code>deliver()</code>; you don't worry about the vehicle creation mechanics.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We define an interface for the object (<code>Transport</code>) and a Factory class that creates them based on input."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Interface (The \"Product\")\ninterface Transport {\n    void deliver();\n}\n\n// 2. Concrete Products\nclass Truck implements Transport {\n    public void deliver() { System.out.println(\"Delivering by road in a Box.\"); }\n}\n\nclass Ship implements Transport {\n    public void deliver() { System.out.println(\"Delivering by sea in a Container.\"); }\n}\n\n// 3. The Factory (The \"Creator\")\nclass LogisticsFactory {\n    // The \"Factory Method\"\n    // Notice: It returns the Interface, not the specific class!\n    public Transport createTransport(String type) {\n        if (type.equals(\"Road\")) {\n            return new Truck();\n        } else if (type.equals(\"Sea\")) {\n            return new Ship();\n        } else {\n            throw new IllegalArgumentException(\"Unknown transport type\");\n        }\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        LogisticsFactory factory = new LogisticsFactory();\n        \n        // Client doesn't know \"Truck\" class exists. Just knows \"Road\".\n        Transport t1 = factory.createTransport(\"Road\");\n        t1.deliver(); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Open/Closed Principle:</b> This is the biggest selling point. If you want to add <b>Air</b> transport later, you simply create a <code>Plane</code> class and update the Factory. You do <b>not</b> touch the Client code (the main app logic). The client remains safe and bug-free.</li><li><b>Decoupling:</b> The client code is decoupled from the concrete classes (<code>Truck</code>, <code>Ship</code>). It only depends on the interface (<code>Transport</code>).</li><li><b>Library Design:</b> Mention this example: \"This is used heavily in libraries (like <b>JDBC</b>). When we do <code>DriverManager.getConnection()</code>, we don't know if we are getting a MySQL connection or Oracle connection object; the factory handles it internally.\"</li></ul>"
    }
  ]
},

  "Builder": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Jab constructor mein 10 parameters pass karne pade aur aadhe 'null' ho, toh samajh lo Builder pattern ki zarurat hai!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Builder pattern is used to construct a complex object step-by-step.</li><li><b>The Problem (Telescoping Constructor):</b> Imagine a class with 10 fields (Name, Address, Phone, etc.). If you use a constructor, you have to pass all 10, even if you only need 2. You end up with ugly code like <code>new User(\"John\", null, null, 25, null...)</code>.</li><li><b>The Solution:</b> Instead of one giant constructor, you use a \"Builder\" object. You tell it only what you need (<code>builder.setName(\"John\").setAge(25)</code>), and finally, call <code>.build()</code> to get the object.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Custom Pizza</b></p><ul><li>Think of <b>Subway</b> or <b>Domino's</b>.</li><li>You don't walk in and say \"Give me Pizza Variant #432\".</li><li>You build it step-by-step:<ul><li>\"Start with Thin Crust.\"</li><li>\"Add Cheese.\"</li><li>\"Skip the onions.\"</li><li><b>\"Build it!\"</b></li></ul></li><li>The final product is complex, but the process of creating it was clean and customizable.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We usually use a <b>Static Inner Class</b> for the Builder to ensure the outer class remains immutable."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class User {\n    // All fields are final (Immutable) - Good practice!\n    private final String firstName; // Required\n    private final String lastName;  // Required\n    private final int age;          // Optional\n    private final String phone;     // Optional\n\n    // Private Constructor: Only the Builder can create a User\n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.phone = builder.phone;\n    }\n\n    // Static Inner Builder Class\n    public static class UserBuilder {\n        private final String firstName;\n        private final String lastName;\n        private int age;\n        private String phone;\n\n        // Constructor for Required Parameters\n        public UserBuilder(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n\n        // Methods return 'this' to allow Chaining (Fluent Interface)\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n\n        // The final step\n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Usage\npublic class Client {\n    public static void main(String[] args) {\n        // Clean, readable, and no confusing 'nulls'\n        User user = new User.UserBuilder(\"Karan\", \"Jarawata\")\n                        .age(24)\n                        .phone(\"1234567890\")\n                        .build();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Method Chaining (Fluent Interface):</b> Interviewers love the syntax <code>obj.setA().setB().setC()</code>. Explain that returning <code>this</code> in the setter methods makes this possible.</li><li><b>Immutability:</b> This is the strongest technical advantage. Since the <code>User</code> has no setters and the constructor is private, once <code>.build()</code> returns the object, it cannot be changed. This makes it <b>thread-safe</b>.</li><li><b>Telescoping Constructor:</b> Use this keyword. \"Builder solves the Telescoping Constructor anti-pattern where you have multiple constructors with 1, 2, 3... n arguments.\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

 "Adapter": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Jab do alag interfaces baat na kar paayein, toh beech mein Adapter laga do. Just like your travel charger!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Adapter pattern acts as a bridge between two incompatible interfaces.</li><li><b>The Problem:</b> You have an existing system that expects data in <b>Format A</b>. You buy a new library that gives data in <b>Format B</b>. You cannot change the code of the library, and you don't want to rewrite your system.</li><li><b>The Solution:</b> You create a wrapper class (the Adapter) that translates the calls from the existing system into the format the new library understands.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Travel Plug</b></p><ul><li><b>Scenario:</b> You are from India (Round Pin Plug).</li><li><b>Problem:</b> You travel to the USA (Flat Pin Socket). Your charger won't fit directly.</li><li><b>Constraint:</b> You won't rebuild the hotel wall (System), and you won't buy a new laptop (Library).</li><li><b>Solution:</b> You use an <b>Adapter</b>. It takes your Round Pins and outputs Flat Pins.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Target Interface (What the client uses)\ninterface Bird {\n    void fly();\n    void makeSound();\n}\n\n// 2. The Adaptee (The existing incompatible class)\nclass PlasticToyDuck {\n    public void squeak() {\n        System.out.println(\"Squeak\");\n    }\n}\n\n// 3. The Adapter (The Wrapper)\n// It implements the interface Client expects, but holds the incompatible object.\nclass BirdAdapter implements Bird {\n    private PlasticToyDuck toyDuck;\n\n    public BirdAdapter(PlasticToyDuck toyDuck) {\n        this.toyDuck = toyDuck;\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(\"I can't fly, I am plastic!\");\n    }\n\n    @Override\n    public void makeSound() {\n        // Translation happens here!\n        // Client calls makeSound(), Adapter translates it to squeak()\n        toyDuck.squeak();\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        PlasticToyDuck toy = new PlasticToyDuck();\n        \n        // Wrap the toy in the adapter so it looks like a Bird\n        Bird birdAdapter = new BirdAdapter(toy);\n        \n        // Client thinks it's treating a real bird\n        birdAdapter.makeSound(); // Prints: \"Squeak\"\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Wrapper Pattern:</b> Adapter is also known as a Wrapper. If the interviewer asks \"How do you integrate a 3rd party Legacy API that doesn't match our interface?\", the answer is Adapter.</li><li><b>Composition over Inheritance:</b> Notice that <code>BirdAdapter</code> <b>contains</b> (has-a) the <code>PlasticToyDuck</code>, it doesn't extend it. This is preferred because the Adapter can hold any subclass of the Adaptee.</li><li><b>Two Types:</b> Mention there are <b>Class Adapters</b> (using Inheritance) and <b>Object Adapters</b> (using Composition). Object Adapters (shown above) are generally safer and more flexible.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Facade": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Bohot saare complex wires ke peeche ek simple button. Client ko bas button dabana hai, wires nahi suljhane.\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Facade pattern provides a simplified interface to a library, a framework, or any other complex set of classes.</li><li><b>The Problem:</b> Your system has many moving parts. To perform a task, the client needs to call Method A from Class 1, Method B from Class 2, and Method C from Class 3, in a specific order. This makes the client code messy and tightly coupled.</li><li><b>The Solution:</b> You build a \"Facade\" (a front-facing class). The client calls <b>one method</b> on the Facade, and the Facade handles the confusing calls to the internal subsystems.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Hotel Concierge</b></p><ul><li><b>Without Facade:</b> You want a taxi, dinner, and show tickets. You have to call the taxi company, then the restaurant, then the theater yourself.</li><li><b>With Facade:</b> You call the <b>Concierge (Facade)</b> and say \"Arrange my evening.\" The Concierge makes all the calls for you. You have a single point of contact.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (Home Theater)</b></p>To watch a movie, you have to turn on the Lights, Screen, Projector, Amp, and DVD. The Facade wraps this complexity."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Complex Subsystem Parts\nclass Light { public void dim() { System.out.println(\"Lights dimmed\"); } }\nclass Screen { public void down() { System.out.println(\"Screen down\"); } }\nclass Projector { public void on() { System.out.println(\"Projector on\"); } }\nclass Amplifier { public void setVolume(int level) { System.out.println(\"Volume \" + level); } }\nclass DVDPlayer { public void play(String movie) { System.out.println(\"Playing \" + movie); } }\n\n// The Facade\nclass HomeTheaterFacade {\n    private Light light;\n    private Screen screen;\n    private Projector projector;\n    private Amplifier amp;\n    private DVDPlayer player;\n\n    public HomeTheaterFacade(Light l, Screen s, Projector p, Amplifier a, DVDPlayer d) {\n        this.light = l; this.screen = s; this.projector = p; this.amp = a; this.player = d;\n    }\n\n    // The One-Button Interface\n    public void watchMovie(String movie) {\n        System.out.println(\"Get ready to watch a movie...\");\n        light.dim();\n        screen.down();\n        projector.on();\n        amp.setVolume(5);\n        player.play(movie);\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        // Setup done once...\n        HomeTheaterFacade homeTheater = new HomeTheaterFacade(new Light(), new Screen(), ...);\n        \n        // Client just does this:\n        homeTheater.watchMovie(\"Inception\");\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Not \"Adding\" Functionality:</b> Clarify that a Facade rarely adds new logic. It mainly <b>organizes</b> existing logic. It is a coordinator, not a worker.</li><li><b>Loose Coupling:</b> If the internal logic of the Projector changes (e.g., method name changes), only the <code>HomeTheaterFacade</code> needs to be updated. The Client code remains untouched.</li><li><b>Microservices Gateway:</b> In system design interviews, the <b>API Gateway</b> is essentially a Facade. It takes a simple request from the Frontend and coordinates calls to the User Service, Product Service, and Cart Service.</li></ul>"
    }
  ]
},

  "Decorator": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Base item wahi rahega, bas upar se layers chadhaate jao. Like adding toppings on a pizza without changing the crust!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Decorator pattern allows you to <b>dynamically</b> add behavior or features to an object without modifying its source code.</li><li><b>The Problem:</b> Inheritance is static. If you have a class <code>Coffee</code>, and you want <code>CoffeeWithMilk</code>, <code>CoffeeWithSugar</code>, <code>CoffeeWithMilkAndSugar</code>... you will end up with a <b>\"Class Explosion\"</b> (too many subclasses).</li><li><b>The Solution:</b> You use <b>Composition</b>. You wrap the original object inside a \"Decorator\" class that adds the new feature. You can wrap it again and again (like Russian Matryoshka dolls).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Starbucks Coffee</b></p><ul><li>You start with a basic <b>Espresso</b>.</li><li>You wrap it with <b>Milk</b> (Latte).</li><li>You wrap that with <b>Caramel</b>.</li><li>It's still a \"Beverage\", but it now has layers of flavor. You didn't create a specific class called <code>EspressoWithMilkAndCaramel</code>; you just composed it on the spot.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We use an interface <code>Coffee</code> and wrap it with decorators. The Decorator <b>is a</b> Coffee, but it also <b>has a</b> Coffee."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Component Interface\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// 2. Concrete Component (The Base Object)\nclass SimpleCoffee implements Coffee {\n    public String getDescription() { return \"Simple Coffee\"; }\n    public double getCost() { return 5.0; }\n}\n\n// 3. The Decorator (The Wrapper)\n// It implements Coffee (so it looks like a coffee) AND contains a Coffee.\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee tempCoffee; // The object we are wrapping\n\n    public CoffeeDecorator(Coffee newCoffee) {\n        this.tempCoffee = newCoffee;\n    }\n    \n    public String getDescription() {\n        return tempCoffee.getDescription();\n    }\n    \n    public double getCost() {\n        return tempCoffee.getCost();\n    }\n}\n\n// 4. Concrete Decorators (The Toppings)\nclass Milk extends CoffeeDecorator {\n    public Milk(Coffee newCoffee) { super(newCoffee); }\n\n    public String getDescription() { return tempCoffee.getDescription() + \", Milk\"; }\n    public double getCost() { return tempCoffee.getCost() + 1.5; }\n}\n\nclass Sugar extends CoffeeDecorator {\n    public Sugar(Coffee newCoffee) { super(newCoffee); }\n\n    public String getDescription() { return tempCoffee.getDescription() + \", Sugar\"; }\n    public double getCost() { return tempCoffee.getCost() + 0.5; }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        // Start with plain coffee\n        Coffee myCoffee = new SimpleCoffee(); \n        \n        // Add Milk\n        myCoffee = new Milk(myCoffee);\n        \n        // Add Sugar\n        myCoffee = new Sugar(myCoffee);\n        \n        // Result: Simple Coffee, Milk, Sugar | Cost: 7.0\n        System.out.println(myCoffee.getDescription() + \" $\" + myCoffee.getCost());\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Open/Closed Principle:</b> Decorator is the perfect example of OCP. You extended the behavior of <code>SimpleCoffee</code> (added Milk/Sugar) without opening or modifying the <code>SimpleCoffee</code> class file.</li><li><b>Inheritance vs. Composition:</b> This is the killer point. \"Inheritance is static (compile-time); Decorator is dynamic (run-time).\" You can decide to add Sugar while the program is running based on user input.</li><li><b>Java I/O Library:</b> The most famous real-world use case. <br><code>new BufferedReader(new FileReader(new File(\"data.txt\")))</code><br><code>BufferedReader</code> decorates <code>FileReader</code>, which decorates <code>File</code>. They all implement the <code>Reader</code> interface.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Composite": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Ek single file ho ya pura folder, command same rahega. Treat the group just like a single item!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Composite pattern is used when you have to represent a <b>Part-Whole hierarchy</b> (a tree structure).</li><li><b>The Problem:</b> You have objects (Leaves) and groups of objects (Composites). You want to treat them exactly the same way. You don't want to write: <code>if (obj is Group) { loop children } else { obj.do() }</code>.</li><li><b>The Solution:</b> Both the single object and the group implement the <b>same interface</b>. When you call a method on the group, it automatically loops through its children and calls the method on them recursively.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: File System</b></p><ul><li><b>Scenario:</b> Windows Explorer / Finder.</li><li><b>Leaf:</b> Individual Files (e.g., <code>resume.pdf</code>).</li><li><b>Composite:</b> Folders. A Folder can contain Files and <i>other</i> Folders.</li><li><b>The Interaction:</b> When you right-click and select <b>\"Get Size\"</b>:<ul><li>If it's a File, it returns its size (e.g., 2MB).</li><li>If it's a Folder, it calculates the sum of all files and sub-folders inside it.</li></ul></li><li>You (the User) don't care if you clicked a file or a folder; the interaction is identical.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We use a common interface <code>FileSystemComponent</code> for both Files and Folders."
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n\n// 1. The Component Interface (Common for both)\ninterface FileSystemComponent {\n    void showDetails();\n}\n\n// 2. The Leaf (Individual Object)\nclass File implements FileSystemComponent {\n    private String name;\n\n    public File(String name) { this.name = name; }\n\n    public void showDetails() {\n        System.out.println(\"File: \" + name);\n    }\n}\n\n// 3. The Composite (Group of Objects)\nclass Folder implements FileSystemComponent {\n    private String name;\n    // Holds a list of children (Files OR other Folders)\n    private List<FileSystemComponent> children = new ArrayList<>();\n\n    public Folder(String name) { this.name = name; }\n\n    public void addComponent(FileSystemComponent component) {\n        children.add(component);\n    }\n\n    // The Magic: Recursion\n    public void showDetails() {\n        System.out.println(\"Folder: \" + name);\n        for (FileSystemComponent child : children) {\n            child.showDetails(); // Delegates to child (File or Folder)\n        }\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        File file1 = new File(\"Resume.pdf\");\n        File file2 = new File(\"Photo.jpg\");\n        \n        Folder subFolder = new Folder(\"My Documents\");\n        subFolder.addComponent(file1);\n        \n        Folder rootFolder = new Folder(\"C: Drive\");\n        rootFolder.addComponent(subFolder); // Adding a Folder to a Folder\n        rootFolder.addComponent(file2);     // Adding a File to a Folder\n        \n        // Client treats the Root Folder just like a File\n        rootFolder.showDetails();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Recursion is King:</b> The Composite pattern relies heavily on recursion. When you call a method on the root, it ripples down to the leaves automatically.</li><li><b>UI Systems (DOM):</b> This is the classic use case. In HTML/React, a <code>&lt;div&gt;</code> (Composite) can contain <code>&lt;p&gt;</code> (Leaf) or other <code>&lt;div&gt;</code>s. The browser renders the top div, and everything inside draws itself.</li><li><b>Uniformity vs. Safety:</b> Be ready for this question. \"Should the <code>add()</code> method be in the Interface or the Composite class?\"<ul><li><b>Interface:</b> Gives <b>Uniformity</b> (you can treat everything the same), but is <b>Unsafe</b> (you might try to <code>add()</code> to a File, which crashes).</li><li><b>Composite Class:</b> <b>Safer</b>, but you lose some polymorphism (you need to know it's a Folder to add things). Usually, we prefer Safety.</li></ul></li></ul>"
    }
  ]
},

  "Proxy": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Asli Boss tak pahunchne se pehle, PA (Personal Assistant) se milna padega. Direct entry not allowed!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Proxy pattern provides a substitute or placeholder for another object. A Proxy controls access to the original object, allowing you to perform actions either <b>before</b> or <b>after</b> the request gets to the real object.</li><li><b>Why?</b> Maybe the real object is heavy to load (Lazy Loading), requires security clearance (Protection), or you want to log every request (Logging). The client talks to the Proxy, thinking it's the Real object.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Company Firewall</b></p><ul><li><b>Scenario:</b> You (Client) request <code>Google.com</code> or <code>BannedSite.com</code>.</li><li><b>The Proxy:</b> The request goes to the Company Proxy Server first, not the real internet.</li><li><b>The Logic:</b><ul><li>The Proxy checks: \"Is this website on the block list?\"</li><li><b>If Yes:</b> It blocks you (Access Denied).</li><li><b>If No:</b> It forwards the request to the real server and fetches the page for you.</li></ul></li><li>You feel like you are browsing directly, but the Proxy is filtering everything in the middle.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We use a <code>ProxyInternet</code> class to wrap the <code>RealInternet</code> class and add security checks."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Interface\ninterface Internet {\n    void connectTo(String serverhost) throws Exception;\n}\n\n// 2. The Real Object (The \"Heavy\" or \"Sensitive\" Logic)\nclass RealInternet implements Internet {\n    public void connectTo(String serverhost) {\n        System.out.println(\"Connecting to \" + serverhost);\n    }\n}\n\n// 3. The Proxy (The Gatekeeper)\nclass ProxyInternet implements Internet {\n    private Internet realInternet = new RealInternet();\n    private static List<String> bannedSites;\n\n    static {\n        bannedSites = new ArrayList<>();\n        bannedSites.add(\"banned.com\");\n        bannedSites.add(\"work-distraction.com\");\n    }\n\n    @Override\n    public void connectTo(String serverhost) throws Exception {\n        // Pre-processing (Security Check)\n        if (bannedSites.contains(serverhost.toLowerCase())) {\n            throw new Exception(\"Access Denied to \" + serverhost);\n        }\n        \n        // Forwarding to Real Object\n        realInternet.connectTo(serverhost);\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        Internet internet = new ProxyInternet();\n        \n        try {\n            internet.connectTo(\"google.com\"); // Works\n            internet.connectTo(\"banned.com\"); // Throws Exception\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Lazy Loading (Hibernate/JPA):</b> This is the #1 interview answer. \"How does Hibernate fetch a <code>User</code> but not their 10,000 <code>orders</code> immediately?\" <br><b>Answer:</b> It returns a <b>Proxy</b> object. The real orders are only fetched from the DB (the expensive query) when you actually call <code>.getOrders()</code>.</li><li><b>Spring AOP (Aspect Oriented Programming):</b> Spring uses Proxies for things like <code>@Transactional</code>. When you call a method, the Proxy intercepts it, starts the transaction, runs your method, and then commits the transaction.</li><li><b>Protection Proxy:</b> Mention that Proxies are often used for security (RBAC - Role Based Access Control) to check if a user has Admin permissions before executing a sensitive command.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Strategy": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Manzil wahi hai, bas rasta badalna hai. Car se jao ya paidal, Google Maps logic change kar deta hai bina system crash kiye!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Strategy pattern defines a family of algorithms, puts each of them in its own class, and makes their objects <b>interchangeable</b>.</li><li><b>The Problem:</b> You have a class that does something (e.g., calculates shipping cost), but the logic changes based on the situation (Air, Train, Road). You end up with a massive <code>if-else</code> or <code>switch</code> block that is hard to maintain.</li><li><b>The Solution:</b> You remove the <code>if-else</code>. You create an interface <code>ShippingStrategy</code>. You create classes <code>AirShipping</code>, <code>RoadShipping</code>. The main class just holds the interface and calls <code>calculate()</code>. You can swap the strategy at runtime!</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Google Maps</b></p><ul><li><b>Goal:</b> Reach Destination X.</li><li><b>Strategies:</b><ul><li><b>Car Mode:</b> Prioritizes highways and speed.</li><li><b>Walking Mode:</b> Uses sidewalks and shortcuts.</li><li><b>Public Transport:</b> Follows bus/train schedules.</li></ul></li><li>The \"Goal\" (Navigation) remains the same, but the \"Strategy\" (Algorithm) to get there is completely different. The app swaps the algorithm instantly when you click the icon.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (Payment System)</b></p>We want to implement a system where the user can pay via Credit Card or UPI. The context (Cart) doesn't care <i>how</i> the payment happens, only <i>that</i> it happens."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Strategy Interface\ninterface PaymentStrategy {\n    void pay(int amount);\n}\n\n// 2. Concrete Strategies (The Algorithms)\nclass CreditCardStrategy implements PaymentStrategy {\n    private String name;\n    public CreditCardStrategy(String name) { this.name = name; }\n    \n    public void pay(int amount) {\n        System.out.println(amount + \" paid with Credit Card by \" + name);\n    }\n}\n\nclass UpiStrategy implements PaymentStrategy {\n    private String upiId;\n    public UpiStrategy(String upiId) { this.upiId = upiId; }\n    \n    public void pay(int amount) {\n        System.out.println(amount + \" paid using UPI ID: \" + upiId);\n    }\n}\n\n// 3. The Context (The Shopping Cart)\nclass ShoppingCart {\n    // The Context doesn't know details, just talks to the Interface\n    public void checkout(int amount, PaymentStrategy strategy) {\n        strategy.pay(amount);\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart();\n        \n        // Runtime Decision 1: User pays by Card\n        cart.checkout(100, new CreditCardStrategy(\"Karan\"));\n        \n        // Runtime Decision 2: User changes mind, pays by UPI\n        cart.checkout(200, new UpiStrategy(\"karan@okhdfcbank\"));\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Death to If-Else:</b> If an interviewer shows you code with 10 <code>if (type == 'X')</code> statements, your immediate answer should be: \"Refactor this using the Strategy Pattern.\"</li><li><b>Runtime Switching:</b> Emphasize that unlike Inheritance (which is fixed at compile time), Strategy allows you to swap behavior <b>while the app is running</b>. (e.g., A game character switching from \"Bow\" to \"Sword\" changes the attack strategy instantly).</li><li><b>Comparators in Java:</b> The most common Java example. <code>Collections.sort(list, new NameComparator())</code> vs <code>Collections.sort(list, new AgeComparator())</code>. You are passing different strategies for sorting to the same sort function.</li></ul>"
    }
  ]
},

  "Observer": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"YouTube pe 'Bell Icon' dabaya hai? Bas wahi hai logic. Video aayegi toh notification apne aap aayega, baar-baar check nahi karna padega!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Observer pattern defines a <b>one-to-many dependency</b> between objects.</li><li><b>The Mechanism:</b> One object (the <b>Subject</b>) holds the state. When the Subject changes, it automatically \"notifies\" all attached <b>Observers</b> so they can update themselves.</li><li><b>The Goal:</b> Decoupling. The Subject doesn't care who the observers are or what they do with the data. It just says, \"Hey, I changed!\"</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: YouTube Subscription</b></p><ul><li><b>The Channel (Subject):</b> Uploads a new video.</li><li><b>The Subscribers (Observers):</b> Thousands of people have clicked \"Subscribe\".</li><li><b>The Action:</b> The Channel does not call each person individually. It pushes a <b>\"Notification\"</b> to the list of subscribers.</li><li>If you Unsubscribe, you stop getting notifications. The Channel keeps working fine without you.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We have a <code>WeatherStation</code> (Subject) that updates a <code>PhoneDisplay</code> (Observer) whenever the temperature changes."
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n\n// 1. The Observer Interface (The Subscriber)\ninterface Observer {\n    void update(float temperature);\n}\n\n// 2. The Subject Interface (The Publisher)\ninterface Subject {\n    void registerObserver(Observer o);\n    void removeObserver(Observer o);\n    void notifyObservers();\n}\n\n// 3. Concrete Subject\nclass WeatherStation implements Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private float temperature;\n\n    public void setTemperature(float temperature) {\n        this.temperature = temperature;\n        notifyObservers(); // State changed? Notify everyone!\n    }\n\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void removeObserver(Observer o) {\n        observers.remove(o);\n    }\n\n    public void notifyObservers() {\n        for (Observer o : observers) {\n            o.update(temperature);\n        }\n    }\n}\n\n// 4. Concrete Observer\nclass PhoneDisplay implements Observer {\n    private String username;\n\n    public PhoneDisplay(String username) { this.username = username; }\n\n    public void update(float temperature) {\n        System.out.println(\"Notification for \" + username + \": Temp is now \" + temperature + \"Â°C\");\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        WeatherStation station = new WeatherStation();\n        \n        Observer user1 = new PhoneDisplay(\"Karan\");\n        Observer user2 = new PhoneDisplay(\"Alice\");\n        \n        station.registerObserver(user1);\n        station.registerObserver(user2);\n        \n        // Simulating a weather update\n        station.setTemperature(30.5f); \n        // Output: Both Karan and Alice get the update instantly.\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Push vs. Pull Model:</b><ul><li><b>Push:</b> The Subject sends the data <i>in</i> the notification (like <code>update(temperature)</code> above).</li><li><b>Pull:</b> The Subject just says <code>update()</code>, and the Observer has to call <code>subject.getData()</code> to fetch what it needs.</li></ul></li><li><b>Memory Leaks (The Lapsed Listener Problem):</b> This is a pro tip. If an Observer registers but never unregisters (User closes the window but code forgets to <code>removeObserver</code>), the Subject keeps a reference to it, preventing <b>Garbage Collection</b>. This causes memory leaks.</li><li><b>Event Listeners:</b> Mention that all UI frameworks (Java Swing <code>ActionListener</code>, JavaScript <code>addEventListener</code>) are built on the Observer pattern.</li></ul>"
    }
  ]
},

  "Command": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Order waiter ko de diya, ab wo chef tak kaise pahunchega ye tumhari tension nahi. Request ko packet bana ke pass kar do!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Command pattern turns a request (method call) into a standalone <b>object</b>.</li><li><b>The Mechanism:</b> Instead of calling a method directly (<code>light.turnOn()</code>), you wrap that call inside an object (<code>new TurnOnCommand(light)</code>).</li><li><b>The Benefit:</b> Since the request is now an object, you can pass it around, store it in a list (Queue), delay its execution, or even reverse it (Undo).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Restaurant</b></p><ul><li><b>You (Client):</b> You want food. You don't run into the kitchen and tell the Chef what to do.</li><li><b>The Waiter (Invoker):</b> You give your order to the waiter.</li><li><b>The Order Slip (Command):</b> The waiter writes your request on a piece of paper. This paper is the \"Command Object\". It contains all the info needed.</li><li><b>The Chef (Receiver):</b> The waiter hangs the slip in the kitchen. The Chef picks it up and cooks.</li><li>The waiter doesn't know how to cook Lasagna; they just know how to pass the command object to the kitchen.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (Remote Control)</b></p>We build a Remote Control where buttons can be programmed to do anything (Light On, Fan Off, etc.)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Command Interface\ninterface Command {\n    void execute();\n}\n\n// 2. The Receiver (Does the actual work)\nclass Light {\n    public void turnOn() { System.out.println(\"Light is ON\"); }\n    public void turnOff() { System.out.println(\"Light is OFF\"); }\n}\n\n// 3. Concrete Command (Wraps the request)\nclass LightOnCommand implements Command {\n    private Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    public void execute() {\n        light.turnOn(); // Delegates to the Receiver\n    }\n}\n\n// 4. The Invoker (The Remote Button)\nclass RemoteControl {\n    private Command command;\n\n    public void setCommand(Command command) {\n        this.command = command;\n    }\n\n    public void pressButton() {\n        command.execute(); // Remote doesn't know it's turning on a light.\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        Light livingRoomLight = new Light();\n        \n        // Wrap the request into an object\n        Command lightsOn = new LightOnCommand(livingRoomLight);\n        \n        RemoteControl remote = new RemoteControl();\n        remote.setCommand(lightsOn);\n        \n        // User presses button -> Command executes -> Light turns on\n        remote.pressButton();\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Undo/Redo:</b> This is the #1 feature of the Command Pattern. Because every action is an object, you can keep a <code>List&lt;Command&gt;</code> history. To \"Undo\", you just pop the last command and call a generic <code>undo()</code> method (which you would add to the interface).</li><li><b>Job Queues:</b> If you need to process tasks asynchronously (like a Thread Pool or Task Scheduler), you use the Command pattern. You create \"Job objects\" and add them to a queue. The worker threads pick up the Command objects and call <code>.execute()</code>.</li><li><b>Macro Commands:</b> You can create a <code>PartyModeCommand</code> that holds a list of other commands (LightOn, MusicOn, ACOn) and executes them all at once.</li></ul>"
    }
  ]
},

  "State": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Phone lock hai toh swipe karne par passcode mangega, unlock hai toh menu khulega. Action same (Swipe), par result state par depend karta hai!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The State pattern allows an object to change its behavior when its internal state changes. It appears as if the object changed its class.</li><li><b>The Problem:</b> You have an object with many states (e.g., \"Draft\", \"Published\", \"Archived\"). Your code is full of <code>if (state == DRAFT) { ... } else if (state == PUBLISHED) { ... }</code>. This is hard to maintain.</li><li><b>The Solution:</b> You create a separate class for each state. The main object delegates the work to the \"Current State\" object. When the state changes, you just swap the object.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Vending Machine</b></p><ul><li><b>State 1: No Coin.</b> If you press \"Dispense\", it says: \"Insert money first!\"</li><li><b>State 2: Has Coin.</b> If you press \"Dispense\", it says: \"Here is your Soda.\"</li><li><b>State 3: Sold Out.</b> If you press \"Dispense\", it says: \"Sorry, out of stock.\"</li><li>The <b>\"Dispense Button\"</b> is the exact same hardware, but its logic flips completely based on the machine's current state.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We implement the Vending Machine logic without a single <code>if-else</code> statement by delegating behavior to State classes."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The State Interface\ninterface State {\n    void insertCoin();\n    void pressButton();\n}\n\n// 2. Concrete States\nclass NoCoinState implements State {\n    VendingMachine machine;\n    public NoCoinState(VendingMachine m) { this.machine = m; }\n\n    public void insertCoin() {\n        System.out.println(\"Coin inserted.\");\n        machine.setState(machine.getHasCoinState()); // State Transition\n    }\n    public void pressButton() {\n        System.out.println(\"No coin. Can't dispense.\");\n    }\n}\n\nclass HasCoinState implements State {\n    VendingMachine machine;\n    public HasCoinState(VendingMachine m) { this.machine = m; }\n\n    public void insertCoin() {\n        System.out.println(\"Coin already inside.\");\n    }\n    public void pressButton() {\n        System.out.println(\"Dispensing Soda...\");\n        machine.setState(machine.getNoCoinState()); // Transition back\n    }\n}\n\n// 3. The Context (The Machine)\nclass VendingMachine {\n    private State noCoinState;\n    private State hasCoinState;\n    \n    private State currentState; // Holds the current \"Brain\"\n\n    public VendingMachine() {\n        noCoinState = new NoCoinState(this);\n        hasCoinState = new HasCoinState(this);\n        currentState = noCoinState; // Initial State\n    }\n\n    public void setState(State state) { this.currentState = state; }\n    public State getHasCoinState() { return hasCoinState; }\n    public State getNoCoinState() { return noCoinState; }\n\n    // Delegation: The Machine just asks the State to handle it\n    public void insertCoin() { currentState.insertCoin(); }\n    public void pressButton() { currentState.pressButton(); }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        VendingMachine vm = new VendingMachine();\n        \n        vm.pressButton(); // Output: \"No coin. Can't dispense.\"\n        \n        vm.insertCoin();  // Output: \"Coin inserted.\" (State changes internally)\n        \n        vm.pressButton(); // Output: \"Dispensing Soda...\"\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Finite State Machine (FSM):</b> This is the magic word. If asked to design a Game Character (Idle $\\rightarrow$ Running) or an Order System (Placed $\\rightarrow$ Shipped), say: \"I will use the State Pattern to implement this Finite State Machine.\"</li><li><b>State vs. Strategy:</b> A common confusion.<ul><li><b>Strategy:</b> The <b>Client</b> chooses the strategy (e.g., \"Use Credit Card\").</li><li><b>State:</b> The <b>System</b> transitions itself (e.g., Machine goes from 'NoCoin' to 'HasCoin'). The client doesn't explicitly set the state.</li></ul></li><li><b>Removing Cyclomatic Complexity:</b> Highlight that you eliminated massive <code>switch-case</code> blocks. This makes the code <b>OCP (Open/Closed Principle)</b> compliant. Adding a \"WinnerState\" is easy: just add a class, don't touch the existing logic.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Template Method": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Maggi banane ka process fixed hai: Pani ubaalo, noodles daalo. Lekin 'Extra Cheese' dalna hai ya 'Butter', ye tum decide karo. Steps wahi rahenge, bas flavor badlega!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Template Method pattern defines the <b>skeleton</b> of an algorithm in a base class but lets subclasses override specific steps without changing the algorithm's structure.</li><li><b>The Invariant:</b> Some steps are the same for everyone (implemented in Base).</li><li><b>The Variant:</b> Some steps are unique (abstract methods implemented by Child).</li><li><b>The Goal:</b> <b>Code Reuse.</b> You don't copy-paste the whole algorithm just to change one small step in the middle.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Building a House</b></p><ul><li>The architect gives a master plan (The Template):<ol><li><b>Build Foundation</b> (Fixed: Concrete for everyone).</li><li><b>Build Walls</b> (Fixed: Bricks).</li><li><b>Install Windows</b> (Variable: Sliding Glass or Wood?).</li><li><b>Paint House</b> (Variable: Blue or White?).</li></ol></li><li>The sequence (Foundation $\\rightarrow$ Walls $\\rightarrow$ Windows $\\rightarrow$ Paint) <b>never changes</b>. But the details of Windows and Paint are decided by the owner (Subclass).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (OTP System)</b></p>Let's build an OTP System. Whether you send OTP via SMS or Email, the core logic (Generate $\\rightarrow$ Send $\\rightarrow$ Log) remains the same."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Abstract Base Class\nabstract class OtpService {\n    \n    // This is the \"Template Method\".\n    // It is 'final' so subclasses CANNOT change the sequence.\n    public final void processOtp(String message) {\n        String otp = generateOtp(); // Common Step\n        sendNotification(message, otp); // Variable Step (Abstract)\n        logSuccess(); // Common Step\n    }\n\n    // Common Step: Same for SMS and Email\n    private String generateOtp() {\n        return \"123456\"; // Dummy logic\n    }\n\n    // Variable Step: Subclasses MUST implement this\n    abstract void sendNotification(String message, String otp);\n\n    // Common Step\n    private void logSuccess() {\n        System.out.println(\"OTP processed successfully.\");\n    }\n}\n\n// 2. Concrete Implementation for SMS\nclass SmsOtp extends OtpService {\n    @Override\n    void sendNotification(String message, String otp) {\n        System.out.println(\"Sending SMS to User: \" + message + \" Code: \" + otp);\n    }\n}\n\n// 3. Concrete Implementation for Email\nclass EmailOtp extends OtpService {\n    @Override\n    void sendNotification(String message, String otp) {\n        System.out.println(\"Sending Email to User: \" + message + \" Code: \" + otp);\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        OtpService smsService = new SmsOtp();\n        // The client just calls the Template Method\n        smsService.processOtp(\"Login Request\");\n        \n        System.out.println(\"---\");\n        \n        OtpService emailService = new EmailOtp();\n        emailService.processOtp(\"Password Reset\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>The <code>final</code> Keyword:</b> In Java, this is critical. If you don't make the template method <code>final</code>, a subclass could override it and break the algorithm sequence (e.g., trying to send before generating). The interviewer looks for this keyword.</li><li><b>Hooks:</b> Sometimes you want a step to be optional. You define an empty method in the parent (<code>void addCondiments() {}</code>). The child can override it if they want, or ignore it. This is called a \"Hook\".</li><li><b>Hollywood Principle:</b> \"Don't call us, we'll call you.\" The Parent class (High Level) controls the flow and calls the Child class (Low Level) only when needed. The Child never controls the flow.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Chain of Responsibility": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Agar Customer Care ka banda problem solve na kar paye, toh wo Manager ko transfer kar deta hai. Ticket ghumta rahega jab tak koi solve na kar de!\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Chain of Responsibility pattern allows you to pass a request along a chain of handlers. Instead of the client specifying exactly who handles the request, the client sends it to the first object in the chain.</li><li><b>The Flow:</b> Handler 1 checks: \"Can I handle this?\"<ul><li><b>Yes:</b> It handles it (and optionally stops the chain).</li><li><b>No:</b> It passes the request to Handler 2.</li></ul></li><li><b>The Goal:</b> <b>Decoupling.</b> The sender doesn't know who will eventually process the request.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Tech Support Levels</b></p><ul><li><b>Level 1 Support:</b> Basic issues (Password reset). If they can't fix it $\\rightarrow$ Pass to L2.</li><li><b>Level 2 Support:</b> Server issues. If they can't fix it $\\rightarrow$ Pass to Engineering.</li><li><b>Engineering:</b> Code bugs. They fix it.</li><li>The user just sends an email to \"support@company.com\". They don't know (or care) if an L1 Intern or the CTO fixes it.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation (Logger System)</b></p>We build a Logger System where messages cascade. An <code>ERROR</code> might need to be printed to the Console <b>AND</b> saved to a File."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Abstract Handler\nabstract class Logger {\n    public static int INFO = 1;\n    public static int ERROR = 2;\n\n    protected int level;\n    \n    // The \"Next\" link in the chain\n    protected Logger nextLogger;\n\n    public void setNextLogger(Logger nextLogger) {\n        this.nextLogger = nextLogger;\n    }\n\n    // The Logic: Handle or Pass\n    public void logMessage(int level, String message) {\n        if (this.level <= level) {\n            write(message); // I can handle this!\n        }\n        \n        // Pass it up the chain regardless (Logging usually bubbles up)\n        if (nextLogger != null) {\n            nextLogger.logMessage(level, message);\n        }\n    }\n\n    abstract protected void write(String message);\n}\n\n// 2. Concrete Handlers\nclass ConsoleLogger extends Logger {\n    public ConsoleLogger(int level) { this.level = level; }\n    \n    @Override\n    protected void write(String message) {\n        System.out.println(\"Standard Console::Logger: \" + message);\n    }\n}\n\nclass ErrorLogger extends Logger {\n    public ErrorLogger(int level) { this.level = level; }\n    \n    @Override\n    protected void write(String message) {\n        System.out.println(\"ERROR Console::Logger: \" + message);\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        Logger errorLogger = new ErrorLogger(Logger.ERROR);\n        Logger consoleLogger = new ConsoleLogger(Logger.INFO);\n\n        // Building the Chain: Console -> Error\n        consoleLogger.setNextLogger(errorLogger);\n\n        // Client just talks to the first link\n        System.out.println(\"--- Sending INFO ---\");\n        consoleLogger.logMessage(Logger.INFO, \"This is an information.\");\n\n        System.out.println(\"\\n--- Sending ERROR ---\");\n        consoleLogger.logMessage(Logger.ERROR, \"This is an error!\");\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Servlet Filters / Spring Security:</b> This is the ultimate \"real-world\" example. When a request hits a Java server, it goes through a chain of filters (AuthFilter $\\rightarrow$ LoggingFilter $\\rightarrow$ CompressionFilter) before reaching your Controller. This is Chain of Responsibility.</li><li><b>Dynamic Chains:</b> Mention that the chain structure is flexible. You can add a new \"SecurityCheckLogger\" in the middle of the chain at runtime without breaking the code.</li><li><b>No Guarantee:</b> Be careful. It's possible the request falls off the end of the chain without anyone handling it (if you don't have a catch-all handler at the end).</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Iterator": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>\"Playlist loop pe ho ya shuffle pe, tumhe bas 'Next Song' dabane se matlab hai. Backend mein list hai ya tree, usse tumhe kya?\"</b></p><p><b>1. Simple Explanation</b></p><ul><li><b>The Concept:</b> The Iterator pattern provides a way to access elements of a collection (like a List, Array, or Tree) sequentially without exposing the underlying structure.</li><li><b>The Problem:</b> Different collections store data differently (Arrays use indices <code>[0]</code>, Linked Lists use nodes <code>node.next</code>). If the client code has to learn how every collection works just to loop through it, the code becomes messy and coupled.</li><li><b>The Solution:</b> You create a standard interface called <code>Iterator</code> with methods like <code>hasNext()</code> and <code>next()</code>. The client just calls \"Next\", and the Iterator handles the complex traversal logic internally.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: TV Remote Control</b></p><ul><li><b>Action:</b> You press the \"Channel Up\" button.</li><li><b>Result:</b> The TV moves to the next channel.</li><li><b>Abstraction:</b> You don't know (or care) if the TV stores channels as a simple list <code>[1, 2, 3]</code> or a complex satellite frequency map. The \"Channel Up\" button is your Iterator. It gives you the next item regardless of how the system works inside.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>We will create a custom collection of names and iterate over it without using a standard for-loop index."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. The Iterator Interface\ninterface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\n// 2. The Container Interface\ninterface Container {\n    Iterator getIterator();\n}\n\n// 3. Concrete Collection\nclass NameRepository implements Container {\n    public String names[] = {\"Robert\", \"John\", \"Julie\", \"Lora\"};\n\n    @Override\n    public Iterator getIterator() {\n        return new NameIterator();\n    }\n\n    // 4. The Inner Class Iterator (Knows the secrets of Repository)\n    // Defined INSIDE the collection so it can access private arrays/lists\n    private class NameIterator implements Iterator {\n        int index;\n\n        @Override\n        public boolean hasNext() {\n            if (index < names.length) {\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public Object next() {\n            if (this.hasNext()) {\n                return names[index++];\n            }\n            return null;\n        }\n    }\n}\n\n// Usage\nclass Client {\n    public static void main(String[] args) {\n        NameRepository namesRepository = new NameRepository();\n        \n        // Client doesn't touch the array directly. \n        // It asks for an Iterator.\n        for (Iterator iter = namesRepository.getIterator(); iter.hasNext(); ) {\n            String name = (String) iter.next();\n            System.out.println(\"Name: \" + name);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Java's For-Each Loop:</b> The magic behind <code>for (String s : list)</code> is the Iterator pattern. Java compiles this down to <code>while(iter.hasNext())</code>. If your custom class implements <code>Iterable</code>, you can use it in a for-each loop too.</li><li><b>Fail-Fast vs. Fail-Safe:</b> This is a huge interview topic. \"What happens if I delete an item from the list while iterating over it?\"<ul><li><b>Fail-Fast:</b> Standard Iterators (ArrayList) throw <code>ConcurrentModificationException</code> immediately to prevent bugs.</li><li><b>Fail-Safe:</b> Concurrent collections (ConcurrentHashMap) work on a clone or are weakly consistent, so they don't crash.</li></ul></li><li><b>Uniform Interface:</b> The biggest benefit is that you can write a single function <code>printAll(Iterator i)</code> that works for an ArrayList, a LinkedList, a HashSet, and a Tree. You've decoupled the algorithm from the data structure.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

"TTL Logic": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>TTL (Time To Live):</b> A mechanism that sets a lifespan for data.</li><li><b>The Concept:</b> You assign an expiration time to a piece of data when you create it. Once that time runs out, the data is automatically treated as invalid, deleted, or \"expired.\"</li><li><b>The Goal:</b> It ensures that systems don't serve stale (outdated) data to users and prevents storage systems (like caches or databases) from filling up with temporary information that is no longer needed.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Airport Boarding Pass</b></p><ul><li>It is valid <b>only</b> for a specific flight at a specific time.</li><li>Once the flight departs, the boarding pass is useless. You cannot use it the next day.</li><li>The system doesn't need to manually check if you flew 10 years ago; the \"validity period\" naturally expires, and the pass becomes trash.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>TTL is most famously used in <b>Redis</b> (a caching tool) to auto-expire keys. <br><b>Scenario:</b> A website stores a user's login session. We want the user to be logged out automatically if they are inactive for 30 minutes."
    },
    {
      "type": "code",
      "language": "java",
      "content": "import redis.clients.jedis.Jedis;\n\npublic class SessionService {\n    private Jedis redis = new Jedis(\"localhost\");\n\n    public void saveSession(String userId, String token) {\n        // SET key value\n        // EX 1800 means \"Expire in 1800 seconds\" (30 minutes)\n        redis.setex(\"session:\" + userId, 1800, token);\n    }\n\n    public String getSession(String userId) {\n        String token = redis.get(\"session:\" + userId);\n        \n        if (token == null) {\n            System.out.println(\"Session expired or does not exist.\");\n            return null;\n        }\n        \n        // Optional: Reset TTL (Sliding Expiration) if the user is active\n        // This keeps the user logged in as long as they are using the app\n        redis.expire(\"session:\" + userId, 1800);\n        return token;\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>For Databases (DB Cleanup):</b></p>Databases generally do not auto-delete rows. You must implement TTL manually:<ul><li><b>Add Column:</b> <code>expire_at</code> (Timestamp).</li><li><b>Read Logic:</b> <code>WHERE expire_at &gt; NOW()</code>.</li><li><b>Cleanup:</b> Run a scheduled background job: <code>DELETE FROM sessions WHERE expire_at &lt; NOW()</code>.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Cache Stampede:</b> If many keys have the <b>exact same TTL</b> (e.g., 1 hour), they will all expire at the exact same second. This causes a massive spike in traffic to the database to fetch fresh data.<ul><li><b>Solution (Jitter):</b> Add a small random number to the TTL (e.g., 60 mins Â± 2 mins) to spread out the expirations.</li></ul></li><li><b>Hard vs. Soft Expiry:</b><ul><li><b>Hard Expiry:</b> The data is deleted immediately.</li><li><b>Soft Expiry:</b> The data is kept but marked as \"stale.\" The system might still serve this stale data briefly while fetching fresh data in the background (better for performance).</li></ul></li><li><b>Storage Costs:</b> In System Design interviews (e.g., \"Design WhatsApp Status\"), TTL is the primary answer for how to manage storage costs. You can't store temporary status updates forever; they must expire to free up disk space.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Schedulers": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> A Scheduler is a system component designed to execute tasks automatically at specific times or recurring intervals, without manual intervention.</li><li><b>The Concept:</b> Instead of an event (like a user click) triggering a process, <b>\"Time\"</b> triggers the process.</li><li><b>The Goal:</b> Automation of maintenance tasks, reporting, or batch processing that needs to happen on a regular rhythm.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Sprinkler System</b></p><ul><li>You don't go outside to water the grass every single day.</li><li>You program the timer: \"Turn on water every morning at 6:00 AM for 15 minutes.\"</li><li>The system wakes up at 6:00 AM, does its job, and goes back to sleep. You don't need to be awake or present for it to happen.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In the Java ecosystem (Spring Boot), Schedulers are very easy to implement using annotations. <br><b>Common Scenarios:</b><ul><li><b>Fixed Rate:</b> Run every X seconds (e.g., Heartbeat check).</li><li><b>Cron Expression:</b> Run at specific calendar times (e.g., Every Monday at 9 AM).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ReportScheduler {\n\n    // Scenario 1: Fixed Rate\n    // Runs every 5000 milliseconds (5 seconds)\n    @Scheduled(fixedRate = 5000)\n    public void checkSystemHealth() {\n        System.out.println(\"Heartbeat: System is alive.\");\n    }\n\n    // Scenario 2: Cron Job\n    // Syntax: Seconds Minutes Hours DayOfMonth Month DayOfWeek\n    // \"0 0 0 * * ?\" = At 00:00:00 (Midnight) every day\n    @Scheduled(cron = \"0 0 0 * * ?\")\n    public void generateDailyReport() {\n        System.out.println(\"Starting End-of-Day Report...\");\n        // Logic to fetch data from DB and email PDF to manager\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Distributed Locking (Critical):</b> If you deploy your application on 3 servers (for scaling), the Scheduler will run on <b>all 3 servers</b>. You will end up sending the same email 3 times.<ul><li><b>Solution:</b> Use a library like <b>ShedLock</b> (with Redis or DB). It ensures that only one instance picks up the job, and the others skip it.</li></ul></li><li><b>Thread Pool Management:</b> By default, Spring's scheduler might use a single thread. If one task gets stuck (e.g., a report takes 1 hour), it blocks all other scheduled tasks.<ul><li><b>Solution:</b> Configure a <code>TaskScheduler</code> with a pool of threads (e.g., 10 threads) so long tasks don't block short ones.</li></ul></li><li><b>Idempotency:</b> Always write scheduled tasks to be idempotent. If a network glitch causes the \"Monthly Billing\" job to run twice, your code should be smart enough to see \"Oh, I already billed this user for January,\" and do nothing the second time.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  
  "Delayed Tasks": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> A Delayed Task is an operation that is scheduled to run after a specific waiting period, rather than immediately.</li><li><b>The Concept:</b> Instead of \"Execute Now,\" the system says \"Execute in X seconds/minutes.\"</li><li><b>The Difference:</b> Unlike a <b>Scheduler</b> (which runs at a specific clock time, like 9:00 AM), a <b>Delayed Task</b> runs <i>relative</i> to an event (e.g., \"Send a follow-up email 24 hours <i>after</i> the user signs up\").</li><li><b>The Goal:</b> It handles retries, timeouts, or user-experience flows that require a \"cooling off\" period.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Snooze Button</b></p><ul><li>The alarm rings. You hit <b>\"Snooze.\"</b></li><li>You are scheduling a Delayed Task: \"Ring again in 9 minutes.\"</li><li>The alarm clock doesn't care what the actual time is; it just counts down the specific delay you requested.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>One of the most critical uses of Delayed Tasks is <b>Exponential Backoff</b> for retries. If a service call fails, you don't want to retry immediately (spamming the failing server). You wait, then retry.<br><b>Scenario:</b> We try to connect to a payment gateway. If it fails, we retry with increasing delays (1s, 2s, 4s...)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class RetryService {\n    // A pool that can schedule commands to run after a delay\n    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n    public void attemptConnection(int attempt) {\n        if (connectToPaymentGateway()) {\n            System.out.println(\"Success!\");\n            return;\n        }\n\n        if (attempt > 5) {\n            System.out.println(\"Given up after 5 attempts.\");\n            return;\n        }\n\n        // Exponential Backoff Formula: 2 ^ attempt\n        long delay = (long) Math.pow(2, attempt);\n        \n        System.out.println(\"Failed. Retrying in \" + delay + \" seconds...\");\n\n        // Schedule the next attempt\n        scheduler.schedule(() -> attemptConnection(attempt + 1), delay, TimeUnit.SECONDS);\n    }\n\n    private boolean connectToPaymentGateway() {\n        // Simulate failure\n        return false; \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Distributed Systems Note:</b> In Microservices, we usually use <b>Message Queues (RabbitMQ/SQS)</b> with a \"Delay Queue\" feature rather than in-memory Java threads, so tasks aren't lost if the server restarts.</p>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Exponential Backoff:</b> This is the standard answer for \"How do you handle failed API calls?\" You wait 1s, then 2s, then 4s, then 8s. This prevents your system from accidentally DDoS-ing a service that is already struggling to recover.</li><li><b>Jitter:</b> Always add \"Jitter\" (random noise) to your backoff. If 1000 users fail at the same time, and they all retry exactly 2 seconds later, they will hammer the server again. Adding randomness (e.g., 2.1s, 1.9s) smooths out the traffic.</li><li><b>Priority Queues:</b> Internally, delayed tasks are often implemented using a Priority Queue (Min-Heap). The task with the soonest execution time is always at the top of the heap, making it efficient to check what needs to run next.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Clock Abstraction": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Clock Abstraction is the practice of wrapping the system's time source (like <code>System.currentTimeMillis()</code> or <code>LocalDateTime.now()</code>) behind an interface.</li><li><b>The Problem:</b> If your code directly calls the system clock, it becomes hard to test. You cannot easily simulate \"tomorrow\" or \"leap year\" without manually changing your computer's actual time.</li><li><b>The Solution:</b> You create a Clock service (or use <code>java.time.Clock</code>). In production, it returns the real time. In testing, it returns whatever time you tell it to (e.g., a frozen fixed time).</li><li><b>The Goal:</b> <b>Deterministic Testing.</b> Your tests should pass 100% of the time, regardless of whether you run them at 8 AM or midnight.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Filming a Movie</b></p><ul><li><b>The Script:</b> \"The hero wakes up at 7:00 AM.\"</li><li><b>The Director:</b> Doesn't wait for the actual sun to rise the next day. They simply move the hands of the <b>prop clock</b> to 7:00 AM and shout \"Action!\"</li><li>Clock Abstraction allows you to be the <b>Director of time</b> in your code, rather than waiting for reality.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In Java 8+, this is natively supported by the <code>java.time.Clock</code> class.<br><br><b>Bad Code (Hard to Test):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class SubscriptionService {\n    public boolean isExpired(LocalDateTime expiryDate) {\n        // Hard dependency on the real system time!\n        // If you run this test exactly at the expiry second, it might flake.\n        return LocalDateTime.now().isAfter(expiryDate);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Good Code (Abstracted Clock):</b></p>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import java.time.Clock;\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\n\npublic class SubscriptionService {\n    private final Clock clock;\n\n    // Dependency Injection: Pass the clock in!\n    public SubscriptionService(Clock clock) {\n        this.clock = clock;\n    }\n\n    public boolean isExpired(LocalDateTime expiryDate) {\n        // Ask the abstract clock for the time\n        return LocalDateTime.now(clock).isAfter(expiryDate);\n    }\n}\n\n// Usage in Unit Test\nclass Test {\n    void testExpiration() {\n        // Create a fake clock frozen at a specific past time\n        Clock fixedClock = Clock.fixed(Instant.parse(\"2023-01-01T10:00:00Z\"), ZoneId.of(\"UTC\"));\n        \n        SubscriptionService service = new SubscriptionService(fixedClock);\n        \n        // This test will ALWAYS pass, even if you run it in the year 2050.\n        // Because for the service, it is eternally Jan 1st, 2023.\n        assert service.isExpired(LocalDateTime.parse(\"2022-12-31T10:00:00\"));\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Flaky Tests:</b> If an interviewer asks, \"How do you prevent flaky tests that fail only at night or on weekends?\", the answer is Clock Abstraction. You remove the variable of \"real time\" from the equation.</li><li><b>Edge Case Testing:</b> It allows you to easily test rare events without waiting for them:<ul><li><b>Leap Year bugs:</b> Set the clock to Feb 29th.</li><li><b>Daylight Savings Time (DST):</b> Set the clock to the exact second the time shifts.</li><li><b>Year 2038 Problem:</b> Set the clock to the overflow date.</li></ul></li><li><b>Dependency Injection:</b> This is a classic example of why Dependency Injection is useful. You inject the Clock just like you inject a Database connection.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},


  "Logging Levels": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Logging Levels are a way of categorizing log messages based on their severity and importance.</li><li><b>The Concept:</b> Not all information is equal. A \"System Crashed\" event is critical; a \"User logged in\" event is routine; a \"Variable X = 5\" event is only useful for fixing bugs.</li><li><b>The Goal:</b> It allows you to filter logs. In production, you only want to see important errors to save disk space and reduce noise. In development, you want to see everything to understand the code flow.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Car Dashboard</b></p><ul><li><b>Speedometer (INFO):</b> Tells you normal operating data (Current speed 60km/h). You glance at it occasionally.</li><li><b>Low Fuel Light (WARN):</b> Something is not ideal, but the car is still running. You should fix it soon.</li><li><b>Check Engine Light (ERROR):</b> Something is broken. Stop the car immediately.</li><li><b>Mechanic's Diagnostic Tool (DEBUG):</b> When the mechanic plugs in their laptop, they see thousands of raw sensor data points. You (the driver) don't see this because it would distract you.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>Standard Logging frameworks (like Log4j or SLF4J) use a hierarchy: <b>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</b>.<br>If you set the level to <b>INFO</b>, you see INFO, WARN, and ERROR. (DEBUG is hidden)."
    },
    {
      "type": "code",
      "language": "java",
      "content": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PaymentService {\n    // Standard Logger initialization\n    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);\n\n    public void processPayment(String user, int amount) {\n        // TRACE: Very granular, loop variables (Only for dev)\n        logger.trace(\"Entering processPayment method\");\n\n        // DEBUG: Diagnostic info useful for debugging logic\n        logger.debug(\"Fetching bank details for user: \" + user);\n\n        // INFO: General operational events (Standard Production Level)\n        logger.info(\"Payment started for user: \" + user);\n\n        try {\n            if (amount > 100000) {\n                // WARN: Potentially harmful or odd, but system continues\n                logger.warn(\"Large transaction detected! Amount: \" + amount);\n            }\n            // Simulate logic...\n        } catch (Exception e) {\n            // ERROR: Request failed, attention needed\n            logger.error(\"Payment failed due to DB connection\", e);\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Cost & Storage:</b> This is the practical answer. \"Why not log DEBUG in production?\" Because logs cost money. Storing TBs of \"Entered function X\" logs in tools like Splunk or Datadog is expensive and useless.</li><li><b>Performance:</b> Generating a log message takes CPU time (string concatenation, I/O). If you have a <code>logger.debug</code> inside a loop running 1 million times, it will slow down your app, even if you aren't reading the logs.</li><li><b>Dynamic Log Levels:</b> A senior engineer tip: \"Ideally, we should be able to change log levels (e.g., from INFO to DEBUG) for a specific class at <b>runtime</b> without restarting the server.\" This helps debug production issues live.</li></ul>"
    }
  ]
},

  "Correlation IDs": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> A Correlation ID (or Trace ID) is a unique identifier attached to a specific user request that travels with it across the entire system.</li><li><b>The Problem:</b> In a Microservices architecture, one user click might hit 5 different services (Gateway $\\rightarrow$ Auth $\\rightarrow$ Order $\\rightarrow$ Payment $\\rightarrow$ Inventory). If the Payment service fails, how do you find the logs for that specific request in the Order service?</li><li><b>The Solution:</b> You generate a random ID (e.g., <code>abc-123</code>) at the entrance (Gateway). You pass this ID in the headers to every internal service. Every service includes this ID in its logs.</li><li><b>The Goal:</b> It allows you to \"trace\" the path of a single request across a distributed system.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Airline Baggage Tag</b></p><ul><li>You drop your bag at the Check-in counter. They stick a tag with a barcode ID: <b>BAG-999</b>.</li><li>The bag goes through sorting, gets loaded on a plane, and unloaded at the destination.</li><li>At every single scan point, the ID <b>BAG-999</b> is used. If the bag is lost, they don't search \"All black suitcases\"; they search for the last known location of <b>BAG-999</b>.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In Java, we use <b>MDC (Mapped Diagnostic Context)</b>. It acts like a \"Thread-Local\" map that automatically adds the ID to every log line printed by that thread.<br><br><b>The Filter (The Entry Point):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "import org.slf4j.MDC;\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.UUID;\n\n// Runs for every request hitting the server\npublic class CorrelationFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {\n        try {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            String correlationId = httpReq.getHeader(\"X-Correlation-ID\");\n\n            // Generate new ID if not present in headers\n            if (correlationId == null) {\n                correlationId = UUID.randomUUID().toString();\n            }\n\n            // Put it in MDC. Now Logger will auto-include this!\n            MDC.put(\"traceId\", correlationId);\n\n            chain.doFilter(request, response);\n        } finally {\n            // Cleanup thread to prevent memory leaks\n            MDC.clear();\n        }\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>The Log Output:</b></p>You configure your <code>logback.xml</code> pattern to include <code>%X{traceId}</code>. Logs from different services now tell a unified story:<ul><li><b>Log 1 (Order Svc):</b> <code>[traceId=abc-123] Order received.</code></li><li><b>Log 2 (Payment Svc):</b> <code>[traceId=abc-123] Processing payment.</code></li><li><b>Log 3 (Payment Svc):</b> <code>[traceId=abc-123] ERROR: Insufficient Funds.</code></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Needle in a Haystack:</b> This is the standard answer to \"How do you debug an error in a distributed system with 50 microservices?\" You filter by Correlation ID across centralized logging tools like <b>Splunk</b> or <b>ELK Stack</b>.</li><li><b>MDC (Mapped Diagnostic Context):</b> Memorize this term. It is the standard Java way to handle thread-context logging.</li><li><b>Header Propagation:</b> Mention that when Service A calls Service B, you must use an <b>Interceptor</b> (for RestTemplate or Feign) to copy the ID from MDC and put it into the HTTP Header. If you break this chain, the trace is lost.</li></ul>"
    }
  ]
},

  "Audit Logs": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Audit Logs are a secure, <b>immutable</b> record of \"Who did What, When, and to Whom.\"</li><li><b>The Concept:</b> While standard logs are for developers to fix bugs (e.g., \"NullPointer at line 40\"), Audit Logs are for <b>security and compliance</b>. They answer questions like: \"Who changed the admin password?\" or \"Who deleted this invoice?\"</li><li><b>The Goal:</b> Accountability. If malicious activity or a mistake occurs, you can trace it back to a specific user and action.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Bank Statement</b></p><ul><li>It doesn't just show your current balance ($500).</li><li>It shows a history: <b>Salary Credit</b>, <b>ATM Withdrawal</b>, <b>Subscription Payment</b>.</li><li>Even if money is missing, the bank can look at the audit log (statement) and tell you exactly where it went and when it happened.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>Audit logs are usually stored in a separate table to ensure they are not tampered with. Using <b>Spring AOP (Aspect Oriented Programming)</b> allows you to keep business logic clean."
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Aspect\n@Component\npublic class AuditAspect {\n\n    @Autowired\n    private AuditRepository auditRepo;\n\n    // Run this BEFORE any method with @Auditable annotation\n    @Before(\"@annotation(auditable)\")\n    public void logAudit(JoinPoint joinPoint, Auditable auditable) {\n        \n        // 1. Get User Info from Security Context\n        String currentUser = SecurityContext.getUser(); \n        \n        // 2. Get Action Details and Method Arguments\n        String action = auditable.action(); // e.g., \"DELETE_USER\"\n        String args = Arrays.toString(joinPoint.getArgs());\n        \n        // 3. Save to Audit Database\n        AuditLog log = new AuditLog();\n        log.setActor(currentUser);\n        log.setAction(action);\n        log.setDetails(\"Arguments: \" + args);\n        log.setTimestamp(Instant.now());\n        \n        auditRepo.save(log);\n    }\n}\n\n// Usage in Service Layer\n@Service\npublic class UserService {\n    \n    @Auditable(action = \"DELETE_USER\")\n    public void deleteUser(String userId) {\n        userRepo.deleteById(userId);\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Compliance (GDPR / HIPAA):</b> This is the \"Why\". If you handle medical or financial data, the law requires you to keep audit logs for 5-7 years. <i>\"If it's not logged, it didn't happen.\"</i></li><li><b>Immutability:</b> An audit log must be <b>Write-Once, Read-Many (WORM)</b>. Even a System Admin should not be able to edit these. If a hacker breaks in, they will try to delete the audit trail first; sending logs to a separate, restricted server is a best practice.</li><li><b>Async Processing:</b> Logging should not slow down the user.<ul><li><b>Bad:</b> User waits while the system writes to the Audit DB.</li><li><b>Good:</b> Push the audit event to a message queue (Kafka/RabbitMQ) and return the response to the user immediately.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Debuggability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Debuggability is a measure of how easily you can identify, locate, and fix a problem within a software system.</li><li><b>The Problem:</b> Many systems are \"Black Boxes.\" When something goes wrong (e.g., a payment fails), developers spend hours guessing or adding \"Print\" statements because they have no visibility into the failure.</li><li><b>The Solution:</b> Building the system from day one with tools like clear logs, error codes, and state-visibility.</li><li><b>The Goal:</b> Reduce <b>MTTR (Mean Time To Repair)</b>. The faster you can understand the bug, the faster the system is back online.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Transparent vs. Opaque Pipes</b></p><ul><li>If a <b>metal pipe</b> is clogged, you have to cut it open in ten different places just to find the blockage.</li><li>If the <b>pipe is transparent</b>, you can walk along the line, see exactly where the \"gunk\" is stuck, and fix only that part.</li><li>A \"debuggable\" system is a transparent pipe; you can see the flow of data and precisely where it stops.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>Debuggability isn't a specific tool; it's a set of coding habits that expose the internal state of the application.<br><br><b>A. Actionable Error Messages:</b><ul><li><b>Bad:</b> <code>Error: Something went wrong.</code> (Useless)</li><li><b>Better:</b> <code>Error 404: User [ID: 101] not found in Database [Shard: B].</code> (Actionable)</li></ul>"
    },
    {
      "type": "text",
      "content": "<b>B. Meaningful Context in Logs:</b> Always log the \"State\" of the object when an error occurs."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public void updateInventory(String productId, int quantity) {\n    try {\n        inventoryService.reduce(productId, quantity);\n    } catch (Exception e) {\n        // High Debuggability: Log the parameters that caused the failure\n        logger.error(\"Failed to update inventory. Product: {}, RequestedQty: {}, CurrentStock: {}\", \n                     productId, quantity, inventoryService.getQty(productId), e);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<b>C. Health Check & Metrics Endpoints:</b> Expose internal state via <code>/health</code>, <code>/metrics</code>, or <code>/admin/stats</code> so you can see if the system is \"choking\" (e.g., memory leaks, thread pool exhaustion) without restarting it."
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Fail-Fast Principle:</b> A debuggable system fails immediately when it encounters an invalid state. \"Silent failures\" are the enemy of debuggability because the actual bug happened 100 lines before the crash.</li><li><b>Externalizing Configuration:</b> Mention that being able to change log levels (e.g., INFO to DEBUG) or toggle <b>Feature Flags</b> at runtime without a re-deploy is a massive win for production debuggability.</li><li><b>The \"Why\" vs. \"What\":</b> Standard logging tells you <i>what</i> happened. High debuggability (via <b>Correlation IDs</b> and rich <b>Context</b>) tells you <i>why</i> it happened by connecting the dots across distributed services.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Unit Tests": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> A Unit Test is a piece of code that tests a small, isolated \"unit\" of your applicationâ€”typically a single method or a classâ€”in isolation from the rest of the system.</li><li><b>The Concept:</b> You verify that for a specific input, the method produces the expected output.</li><li><b>Isolation:</b> It should <b>not</b> talk to the database, the internet, or other complex services. Those dependencies are \"mocked\" or faked using tools like Mockito.</li><li><b>The Goal:</b> To catch bugs at the developerâ€™s desk immediately after writing code, reducing the cost of fixing errors.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Car Manufacturing</b></p><ul><li>Before a car is fully assembled, engineers test the <b>Light Bulb</b> individually.</li><li>They connect it to a battery to see if it glows. They don't wait to build the entire car, engine, and dashboard just to see if a single bulb works.</li><li>If the bulb (the unit) works in isolation, you can trust it when you eventually plug it into the car (the system).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In Java, we use <b>JUnit</b> as the testing framework. A common pattern used in writing tests is <b>AAA (Arrange, Act, Assert)</b>."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Class to Test\npublic class DiscountService {\n    public double calculateDiscount(double price) {\n        if (price < 0) throw new IllegalArgumentException(\"Price cannot be negative\");\n        if (price > 1000) return price * 0.15; // 15% for big spenders\n        return price * 0.10; // 10% standard\n    }\n}\n\n// The Unit Test\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass DiscountServiceTest {\n\n    private final DiscountService service = new DiscountService();\n\n    @Test\n    void testStandardDiscount() {\n        // Arrange: Setup input\n        double price = 100.0;\n        \n        // Act: Run the method\n        double result = service.calculateDiscount(price);\n        \n        // Assert: Verify output\n        assertEquals(10.0, result, \"Discount should be 10% of 100\");\n    }\n\n    @Test\n    void testNegativePriceThrowsException() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            service.calculateDiscount(-50);\n        });\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>FIRST Principles:</b> A good unit test must be:<ul><li><b>Fast:</b> Thousands should run in seconds.</li><li><b>Independent:</b> No shared state between tests.</li><li><b>Repeatable:</b> Deterministic results (use <b>Clock Abstraction</b>).</li><li><b>Self-Validating:</b> No manual interpretation needed.</li><li><b>Thorough:</b> Covers Happy Path, Edge Cases, and Negative Scenarios.</li></ul></li><li><b>Code Coverage:</b> While 100% line coverage is popular, <b>Branch Coverage</b> (testing every <code>if/else</code> logic path) is the gold standard for high-quality code.</li><li><b>Documentation:</b> Unit tests serve as <b>\"Living Documentation.\"</b> They describe how the code is intended to be used and what its limitations are.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Dependency Injection (DI)": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Dependency Injection (DI) is a design pattern where an object does not create its own dependencies. Instead, those dependencies are \"injected\" into it (usually via the constructor).</li><li><b>The Problem:</b> If Class A creates an instance of Class B internally (<code>new B()</code>), Class A is \"hard-coded\" to that specific implementation. You cannot easily swap Class B for a Mock object during testing or change it to a different version later.</li><li><b>The Solution:</b> Class A says, \"I need something that follows the interface of B. Someone else please provide it to me.\"</li><li><b>The Goal:</b> <b>Decoupling.</b> It makes code modular, easier to manage, andâ€”most importantlyâ€”testable.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Laptop Power Cable</b></p><ul><li>The laptop needs electricity (the dependency), but the power cable is <b>not</b> permanently soldered inside the laptop.</li><li>The laptop has a port (the <b>injection point</b>). You can plug in a wall charger, a power bank, or a car charger.</li><li>Because the power source is \"injected,\" the laptop is flexible. If the power source was built-in (hard-coded), you couldn't change it without breaking the laptop open.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In the Java/Spring world, DI is the core of the framework. It allows for high flexibility by coding to an interface rather than an implementation.<br><br><b>Bad (Tight Coupling):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class Car {\n    private Engine engine;\n\n    public Car() {\n        // Hard-coded! I can only ever use a PetrolEngine.\n        // If I want to test Car without starting a real engine, I'm stuck.\n        this.engine = new PetrolEngine(); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<b>Good (Dependency Injection):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public interface Engine { void start(); }\n\npublic class Car {\n    private Engine engine;\n\n    // Dependency is \"Injected\" via the Constructor\n    public Car(Engine engine) {\n        this.engine = engine;\n    }\n\n    public void drive() {\n        engine.start();\n    }\n}\n\n// Usage: Wires the objects together outside the class\nEngine myEngine = new ElectricEngine();\nCar myCar = new Car(myEngine); // I can inject any engine implementation!"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Inversion of Control (IoC):</b> DI is a specific way of achieving IoC. In traditional programming, your code controls the flow. In IoC, the <b>Inversion of Control Container</b> (like the Spring Context) controls the flow and \"wires\" everything together for you.</li><li><b>Types of Injection:</b><ul><li><b>Constructor Injection:</b> (Recommended) Ensures dependencies are provided at the time of creation and allows for <code>final</code> fields (immutability).</li><li><b>Setter Injection:</b> Good for optional dependencies that can be changed or provided later.</li><li><b>Field Injection:</b> (Using <code>@Autowired</code> on private fields) Convenient but discouraged, as it makes unit testing harder and hides dependencies.</li></ul></li><li><b>Testability:</b> This is the #1 reason for DI. Because the class receives its dependencies from the outside, you can easily pass in a <b>Mock object</b> during a Unit Test to simulate database failures, network timeouts, or specific return values.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  "Mocking": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Mocking is a technique used in testing to replace a real, complex dependency with a \"fake\" object that simulates the behavior of the real one.</li><li><b>The Problem:</b> Your code often depends on external things like a Database, an Email Server, or a 3rd-party Payment Gateway. If you run a unit test that actually sends a real email or charges a real credit card, the test will be slow, expensive, and unreliable.</li><li><b>The Solution:</b> You create a \"Mock\" of that service. You tell the mock: \"When the code asks you to process a payment, just return <code>true</code> immediately without actually doing anything.\"</li><li><b>The Goal:</b> To <b>isolate</b> the code you are testing so you can verify its logic without worrying about external systems.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Crash Test Dummy</b></p><ul><li>Car manufacturers want to test how an airbag performs during a collision.</li><li>They don't put a <b>real human</b> (the real dependency) in the car because it's dangerous and complicated.</li><li>Instead, they use a <b>Dummy</b> (the Mock). The dummy looks and behaves like a human for the purpose of the test, allowing the engineers to focus strictly on the airbag's performance.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In Java, <b>Mockito</b> is the standard library for creating mocks. It allows you to define \"Stub\" behavior and \"Verify\" interactions.<br><br><b>Scenario:</b> We want to test <code>OrderService</code> without sending real emails."
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The dependency we want to mock\npublic interface EmailService {\n    boolean sendEmail(String to, String body);\n}\n\n// The class we are testing\npublic class OrderService {\n    private EmailService emailService;\n\n    public OrderService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n\n    public String placeOrder(String userEmail) {\n        // ... business logic ...\n        boolean success = emailService.sendEmail(userEmail, \"Order Placed!\");\n        return success ? \"SUCCESS\" : \"FAILURE\";\n    }\n}\n\n// The Test using Mockito\nimport static org.mockito.Mockito.*;\nimport org.junit.jupiter.api.Test;\n\nclass OrderServiceTest {\n    @Test\n    void testPlaceOrder() {\n        // 1. Create the Mock\n        EmailService mockEmail = mock(EmailService.class);\n        \n        // 2. Define Behavior (Stubbing)\n        // \"When sendEmail is called with any string, return true\"\n        when(mockEmail.sendEmail(anyString(), anyString())).thenReturn(true);\n        \n        // 3. Inject the Mock (Dependency Injection)\n        OrderService service = new OrderService(mockEmail);\n        \n        // 4. Act and Assert\n        String result = service.placeOrder(\"test@example.com\");\n        assert(result.equals(\"SUCCESS\"));\n        \n        // 5. Verify (Behavioral testing: Did the code actually call the mock?)\n        verify(mockEmail, times(1)).sendEmail(eq(\"test@example.com\"), anyString());\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Mock vs. Stub:</b><ul><li><b>Stub:</b> A simple fake that returns a hard-coded value (Used for <b>State verification</b>).</li><li><b>Mock:</b> A more advanced fake that records how it was called (Used for <b>Behavior verification</b>).</li></ul></li><li><b>When to Mock:</b> Only mock what you don't \"own\" (3rd party APIs) or what is slow/unstable (Databases, Network). Never mock the <b>Class Under Test</b>.</li><li><b>Fragile Tests:</b> Be careful! Over-mocking (mocking every internal method call) leads to <b>\"Brittle Tests.\"</b> If you refactor your code structure slightly, the test will fail even if the final logic is still correct.</li><li><b>Interaction Testing:</b> Use <code>verify()</code> to ensure that critical secondary effects happened, like checking if a <code>logger.error()</code> was called when a database failed.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},


  "Test Seams": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> A Test Seam is a place in your code where you can alter behavior without editing the source code itself.</li><li><b>The Concept:</b> Think of a \"seam\" in clothing where two pieces of fabric join. In software, a seam is an entry point where you can \"unzip\" the real logic and \"plug in\" a fake one (like a Mock).</li><li><b>The Problem:</b> Legacy code often has \"hard\" dependencies (e.g., <code>new Database()</code>) inside a method. There is no \"seam\" there, making it impossible to test without real infrastructure.</li><li><b>The Goal:</b> To design code with \"access points\" specifically for the purpose of testing.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Circuit Breaker Box</b></p><ul><li>If you want to test the electricity in the kitchen, you don't have to tear down the walls to reach the wires.</li><li>The breaker box provides a <b>Seam</b>. You can flip a switch to cut off the real power from the street and plug in a portable generator to test the lights.</li><li>Because the builder provided that access point (the seam), maintenance and testing become easy.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>The most common way to create a Test Seam is through <b>Dependency Injection</b> or <b>Method Overriding</b>.<br><br><b>Scenario: No Seam (Un-testable)</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class SecuritySystem {\n    public void secureHouse() {\n        // There is no seam here! I'm stuck with the real door.\n        SmartDoor door = new SmartDoor(); \n        door.lock();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<b>Scenario: Adding an Object Seam (Testable)</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class SecuritySystem {\n    private SmartDoor door;\n\n    // This Constructor is the \"Seam\"\n    public SecuritySystem(SmartDoor door) {\n        this.door = door;\n    }\n\n    public void secureHouse() {\n        door.lock();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<b>Scenario: The \"Subclass and Override\" Seam</b><br>Sometimes you can't change the constructor. You can create a <code>protected</code> method seam to override in a test subclass."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class PaymentProcessor {\n    public void process() {\n        // ... logic ...\n        sendMoney();\n    }\n\n    // Protected method provides a seam for testing\n    protected void sendMoney() {\n        RealBankApi.transfer(); \n    }\n}\n\n// In your Test Folder:\nclass TestablePaymentProcessor extends PaymentProcessor {\n    @Override\n    protected void sendMoney() {\n        // Mock behavior: don't actually send money during testing!\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Legacy Code:</b> Michael Feathers defined seams as the primary tool for refactoring old code. If you can't test it, find a seam or create one.</li><li><b>Types of Seams:</b><ul><li><b>Preprocessing Seams:</b> Using compiler flags (like <code>#ifdef</code> in C++) to swap code.</li><li><b>Link Seams:</b> Changing which library/binary is loaded at runtime.</li><li><b>Object Seams:</b> (Most common in Java/C#) Using Polymorphism and DI to swap objects.</li></ul></li><li><b>Encapsulation vs. Testability:</b> Sometimes adding a seam requires making a private method <code>protected</code>. While some argue this breaks strict Encapsulation, in LLD, <b>Testability</b> is often considered more valuable because it prevents regressions.</li></ul>"
    }
  ]
},


  "Over-Engineering": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Definition:</b> Over-Engineering is the act of designing a product or a piece of code to be more robust, complex, or \"future-proof\" than is actually necessary for the current requirements.</li><li><b>The Problem:</b> Developers often build features they <i>think</i> they might need later (e.g., \"What if we switch from SQL to NoSQL next month?\"). This leads to layers of unnecessary abstraction and \"Interface-itis\" (interfaces with only one implementation).</li><li><b>The Principle:</b> <b>YAGNI (You Ain't Gonna Need It).</b> Do not add functionality or complexity until it is proven necessary.</li><li><b>The Goal:</b> Simplicity and speed. Every extra line of code is a liability that must be tested, maintained, and debugged.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: The Garden Shed</b></p><ul><li><b>Simple Engineering:</b> You use wood, nails, and a simple roof to keep your lawnmower dry. It takes 2 days to build.</li><li><b>Over-Engineering:</b> You build it with earthquake-proof reinforced concrete, a climate-control system, and a fingerprint scannerâ€”just in case you decide to store a Ferrari there in ten years.</li><li><b>The Result:</b> You spent 10x the money and time. Now the shed is so complex that you can't even fix a simple roof leak without calling a specialist.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>In code, over-engineering often manifests as \"Design Pattern Abuse.\"<br><br><b>The Over-Engineered Approach (Pattern Abuse):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Why create an interface, an abstract class, and a factory for one simple DB?\npublic interface IRepository<T> { void save(T entity); }\n\npublic abstract class BaseSqlRepository<T> implements IRepository<T> {\n    public abstract String getTableName();\n}\n\npublic class UserDataPersistenceManager extends BaseSqlRepository<User> {\n    @Override\n    public String getTableName() { return \"USERS\"; }\n    \n    public void save(User user) {\n        // Complex logic with 5 layers of abstraction for a simple save...\n    }\n}"
    },
    {
      "type": "text",
      "content": "<b>The Pragmatic Approach (YAGNI):</b>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "public class UserRepository {\n    public void save(User user) {\n        // Just write the SQL/JPA logic here.\n        // If we ever actually switch DBs, we refactor then.\n    }\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. LLD Interview Key Takeaways</b></p><ul><li><b>Diminishing Returns:</b> Explain that after a certain point, more design doesn't make the app \"better\"â€”it just makes it slower to develop and harder for new engineers to understand.</li><li><b>KISS Principle (Keep It Simple, Stupid):</b> In LLD interviews, if you start adding complex patterns like <i>Visitor</i> or <i>Bridge</i> where a simple <code>if</code> statement or <i>Strategy</i> works, you may be penalized for over-engineering.</li><li><b>Gold Plating:</b> This refers to working on a feature past the point of diminishing returns. Prioritize <b>Time to Market (TTM)</b> and readability over \"perfect\" theoretical flexibility.</li><li><b>Premature Optimization:</b> Mention Donald Knuthâ€™s famous quote: \"Premature optimization is the root of all evil.\" Don't build for scale that doesn't exist yet.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

  
"Perf vs Readability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>1. Simple Explanation</b></p><ul><li><b>Performance (Perf):</b> Focuses on how fast the code executes and how efficiently it utilizes system resources like CPU and RAM.</li><li><b>Readability:</b> Focuses on how easily a human developer can understand, maintain, and debug the code.</li><li><b>The Conflict:</b> The \"fastest\" code often uses obscure tricks (like bitwise operations) that are hard to read. The \"cleanest\" code might use abstractions (like Streams or Objects) that add a tiny bit of overhead.</li><li><b>The Golden Rule:</b> <b>\"Clean code is usually fast enough.\"</b> In most business apps, hardware is cheap, but developer time is expensive. Prioritize readability unless you have a <i>proven</i> performance bottleneck.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>2. Real-World Analogy: Cooking Recipes</b></p><ul><li><b>Readable Recipe:</b> \"Chop onions into small cubes and sautÃ© until golden brown.\" Easy to follow, easy to modify.</li><li><b>Performance-Optimized Recipe:</b> \"Utilize a 12-inch serrated blade at a 45-degree angle for 2mm fragments; apply 375Â°F thermal energy for 180 seconds.\" Technically precise but exhausting to read and easy to mess up.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>3. Technical Implementation</b></p>Example: Summing even numbers in a list.<br><br><b>The Readable Way (Declarative/Streams):</b> Intent is crystal clear and maintainable."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public int sumEvens(List<Integer> numbers) {\n    return numbers.stream()\n                  .filter(n -> n % 2 == 0)\n                  .mapToInt(Integer::intValue)\n                  .sum();\n}"
    },
    {
      "type": "text",
      "content": "<b>The \"High Perf\" Way (Imperative/Manual):</b> Avoids Stream object overhead and uses bitwise tricks. Faster by nanoseconds, but noisier."
    },
    {
      "type": "code",
      "language": "java",
      "content": "public int sumEvens(List<Integer> numbers) {\n    int sum = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        int n = numbers.get(i);\n        if ((n & 1) == 0) { // Bitwise check is slightly faster than %\n            sum += n;\n        }\n    }\n    return sum;\n}"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>4. Interview Key Takeaways</b></p><ul><li><b>Premature Optimization:</b> Always cite Donald Knuth: \"Premature optimization is the root of all evil.\" Don't make code ugly to save a millisecond that the user won't even notice.</li><li><b>Profiling First:</b> If asked to optimize, your first step is: <i>\"I would use a profiler (like JProfiler or VisualVM) to find the bottleneck.\"</i> Never optimize based on a guess.</li><li><b>Readability is for Maintenance:</b> Code is read 10x more than it is written. \"Clever\" code is a liability because it's harder for a team to fix or update.</li><li><b>Big O vs. Micro-optimizations:</b> In LLD, focus on <b>Algorithmic Efficiency</b> (e.g., changing $O(n^2)$ to $O(n \\log n)$). This gives huge gains without sacrificing readability. Micro-optimizations (like bit-shifting) are rarely worth it.</li></ul>"
    }
  ]
},

  "The Anatomy of a Line": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Friendly Explanation</b></p><ul><li><b>The Analogy:</b> Imagine you are a Contractor (The <b>Thread</b>) working on a job site. You carry a personal, private Clipboard (The <b>Stack</b>) that no one else can see. However, all the actual materials and furniture are stored in a massive, shared Public Warehouse (The <b>Heap</b>).</li><li><b>The Process:</b> When you execute <code>User u = new User();</code>, it is a three-step relay:<ul><li><b>The Placeholder (Left Side):</b> You write \"u\" on your private Clipboard. Right now, itâ€™s just a labelâ€”an empty reference.</li><li><b>The Construction (Right Side):</b> You run to the Public Warehouse, build the <b>User object</b> from scratch, and place it on a specific shelf (e.g., Row 99, Slot B).</li><li><b>The Link (The Equals Sign):</b> You return to your Clipboard and write \"Row 99, Slot B\" next to \"u\". You don't hold the object; you only hold the <b>address</b> to find it.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Actual Explanation & Details</b></p>The JVM performs four distinct physical operations to bridge thread-local and shared memory:<ul><li><b>Instruction Fetch (The Metronome):</b> Every thread has its own <b>Program Counter (PC)</b>. It acts like a bookmark, pointing to the instruction currently running. As the CPU reads the line, the PC \"ticks\" forward.</li><li><b>The \"Left\" Side (Stack Allocation):</b> The thread reserves a tiny, private slot in its current <b>Stack Frame</b> for the variable <code>u</code>. This slot is designed strictly to hold a memory address (a pointer).</li><li><b>The \"Right\" Side (Heap Allocation):</b> The <code>new</code> keyword signals the JVM to find a contiguous block of memory in the <b>Heap</b> and write the actual User object details (fields, metadata) there.</li><li><b>The Assignment (The Bridge):</b> The memory address of the Heap block is returned and written into the <code>u</code> slot on the Stack. <code>u</code> now \"points\" to the object.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Important LLD Takeaway</b></p><ul><li><b>The Thread Boundary:</b> The <b>Stack is Thread-Safe</b> (private), but the <b>Heap is Thread-Unsafe</b> (shared).</li><li><b>The Concurrency Trap:</b> In LLD, bugs rarely occur on Stack variables. They happen because multiple threads might have their own private Stack references pointing to the <b>same shared Heap object</b>. If both try to modify the \"furniture\" at the same time, the system crashes or corrupts data.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    }
  ]
},

 "Identity vs Equality": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Friendly Explanation</b></p><ul><li><b>The Analogy:</b> Imagine two identical <b>House Keys</b>.</li><li><b>Identity (<code>==</code>):</b> This asks: \"Do these two keys open the <b>exact same physical door</b>?\" It doesn't matter if the houses look alike. If Key A opens House #1 and Key B opens House #2, they are not identical (False), even if the houses are twins.</li><li><b>Equality (<code>.equals()</code>):</b> This asks: \"Do the rooms inside look exactly the same?\" If you walk into House #1 and House #2 and they both have the same sofa, TV, and paint color, they are <b>Equal (True)</b>, even though they are different physical houses.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Actual Explanation & Details</b></p>This is a battle between checking the <b>Address (Stack)</b> vs. checking the <b>Data (Heap)</b>.<ul><li><b>1. Identity (<code>==</code>)</b><ul><li><b>What it checks:</b> The Stack.</li><li><b>The Logic:</b> It compares the \"Reference Pointer\" (the memory address). It asks: \"Do variable A and variable B point to the exact same location in memory?\"</li><li><b>The Result:</b> True only if both variables refer to the single, same object instance.</li></ul></li><li><b>2. Equality (<code>.equals()</code>)</b><ul><li><b>What it checks:</b> The Heap.</li><li><b>The Logic:</b> It travels from the Stack to the Heap, enters the object, and compares the actual data fields (like <code>name</code>, <code>id</code>, <code>email</code>).</li><li><b>The Catch:</b> By default, <code>Object.equals()</code> simply uses <code>==</code>. You <b>must override it</b> to define what \"equality\" means for your specific object.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<p><b>Important LLD Takeaway</b></p><ul><li><b>The \"Must-Override\" Rule:</b> In LLD, never trust the default <code>.equals()</code>. If you write a custom class (like <code>User</code>), you must write your own logic, usually comparing unique IDs.</li><li><b>The HashMap Trap (HashCode):</b> If you change how equality works (<code>.equals</code>), you <b>must</b> change how the object creates its ID badge (<code>hashCode</code>).</li><li><b>Why?</b> Collections like <code>HashMap</code> use the hash code to find a \"bucket.\" If two objects are Equal but have different hash codes, the collection will think they belong in different places and \"lose\" them.</li></ul>"
    },
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "text",
      "content": "<b>Simple Cheat Sheet:</b><ul><li>Use <b><code>==</code></b> for <b>Primitives</b> (<code>int</code>, <code>boolean</code>, <code>char</code>) and checking for <code>null</code>.</li><li>Use <b><code>.equals()</code></b> for <b>Everything Else</b> (Strings, Users, Objects).</li></ul>"
    }
  ]
},

  "Object Duplication": {
    "blocks": [
      {
        "type": "text",
        "content": "### Friendly Explanation\n\n**The Analogy: The Spotify Playlist**\n\n* **Shallow Copy:** You \"Share\" your playlist with a friend. You both have the playlist on your own phones, but if you delete a song, it disappears from their phone too. You are two people looking at the same list of songs (references).\n* **Deep Copy:** Your friend manually writes down every song name and creates their own, brand-new playlist from scratch. If you delete a song from your list, their list is untouched. They are completely independent."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "### Actual Explanation & Details\n\nThis is about how deep the \"cloning\" goes in the Heap memory.\n\n#### 1. Shallow Copy\n* **The Physics:** The system creates a new \"Outer Shell\" object (Stack reference is new). However, for any non-primitive data inside (like Lists or other Objects), it just copies the memory addresses.\n* **The Result:** The main objects look different on the Stack, but they point to the <b>same inner objects (children)</b> in the Heap.\n* **The Risk:** If you modify a child object (like changing a user's address inside a cloned profile), that change appears in both copies instantly."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "#### 2. Deep Copy\n* **The Physics:** The system creates a new \"Outer Shell\" AND recursively creates new copies of every single object nested inside it.\n* **The Result:** You get a <b>completely fresh tree of objects</b>.\n* **The Safety:** The two Stack variables point to two entirely separate universes in the Heap. Nothing is shared, ensuring total isolation."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "---\n\n### Important LLD Takeaway\n\n**Defensive Copying (The \"Getter\" Trap):**\n* **The Scenario:** You have a `User` class with a private `List` of orders.\n* **The Mistake:** If you return that list directly (`return this.orders`), external code can `clear()` or modify your private data because they hold a reference to the actual Heap object.\n* **The Fix:** Always return a **Deep Copy** (or an `unmodifiableList`) in your getter methods.\n\n**When to use which?**\n* **Shallow Copy:** Use for speed and memory efficiency. It's safe for **Immutable** data (objects that cannot be changed anyway, like Strings).\n* **Deep Copy:** Use for safety. It is **mandatory in Multi-threaded environments** (like banking or inventory systems) where one thread must not accidentally corrupt another thread's data.\n\n> **Machine Coding Tip:** In an interview (like designing a Cache), if you are storing an object, always store a Deep Copy. If the user changes the original object after putting it in the cache, your cached version should remain consistent and unchanged."
      }
    ]
  }
,

  "The HashCode Contract": {
    "blocks": [
      {
        "type": "text",
        "content": "### Context: Where does this fit?\n\nThis topic belongs to **Data Structures** (HashMaps & Sets). When you use a Key-Value store (HashMap) or a unique list (HashSet), the computer needs a way to find items instantly without scanning the whole list. It uses a \"Two-Step Search\":\n\n1.  **HashCode:** Tells the computer roughly where to look (**Which bucket?**).\n2.  **Equals:** Tells the computer exactly which item it is (**Is this the one?**)."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "### Friendly Explanation\n\n**The Analogy: The Supermarket**\n\n* **HashCode:** This is the **Aisle Number** (e.g., \"Dairy Aisle\").\n* **Equals:** This is the **Product Name** (e.g., \"Strawberry Yogurt\").\n\n**The Rule:**\nIf two tubs of yogurt are identical (`.equals()` is True), they **MUST** be in the same aisle (`hashCode()` must be the same).\n\n**Why?** If you tell a customer, \"Go to Aisle 4 for Yogurt,\" but you accidentally shelved the yogurt in Aisle 9, the customer will go to Aisle 4, see empty shelves, and conclude you are out of stock. The yogurt exists, but it is **lost**."
      },
      {
        "type": "text",
        "content": "### Actual Explanation & Details\n\nThe \"Contract\" is a strict rule to ensure hash-based collections function correctly. \n\n**The Physics of the Search:**\n1.  **Step 1 (The Hash):** The Map calculates the `hashCode` and converts it into a **Bucket Number** (like a drawer index). It jumps straight to that physical location.\n2.  **Step 2 (The Equals):** It opens the drawer. If there are multiple items (a **Collision**), it iterates through them using `.equals()` until a match is found."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "**The 3 Simple Rules:**\n* **Consistency:** The `hashCode` must not be random; it must return the same value every time for the same object state.\n* **Equal = Same Bucket:** If `A.equals(B)`, then `A.hashCode()` **must** equal `B.hashCode()`.\n* **Collisions are Okay:** Two different objects can have the same `hashCode`. Itâ€™s not an error, but it makes the drawer crowded and slows down the search from $O(1)$ to $O(n)$ in that bucket."
      },
      {
        "type": "text",
        "content": "---\n\n### Important LLD Takeaway\n\n**The Golden Rule:**\n**If you override `.equals()`, you MUST override `hashCode()`.** If you break this, you create a \"Phantom Object.\" You can put it in a Map, but `map.get(key)` will return null because the Map is looking in the wrong bucket.\n\n**The \"Do Not Change\" Rule (Immutability):**\n* **The Trap:** Never use a field that changes (like `age` or `lastLogin`) for hashing.\n* **The Disaster:** If an object is placed in \"Bucket 5\" and its state changes such that the hash now points to \"Bucket 6,\" the object becomes **retrieval-proof**. It stays in Bucket 5 forever, causing a **Memory Leak**."
      },
      {
        "type": "text",
        "content": ""
      },
      {
        "type": "text",
        "content": "> **Machine Coding Tip:** When building systems like a Cache, always calculate `hashCode` using only the **Primary Key (ID)** to ensure the hash remains stable throughout the object's lifecycle.\n> `return Objects.hash(this.userId);`"
      }
    ]
  }

  
  

  

  

  

  
}






























