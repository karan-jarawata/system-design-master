{
  "Classes & Objects": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Class:</b> The blueprint or template. It defines the structure (attributes) and capabilities (methods) common to all objects of that type. It does not occupy memory for data (mostly) until instantiated.</li><li><b>Object:</b> The instance of the class. It is a concrete entity created based on the blueprint that occupies memory and holds specific data values.</li></ul><br><p><b>Why use them?</b></p><ul><li><b>Modeling:</b> To represent real-world entities (e.g., <code>User</code>, <code>Payment</code>, <code>Button</code>) in code.</li><li><b>Encapsulation:</b> To bundle data (state) and methods (behavior) together, protecting the internal state from unauthorized access.</li><li><b>Reusability:</b> You write the code once (Class) and create as many instances (Objects) as needed.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>State (Fields/Attributes):</b> Variables that hold data (e.g., color, speed).</li><li><b>Behavior (Methods):</b> Functions that operate on the state (e.g., <code>accelerate()</code>, <code>brake()</code>).</li><li><b>Identity:</b> Every object has a unique identity (memory address), even if two objects have the exact same data values.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Blueprint (Class)\npublic class Car {\n    // State\n    String color;\n    int speed;\n\n    // Constructor (Initialization)\n    public Car(String color) {\n        this.color = color;\n        this.speed = 0;\n    }\n\n    // Behavior\n    public void accelerate() {\n        this.speed += 10;\n    }\n}\n\n// The Usage\npublic class Main {\n    public static void main(String[] args) {\n        // 'c1' is a reference variable, 'new Car()' creates the Object in Heap\n        Car c1 = new Car(\"Red\"); \n        c1.accelerate(); \n        \n        Car c2 = new Car(\"Blue\"); // Distinct identity from c1\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Memory Allocation:</b><ul><li><b>Class:</b> Loaded into Method Area (Metaspace in modern Java).</li><li><b>Object:</b> Allocated on the <b>Heap</b>.</li><li><b>Reference:</b> The variable (e.g., <code>c1</code>) is stored on the <b>Stack</b> and points to the Heap address.</li></ul></li><li><b>The <code>this</code> keyword:</b> Refers to the current object instance. It resolves ambiguity between class fields and parameters.</li><li><b>Object Equality:</b><ul><li><code>==</code> checks if two references point to the same memory address (<b>Identity</b>).</li><li><code>.equals()</code> (if overridden) checks if two objects have the same content (<b>State</b>).</li></ul></li><li><b>Lifecycle:</b> Objects are created via constructors and destroyed by the Garbage Collector (GC) when they are no longer reachable.</li><li><b>Anemic vs. Rich Domain Models:</b><ul><li><b>Anemic:</b> Classes only have data (getters/setters) and no logic. (Common in DTOs).</li><li><b>Rich:</b> Classes contain both data and the business logic that modifies that data. (Preferred in good OOP/LLD).</li></ul></li></ul>"
      }
    ]
  },
  "Interfaces": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>An Interface is a contract:</b> It defines <i>what</i> a class can do, without specifying <i>how</i> it does it. It is a collection of abstract methods (mostly) and constants that a class must implement.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Abstraction:</b> It hides implementation details and exposes only the capability.</li><li><b>Decoupling:</b> You can change the implementation without changing the code that uses it (<i>Dependency Inversion Principle</i>).</li><li><b>Multiple Inheritance:</b> Java classes cannot extend multiple classes, but they can implement multiple interfaces.</li><li><b>Polymorphism:</b> You can treat different objects (e.g., <code>Dog</code>, <code>Cat</code>) as the same type (e.g., <code>Animal</code>) if they implement the same interface.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Methods:</b> Methods without a body (implicitly <code>public abstract</code>).</li><li><b>Constants:</b> Variables are implicitly <code>public static final</code>.</li><li><b>Java 8+ Evolution:</b><ul><li><b>Default Methods:</b> Methods with a body (using <code>default</code> keyword) to allow adding new methods without breaking existing implementations.</li><li><b>Static Methods:</b> Utility methods related to the interface.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// The Contract\ninterface PaymentProcessor {\n    void processPayment(double amount); // Abstract method\n    \n    // Java 8 Default method (Backward compatibility)\n    default void logTransaction() {\n        System.out.println(\"Logging tx...\");\n    }\n}\n\n// The Implementation A\nclass PaypalProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via PayPal: \" + amount);\n    }\n}\n\n// The Implementation B\nclass StripeProcessor implements PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Paid via Stripe: \" + amount);\n    }\n}\n\n// Usage (Polymorphism)\nclass CheckoutService {\n    // We program to the Interface, not the implementation\n    PaymentProcessor processor; \n\n    public CheckoutService(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>\"Program to an Interface, not an Implementation\":</b> This is a golden rule in design patterns. Always use the interface type for variable references (e.g., <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>).</li><li><b>Interface Segregation Principle (ISP):</b> Clients should not be forced to depend on interfaces they do not use. It's better to have many specific interfaces (e.g., <code>Readable</code>, <code>Writable</code>) than one general-purpose interface (e.g., <code>FileHandler</code>).</li><li><b>Interface vs. Abstract Class:</b><ul><li><b>Interface:</b> Defines \"Can-Do\" capability (e.g., <code>Runnable</code>, <code>Serializable</code>). Supports multiple implementations.</li><li><b>Abstract Class:</b> Defines \"Is-A\" relationship (e.g., <code>Vehicle</code>, <code>Mammal</code>). Shares code/state among related classes.</li></ul></li><li><b>Marker Interfaces:</b> Interfaces with no methods (e.g., <code>Serializable</code>, <code>Cloneable</code>). They provide metadata to the compiler or runtime that the class is special.</li><li><b>Functional Interface:</b> An interface with exactly one abstract method. Used heavily in Lambda expressions (e.g., <code>Runnable</code>, <code>Comparator</code>).</li></ul>"
      }
    ]
  },
  "Inheritance": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Inheritance</b> is the mechanism by which one class (Child/Subclass) acquires the properties (fields) and behaviors (methods) of another class (Parent/Superclass). It establishes an \"Is-A\" relationship.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Code Reusability:</b> Write common code once in the parent class and reuse it in multiple child classes.</li><li><b>Extensibility:</b> You can extend existing logic without modifying the original class (<i>Open/Closed Principle</i>).</li><li><b>Method Overriding:</b> Child classes can provide a specific implementation of a method already defined in the parent class.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Superclass (Parent/Base):</b> The class whose features are inherited.</li><li><b>Subclass (Child/Derived):</b> The class that inherits the other class.</li><li><b><code>extends</code> Keyword:</b> Used in Java to inherit from a class.</li><li><b><code>super</code> Keyword:</b> Used to access members (methods/constructors) of the immediate parent class.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Parent Class\nclass Vehicle {\n    protected String brand = \"Ford\"; // protected: accessible to subclasses\n    public void honk() {\n        System.out.println(\"Tuut, tuut!\");\n    }\n}\n\n// Child Class\nclass Car extends Vehicle {\n    private String modelName = \"Mustang\";\n    \n    // Overriding parent behavior\n    @Override \n    public void honk() {\n        super.honk(); // Calls parent's honk first\n        System.out.println(\"Honk from \" + modelName);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.honk(); // OUTPUT: Tuut, tuut! \\n Honk from Mustang\n        // myCar.brand is accessible here only if Main is in same package or subclass\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Diamond Problem:</b> Java does not support Multiple Inheritance with Classes (inheriting from two classes that have the same method). It solves this via Interfaces.</li><li><b>Liskov Substitution Principle (LSP):</b> A child class must be substitutable for its parent class without breaking the application. If <code>Dog</code> extends <code>Animal</code>, you should be able to use <code>Dog</code> anywhere <code>Animal</code> is expected.</li><li><b>Constructors are NOT inherited:</b> But the child class constructor must call the parent constructor (implicitly or explicitly via <code>super()</code>) as the first statement.</li><li><b><code>final</code> Class:</b> If a class is marked <code>final</code>, it cannot be inherited (e.g., <code>String</code> class in Java).</li><li><b>Composition over Inheritance:</b> In modern LLD, prefer Composition (\"Has-A\") over Inheritance (\"Is-A\") if the relationship is not strictly hierarchical. Inheritance creates tight coupling; composition is more flexible.</li></ul>"
      }
    ]
  },
  "Polymorphism": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Polymorphism</b> (Greek for \"many forms\") is the ability of a single interface or method name to support different underlying forms (types or implementations). It allows objects of different classes to be treated as objects of a common superclass.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Flexibility:</b> You can write code that works with a general type (e.g., <code>Shape</code>) and it will automatically work with any new specific types you add later (e.g., <code>Pentagon</code>) without changing the code.</li><li><b>Clean Code:</b> Reduces <code>if-else</code> or <code>switch</code> statements checking for types.</li><li><b>Decoupling:</b> The caller doesn't need to know the specific class of the object it's working with.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Compile-time Polymorphism (Static Binding):</b><ul><li>Achieved via <b>Method Overloading</b>.</li><li>Same method name, different parameters (signature) within the same class.</li><li>Resolved by the compiler.</li></ul></li><li><b>Runtime Polymorphism (Dynamic Binding):</b><ul><li>Achieved via <b>Method Overriding</b>.</li><li>Same method name and parameters in a Parent and Child class.</li><li>Resolved at runtime based on the actual object created.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// 1. Compile-time (Overloading)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n\n// 2. Runtime (Overriding)\nclass Animal {\n    void speak() { System.out.println(\"Animal makes a sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void speak() { System.out.println(\"Woof\"); }\n}\n\nclass Cat extends Animal {\n    @Override\n    void speak() { System.out.println(\"Meow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Upcasting: Parent Reference -> Child Object\n        Animal myPet = new Dog(); \n        \n        // The method called depends on the OBJECT (Dog), not the reference (Animal)\n        myPet.speak(); // Output: Woof\n        \n        myPet = new Cat();\n        myPet.speak(); // Output: Meow\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Upcasting:</b> Assigning a Child object to a Parent reference (e.g., <code>Animal a = new Dog()</code>). This is safe and implicit.</li><li><b>Downcasting:</b> Assigning a Parent reference back to a Child reference (e.g., <code>Dog d = (Dog) a</code>). This requires an explicit cast and an <code>instanceof</code> check to avoid <code>ClassCastException</code>.</li><li><b>Dynamic Method Dispatch:</b> This is the mechanism Java uses at runtime to figure out which version of an overridden method to call.</li><li><b>Static methods are NOT polymorphic:</b> If you define a static method with the same name in Parent and Child, the Child hides the Parent's method (<i>Method Hiding</i>), but it does not override it. The method called depends on the reference type, not the object.</li><li><b>Fields are NOT polymorphic:</b> If a Child defines a variable with the same name as the Parent, the variable accessed depends on the reference type.</li></ul>"
      }
    ]
  },
  "Abstraction": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstraction</b> is the process of hiding the complex implementation details and showing only the essential features of an object. It focuses on <i>what</i> an object does instead of <i>how</i> it does it.</li><li><b>Analogy:</b> Think of a car. You use the steering wheel and pedals (<b>Abstraction/Interface</b>) to drive. You don't need to know how the fuel injection or combustion engine (<b>Implementation</b>) works to operate it.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Reduces Complexity:</b> It simplifies the interaction for the user (or client code) by filtering out unnecessary details.</li><li><b>Security:</b> Hides internal data and logic that shouldn't be touched directly.</li><li><b>Maintainability:</b> You can change the complex internal logic (e.g., upgrade the engine) without changing the simple interface (the steering wheel), so client code doesn't break.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated on its own (0-100% abstraction). It can have both abstract methods (no body) and concrete methods (with body).</li><li><b>Interface:</b> A pure template (100% abstraction prior to Java 8). Defines only method signatures.</li><li><b>Access Modifiers:</b> Keywords like <code>private</code> and <code>protected</code> help enforce abstraction by hiding internal members.</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// Abstract Class - partial abstraction\nabstract class BankService {\n    // Abstract method: Logic hidden, must be defined by child\n    abstract void calculateInterest(); \n\n    // Concrete method: Common logic shared by all\n    void login() {\n        System.out.println(\"User Logged in\");\n    }\n}\n\nclass SavingsAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 4%\");\n    }\n}\n\nclass CurrentAccount extends BankService {\n    @Override\n    void calculateInterest() {\n        System.out.println(\"Interest is 0%\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // BankService b = new BankService(); // ERROR: Cannot instantiate abstract class\n        \n        BankService myBank = new SavingsAccount();\n        myBank.login();             // Shared logic\n        myBank.calculateInterest(); // Specific logic\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation</b> is about hiding data (bundling data + methods).</li><li><b>Abstraction</b> is about hiding implementation complexity (design level).</li></ul></li><li><b>\"Is-A\" Relationship:</b> Abstract classes are still classes. Use them when child classes share a lot of code but also need specific behavior (e.g., <code>Bird</code> is an abstract class, <code>Sparrow</code> and <code>Penguin</code> extend it).</li><li><b>The 100% Rule:</b> Before Java 8, Interfaces provided 100% abstraction. Now, with default methods, this line is slightly blurred, but conceptually they are still pure contracts.</li><li><b>Design Decision:</b> If you need to add a new method in the future:<ul><li><b>Abstract Class:</b> You can add a concrete method with a default implementation, and existing child classes will work fine.</li><li><b>Interface:</b> Adding a new abstract method breaks all implementing classes (unless you use a <code>default</code> method).</li></ul></li></ul>"
      }
    ]
  },
  "Encapsulation": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Encapsulation</b> is the bundling of data (variables) and methods (functions) that operate on that data into a single unit (Class). Crucially, it involves restricting direct access to some of an object's components, often referred to as \"<i>Data Hiding</i>\".</li><li><b>Analogy:</b> Think of a medical capsule: The medicine (data) is enclosed inside the capsule shell (methods), preventing it from being consumed directly or contaminated.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Control & Validation:</b> You can validate data before assigning it. For example, preventing a generic age variable from being set to -5.</li><li><b>Security:</b> Hides internal implementation details and protects the object's integrity.</li><li><b>Flexibility (Loose Coupling):</b> You can change the internal data structure (e.g., changing a variable from <code>String</code> to <code>StringBuilder</code>) without breaking the code that uses the class, as long as the public methods remain the same.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Access Modifiers:</b> The tools used to enforce encapsulation.<ul><li><code>private</code>: Visible only within the class (Best for state).</li><li><code>protected</code>: Visible to package + subclasses.</li><li><code>public</code>: Visible to everyone (Best for methods/interface).</li><li><code>(default/package-private)</code>: Visible only within the package.</li></ul></li><li><b>Getters (Accessors):</b> Public methods to read private data.</li><li><b>Setters (Mutators):</b> Public methods to modify private data (usually with validation logic).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class User {\n    // 1. Data is Private (Hidden)\n    private String username;\n    private int age;\n\n    // 2. Public Constructor\n    public User(String username, int age) {\n        this.username = username;\n        setAge(age); // Use setter to enforce logic even during creation\n    }\n\n    // 3. Public Getters (Read-only access)\n    public String getUsername() {\n        return username;\n    }\n\n    // 4. Public Setters (Controlled Write access)\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age provided\");\n            // Optionally throw exception\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        User u = new User(\"John\", 25);\n        // u.age = -5; // ERROR: usage of private field\n        u.setAge(-5);  // Output: Invalid age provided. Data remains safe.\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Getters/Setters are NOT mandatory:</b> Pure encapsulation isn't just generating getters and setters for every field (that makes it anemic). True encapsulation often involves methods that do things (e.g., <code>activateAccount()</code> instead of <code>setStatus(\"Active\")</code>).</li><li><b>Immutability:</b> A powerful form of encapsulation. If you make all fields <code>private final</code> and provide no setters, the object state cannot change once created. This makes the code thread-safe and predictable (e.g., <code>String</code> class).</li><li><b>\"Tell, Don't Ask\":</b> A design principle related to encapsulation. Instead of asking an object for its data to perform a calculation (if <code>user.getAge() > 18</code>), tell the object to do it (if <code>user.isAdult()</code>).</li><li><b>Encapsulation vs. Abstraction:</b><ul><li><b>Encapsulation:</b> Hiding Information (State).</li><li><b>Abstraction:</b> Hiding Complexity (Implementation).</li></ul></li></ul>"
      }
    ]
  },
  "Access Modifiers": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>Access modifiers</b> are keywords that define the scope and visibility of a class, constructor, variable, method, or data member. They determine who can see and use a specific part of your code.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Encapsulation:</b> They are the primary tool to implement encapsulation (hiding internal state).</li><li><b>Security:</b> Prevents sensitive data or critical logic from being tampered with by external classes.</li><li><b>Maintainability:</b> By restricting access, you limit the \"blast radius\" of changes. If a method is private, you can change it freely knowing no other class relies on it.</li></ul><br><p><b>Key Components (The 4 Levels):</b></p><ul><li><b>Private (<code>private</code>):</b> Only within the Same Class. <br><i>Analogy: Your diary. Only you can read it.</i></li><li><b>Default (none):</b> Within the Same Package only. (Package-Private). <br><i>Analogy: Family fridge. Accessible to everyone in the house.</i></li><li><b>Protected (<code>protected</code>):</b> Same Package + Subclasses (even in different packages). <br><i>Analogy: Family inheritance. Kids get it even if they move out.</i></li><li><b>Public (<code>public</code>):</b> Everywhere (Global). <br><i>Analogy: A billboard. Visible to the world.</i></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "// PACKAGE A\npackage com.test.a;\npublic class Parent {\n    public int publicVar = 1;\n    protected int protectedVar = 2;\n    int defaultVar = 3;   // No keyword = Default\n    private int privateVar = 4;\n    \n    public void show() {\n        // All accessible here\n        System.out.println(privateVar); \n    }\n}\n\n// PACKAGE B\npackage com.test.b;\nimport com.test.a.Parent;\n\nclass Child extends Parent {\n    void accessTest() {\n        System.out.println(publicVar);    // OK\n        System.out.println(protectedVar); // OK (Child Class)\n        // System.out.println(defaultVar);   // ERROR: Diff Package\n        // System.out.println(privateVar);   // ERROR: Private\n    }\n}\n\nclass Stranger {\n    void accessTest() {\n        Parent p = new Parent();\n        System.out.println(p.publicVar);  // OK\n        // System.out.println(p.protectedVar); // ERROR: Not a child\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Principle of Least Privilege:</b> Always start with the most restrictive modifier (<code>private</code>) and open it up (<code>protected</code> -> <code>public</code>) only when absolutely necessary. This reduces coupling.</li><li><b>Class vs. Member:</b><ul><li>Top-level classes can only be <code>public</code> or <code>default</code> (package-private). They cannot be <code>private</code> or <code>protected</code>.</li><li>Nested/Inner classes can be all four.</li></ul></li><li><b>Method Overriding Rule:</b> When overriding a method in a child class, you cannot reduce the visibility. If Parent is <code>protected</code>, Child must be <code>protected</code> or <code>public</code>. It cannot be <code>private</code>.</li><li><b>Interface Members:</b><ul><li>Variables in interfaces are implicitly <code>public static final</code>.</li><li>Methods in interfaces are implicitly <code>public</code> (unless <code>private</code> in Java 9+).</li></ul></li></ul>"
      }
    ]
  },
  "Object Lifecycle": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p><ul><li><b>The Object Lifecycle</b> describes the series of states an object goes through from its <b>Creation</b> (instantiation), to its <b>Usage</b> (performing actions), and finally to its <b>Destruction</b> (garbage collection/memory deallocation).</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Memory Management:</b> Understanding the lifecycle helps prevent <i>Memory Leaks</i> (objects staying in memory when no longer needed).</li><li><b>Resource Management:</b> Ensures external resources (file handles, database connections) are opened and closed correctly.</li><li><b>Performance:</b> Knowing how objects are promoted (e.g., from Young to Old Generation in Java) helps in tuning application performance.</li></ul><br><p><b>Key Components (The 3 Stages):</b></p><ul><li><b>Creation (Initialization):</b><ul><li><b>Loading:</b> The <code>.class</code> file is loaded into the Method Area.</li><li><b>Allocation:</b> Memory is allocated on the <b>Heap</b> for the object.</li><li><b>Initialization:</b> The constructor is called to initialize the state.</li></ul></li><li><b>Usage (Live):</b> The object is referenced by a variable on the <b>Stack</b> or by another live object. It actively performs tasks.</li><li><b>Destruction (Death):</b><ul><li><b>Unreachable:</b> All references to the object are removed (e.g., set to <code>null</code> or out of scope).</li><li><b>Garbage Collection (GC):</b> The GC identifies the object as unreachable and reclaims the memory.</li></ul></li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "class Report {\n    String data;\n    \n    public Report() {\n        System.out.println(\"1. Object Created (Constructor)\");\n    }\n    \n    public void print() {\n        System.out.println(\"2. Object in Use\");\n    }\n\n    // Deprecated in modern Java, but good for understanding lifecycle concepts\n    @Override\n    protected void finalize() { \n        System.out.println(\"3. Object Destroyed/GC'd\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Step 1: Creation\n        Report r = new Report(); \n        \n        // Step 2: Usage\n        r.print();\n        \n        // Step 3: Making Eligible for Destruction\n        r = null; // Reference broken. Object is now \"Unreachable\"\n        \n        // Requesting GC (Note: This is just a request, not a command)\n        System.gc(); \n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Stack vs. Heap:</b><ul><li><b>Local Variables</b> (references) live on the <b>Stack</b>.</li><li><b>Objects</b> (actual data) live on the <b>Heap</b>.</li><li>When a stack frame (method) ends, the references pop off, leaving the heap objects eligible for GC if no other references exist.</li></ul></li><li><b>Reachability:</b> An object is only garbage collected if there is no chain of references leading to it from a \"GC Root\" (active thread, static variable, local variable).</li><li><b>Generational GC:</b><ul><li><b>Eden Space:</b> Where new objects are born.</li><li><b>Survivor Space:</b> Objects that survive a GC cycle.</li><li><b>Old/Tenured Gen:</b> Long-lived objects (caches, singletons) move here.</li></ul></li><li><b><code>finalize()</code> is Deprecated:</b> Never rely on <code>finalize()</code> for cleanup (it's unpredictable). Use <code>try-with-resources</code> (<code>AutoCloseable</code> interface) for deterministic cleanup of resources like streams or connections.</li><li><b>Static Variables:</b> These live for the entire life of the application (Class Lifecycle), effectively acting as GC Roots. Be carefulâ€”they are a common source of memory leaks.</li></ul>"
      }
    ]
  },
  "Stack vs Heap": {
    "blocks": [
      {
        "type": "text",
        "content": "<p><b>Core Concept:</b></p>These are the two main areas of memory used by a program.<br><ul><li><b>Stack:</b> A structured, temporary scratchpad for method execution. It stores local primitives and reference variables. It follows the <b>LIFO</b> (Last-In, First-Out) order.</li><li><b>Heap:</b> A large, unstructured pool for dynamic data storage. It stores actual <b>Objects</b> and JRE classes. Memory here is managed by the Garbage Collector.</li></ul><br><p><b>Why use them? (The Roles)</b></p><ul><li><b>Stack (Control Flow):</b> Used to track \"where am I in the code?\". It manages function calls, parameters, and return addresses automatically. When a method finishes, its block is instantly cleared.</li><li><b>Heap (Data Persistence):</b> Used when data needs to live longer than a single function call or when the size of data isn't known at compile time (e.g., a list that grows based on user input).</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Structure:</b> Stack is Linear (LIFO); Heap is Hierarchical/Complex (Young/Old Gen).</li><li><b>Visibility:</b> Stack is <b>Thread-safe</b> (private to each thread). Heap is <b>Shared</b> (all threads share the same Heap, requires synchronization).</li><li><b>Speed:</b> Stack has extremely fast access. Heap is slower due to complex allocation and lookup.</li><li><b>Life Span:</b> Stack is short-lived (method execution). Heap is long-lived (until GC).</li></ul>"
      },
      {
        "type": "code",
        "language": "java",
        "content": "public class MemoryDemo {\n    public static void main(String[] args) { // Main Stack Frame starts\n        int x = 10;           // 'x' (primitive) stored directly on Stack\n        int y = 20;           // 'y' (primitive) stored directly on Stack\n        \n        Person p = new Person(\"Alice\"); \n        // 1. 'new Person(\"Alice\")' -> Creates Object in HEAP\n        // 2. 'p' (reference variable) -> Stored on STACK, pointing to Heap address\n        \n        print(p); \n    } // Main Stack Frame pops off (x, y, p are gone). Heap object becomes eligible for GC.\n\n    public static void print(Person p) { // New Stack Frame created\n        // 'p' here is a copy of the reference, pointing to same Heap Object\n        System.out.println(p.name);\n    }\n}"
      },
      {
        "type": "text",
        "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The References Rule:</b><ul><li><b>Primitives (int, boolean):</b> Value sits directly on the <b>Stack</b> (if local).</li><li><b>Objects (String, List, Car):</b> The <b>Reference</b> sits on the Stack, but the <b>Actual Data</b> sits in the <b>Heap</b>.</li></ul></li><li><b>The Errors:</b><ul><li><b>StackOverflowError:</b> Happens due to deep/infinite recursion. The stack runs out of space for new frames.</li><li><b>OutOfMemoryError (Java Heap Space):</b> Happens when you create too many objects and the GC cannot free up enough space.</li></ul></li><li><b>String Pool:</b> A special area inside the Heap to store String literals for reusability.</li><li><b>Thread Safety:</b> Since Stack is private to a thread, local variables are inherently thread-safe. Heap objects are shared, so if multiple threads modify the same object, you need <b>Locks/Synchronization</b>.</li></ul>"
      }
    ]
  },
  "Association": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Association</b> is a structural relationship that defines a link between objects of one class and objects of another. It represents a \"Has-A\" or \"Uses-A\" relationship.</li><li>It is the most general term for connection; <b>Aggregation</b> and <b>Composition</b> are specific, stricter types of Association.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Modularity:</b> It allows classes to be independent but still interact. A <code>Teacher</code> class doesn't need to be inside a <code>Student</code> class, but they need to be associated.</li><li><b>Reusability:</b> You can reuse independent classes in different relationships (e.g., a <code>User</code> class can be associated with <code>Order</code> in one context and <code>Comment</code> in another).</li><li><b>Navigation:</b> It defines the direction of data flow (Unidirectional vs. Bidirectional).</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Cardinality (Multiplicity):</b> Defines \"how many.\"<ul><li><b>One-to-One:</b> One User has one Profile.</li><li><b>One-to-Many:</b> One Teacher teaches multiple Students.</li><li><b>Many-to-Many:</b> Many Students take many Courses.</li></ul></li><li><b>Direction:</b><ul><li><b>Unidirectional:</b> <code>Order</code> knows about <code>Customer</code>, but <code>Customer</code> doesn't strictly need to track every <code>Order</code> object internally.</li><li><b>Bidirectional:</b> Both classes hold references to each other (requires careful management to avoid infinite loops).</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Unidirectional Association (Bank -> Employee)\nclass Employee {\n    String name;\n    public Employee(String name) { this.name = name; }\n}\n\nclass Bank {\n    String name;\n    // Association: Bank \"Has-Many\" Employees\n    List<Employee> employees; \n\n    public Bank(String name) {\n        this.name = name;\n        this.employees = new ArrayList<>();\n    }\n    \n    public void addEmployee(Employee e) {\n        employees.add(e);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Employee e1 = new Employee(\"Alice\");\n        Bank b1 = new Bank(\"HDFC\");\n        \n        // Establishing the link\n        b1.addEmployee(e1); \n        \n        // Note: If Bank is destroyed, Employee CAN exist independently \n        // (This distinguishes generic Association/Aggregation from Composition)\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Lifecycle dependency is key:</b> In a generic Association, there is no owner. The objects have their own independent lifecycles. If you delete one, the other survives.</li><li><b>Reflexive Association:</b> A class can be associated with itself.<br><i>Example:</i> An <code>Employee</code> class having a field <code>supervisor</code> which is also of type <code>Employee</code>.</li><li><b>Association vs. Dependency:</b><ul><li><b>Association:</b> Stronger. Class A holds a reference to Class B as a field/variable (state).</li><li><b>Dependency:</b> Weaker. Class A uses Class B only as a parameter in a method or a local variable, but doesn't hold onto it.</li></ul></li><li><b>Mapping:</b> In databases (SQL), associations are implemented using Foreign Keys and Join Tables.</li></ul>"
    }
  ]
},
  "Aggregation": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Aggregation</b> is a specialized form of Association. It represents a \"Whole-Part\" relationship (Has-A), but with <b>Weak Ownership</b>.</li><li>The \"Part\" (Child) can exist independently of the \"Whole\" (Parent). If the Parent is destroyed, the Child survives.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Shared Resources:</b> Use it when an object needs to be part of a group but might belong to multiple groups or exist on its own.</li><li><b>Decoupled Lifecycles:</b> When destroying the container shouldn't destroy the items inside.</li><li><b>Real-world analogy:</b> A Team and Players. If the Team is dissolved, the Players don't die; they become free agents or join other teams.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Container (Whole):</b> Holds the reference to the collection of items.</li><li><b>The Component (Part):</b> The item being held.</li><li><b>Independent Lifecycle:</b> The key differentiator from Composition. The child is usually passed into the parent via the constructor or a setter (external creation).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Player {\n    String name;\n    public Player(String name) { this.name = name; }\n}\n\nclass Team {\n    String teamName;\n    List<Player> players; // Aggregation\n\n    public Team(String teamName, List<Player> players) {\n        this.teamName = teamName;\n        this.players = players; // Players are created OUTSIDE and passed in\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Create Parts independently\n        Player p1 = new Player(\"Dhoni\");\n        Player p2 = new Player(\"Kohli\");\n\n        // 2. Create Whole and add Parts\n        List<Player> squad = new ArrayList<>(Arrays.asList(p1, p2));\n        Team india = new Team(\"India\", squad);\n        \n        // 3. Destruction Scenario\n        india = null; // Team is destroyed\n        \n        // p1 and p2 STILL EXIST. They were not destroyed with the Team.\n        System.out.println(p1.name); // Works fine\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with an <b>Empty (White) Diamond</b> on the container side.<br><code>Team &lt;&gt;------- Player</code></li><li><b>Parameter Injection:</b> In Aggregation, objects are usually passed into the class (Dependency Injection) rather than being created inside the class using <code>new</code>.</li><li><b>Vs. Composition:</b> Ask this question: \"If I delete the Parent, does the Child die too?\"<ul><li><b>If No -> Aggregation</b> (e.g., Car and Driver).</li><li><b>If Yes -> Composition</b> (e.g., Car and Engine - conceptually, for that specific car).</li></ul></li></ul>"
    }
  ]
},
  "Composition": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Composition</b> is a restricted form of Aggregation. It represents a strong \"Whole-Part\" relationship.</li><li><b>Strong Ownership:</b> The \"Part\" (Child) belongs exclusively to the \"Whole\" (Parent).</li><li><b>Dependent Lifecycle:</b> If the Parent is destroyed, the Child is also destroyed. The child cannot exist independently.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Logical Consistency:</b> Use it when the parts have no meaning outside the whole (e.g., a <code>Room</code> has no identity without a <code>House</code>).</li><li><b>Encapsulation:</b> The parent strictly controls the creation and access of the child components.</li><li><b>Flexibility:</b> It is preferred over Inheritance (\"Composition over Inheritance\") because it allows you to assemble complex behaviors dynamically without the rigidity of class hierarchies.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>The Owner:</b> The class that manages the lifecycle.</li><li><b>Internal Creation:</b> The child objects are usually created inside the parent's constructor using <code>new</code>. They are not passed in from the outside.</li><li><b>Cascading Delete:</b> Logic that ensures cleaning up the parent cleans up the children.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class Room {\n    String type;\n    public Room(String type) { this.type = type; }\n}\n\nclass House {\n    private final List<Room> rooms; // Composition\n\n    public House() {\n        // Rooms are created INSIDE the House. \n        // If House dies, nobody else holds a reference to these specific rooms.\n        this.rooms = new ArrayList<>();\n        this.rooms.add(new Room(\"Bedroom\"));\n        this.rooms.add(new Room(\"Kitchen\"));\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        House myHouse = new House();\n        \n        // 1. Destruction Scenario\n        myHouse = null; \n        \n        // The 'Room' objects created inside myHouse are now unreachable.\n        // They will be Garbage Collected along with the House.\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>UML Symbol:</b> Represented by a line with a <b>Filled (Black) Diamond</b> on the container side.<br><code>House &lt;#&gt;------- Room</code></li><li><b>The \"Death\" Test:</b><ul><li>If you delete the <code>Order</code>, do the <code>LineItems</code> disappear? <b>Yes (Composition)</b>.</li><li>If you delete the <code>School</code>, do the <code>Students</code> disappear? <b>No (Aggregation)</b>.</li></ul></li><li><b>Composition over Inheritance:</b> This is a major design principle.<ul><li><b>Inheritance:</b> You inherit everything (good and bad) and it's static (fixed at compile time).</li><li><b>Composition:</b> You only include what you need, and you can change behavior at runtime (by swapping the composed object).</li></ul></li></ul>"
    }
  ]
},
  "Composition over Inheritance": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This principle states that classes should achieve code reuse by containing instances of other classes (Composition) rather than inheriting from them.</li><li>It attacks the biggest flaw of inheritance: <b>Tight Coupling</b>.</li></ul><br><p><b>The \"Banana, Gorilla & Jungle\" Problem:</b></p>(This is the most important analogy to remember)<br>Joe Armstrong (creator of Erlang) famously explained why Inheritance is dangerous:<br><i>\"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\"</i><ul><li><b>The Banana:</b> The small piece of functionality you actually needed (e.g., a method <code>calculateTax()</code>).</li><li><b>The Gorilla:</b> The Parent Class (<code>TaxCalculator</code>) that owns the method.</li><li><b>The Jungle:</b> The entire inheritance tree and all the extra data/dependencies the Parent Class carries with it (Grandparents, heavy database connections, unnecessary state).</li></ul><br>Inheritance forces you to load the whole jungle just to eat one banana. <b>Composition lets you just pick the banana.</b><br><br><p><b>Why use Composition?</b></p><ul><li><b>Precision:</b> You pick exactly the behaviors you want. You don't inherit \"baggage\" (variables or methods you don't need).</li><li><b>Flexibility:</b> You can change behaviors at runtime.<br><i>Inheritance:</i> You are born a Dog. You stay a Dog forever.<br><i>Composition:</i> You are an entity holding a <code>SoundBehavior</code>. You can swap it from \"Bark\" to \"Howl\" instantly.</li><li><b>Safety:</b> You avoid the <b>Fragile Base Class</b> problem. Changes in a superclass won't unexpectedly break your subclass because you aren't inextricably linked to its internal structure.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Jungle Way (Inheritance)\n\n// The Jungle (Huge, heavy class)\nclass BigHeavyService {\n    void connectDB() { ... } // Heavy logic\n    void logAnalytics() { ... } // Heavy logic\n    int add(int a, int b) { return a + b; } // THE BANANA (The only thing we want)\n}\n\n// The Gorilla holding the Banana\nclass MyCalculator extends BigHeavyService {\n    // I just wanted 'add()', but now I have DB connections and Analytics \n    // attached to my simple Calculator object. This is wasteful and risky.\n}"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// The Banana Way (Composition)\n\nclass Adder {\n    int add(int a, int b) { return a + b; } // Just the Banana\n}\n\nclass MyCalculator {\n    private Adder adder = new Adder(); // HAS-A relationship\n    \n    // I delegate the work to the specific component I need.\n    // No Jungle attached.\n    int calculate(int a, int b) {\n        return adder.add(a, b);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember:</b></p><ul><li><b>Is-A vs Has-A:</b><ul><li>If you can say \"A Manager is a Person\" -> Inheritance might be okay.</li><li>If you can say \"A Car has an Engine\" -> Use Composition.</li></ul></li><li><b>The \"Final\" Solution:</b> Many modern languages (like Kotlin or Rust) or libraries make classes <code>final</code> by default to force you to use Composition instead of trying to inherit.</li><li><b>Testing is Easier:</b> In Composition, you can easily mock the <code>Adder</code> component to test <code>MyCalculator</code>. In Inheritance, you often can't mock the Parent class easily without initializing its complex state.</li></ul>"
    }
  ]
},
  "Diamond Problem": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>The Diamond Problem</b> is an ambiguity that arises in Multiple Inheritance when a class inherits from two classes that both descend from the same superclass.</li><li>If the top superclass (\"Grandparent\") has a method, and both intermediate classes (\"Parents\") override it, the final subclass (\"Child\") doesn't know which version of the method to inherit.</li></ul><br><p><b>The Problem (Why is it tricky?)</b></p><ul><li><b>Ambiguity:</b> If Class B and Class C both extend Class A and override method <code>run()</code>, and Class D extends both B and C... when you call <code>d.run()</code>, should it run B's version or C's version? The compiler cannot decide.</li><li><b>Complexity:</b> It complicates method dispatch and memory layout (e.g., in C++, it can lead to multiple copies of the Grandparent class in memory unless \"virtual inheritance\" is used).</li></ul><br><p><b>Key Components (The Shape):</b></p><ul><li>The inheritance hierarchy looks like a diamond:<br><b>A</b> (Top / Grandparent)<br><b>B extends A</b> & <b>C extends A</b> (Middle / Parents)<br><b>D extends B, C</b> (Bottom / Child)</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "interface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A {\n    @Override\n    default void hello() { System.out.println(\"Hello from C\"); }\n}\n\n// PROBLEM: D implements both B and C. Both have 'hello()'.\n// COMPILER ERROR: \"class D inherits unrelated defaults for hello()...\"\nclass D implements B, C {\n    \n    // RESOLUTION: You MUST override the method to resolve ambiguity.\n    @Override\n    public void hello() {\n        // Option 1: Define new logic\n        // System.out.println(\"Hello from D\"); \n        \n        // Option 2: Explicitly choose a parent using 'super'\n        B.super.hello(); \n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        new D().hello(); // Output: Hello from B\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Why Java banned multiple class inheritance:</b> Specifically to avoid this ambiguity and keep the language simple (simplicity was a major design goal of Java vs. C++).</li><li><b>Interface Resolution Rules:</b> If there is a conflict between interfaces:<ul><li><b>Classes win:</b> If a class extends a Parent and implements an Interface, the Parent's method always wins (Rule of \"Class wins\").</li><li><b>Sub-interfaces win:</b> If B extends A, B is more specific.</li><li><b>Explicit Override:</b> If there is no clear winner (like the code above), the compiler forces you to override and clarify.</li></ul></li><li><b>Composition is the fix:</b> If you genuinely need behavior from two different classes, don't try to inherit from both. Have one class as a field inside your new class (Composition).</li></ul>"
    }
  ]
},
  "Dynamic Dispatch": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Dynamic Dispatch</b> (or Dynamic Method Dispatch) is the mechanism by which a call to an overridden method is resolved at <b>runtime</b> rather than compile-time.</li><li>The compiler doesn't know which method implementation to call; the JVM decides at the last moment based on the <i>actual object</i> being referred to, not the variable type.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Enables Polymorphism:</b> It is the technical engine that makes runtime polymorphism possible.</li><li><b>Extensibility:</b> You can add new subclasses (e.g., a new plugin) without recompiling the code that calls the plugin methods. The dispatch mechanism automatically finds the new code.</li><li><b>Cleaner Code:</b> Replaces massive <code>if (obj instanceof TypeA) ... else if (obj instanceof TypeB)</code> blocks.</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Upcasting:</b> A Reference Variable of a Parent class holding an Object of a Child class.</li><li><b>Overriding:</b> The Child class must provide a specific implementation of a method defined in the Parent.</li><li><b>Virtual Method Table (vtable):</b> (Under the hood) The JVM maintains a table of method addresses for each class. When a method is called, it looks up the address in this table for the specific object type to find the correct code.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "class GameCharacter {\n    void attack() { System.out.println(\"Basic Punch\"); }\n}\n\nclass Warrior extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Sword Slash\"); }\n}\n\nclass Archer extends GameCharacter {\n    @Override\n    void attack() { System.out.println(\"Shoot Arrow\"); }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // 1. Compile time: 'c' is just a GameCharacter reference.\n        GameCharacter c;\n        \n        // 2. Runtime: The object is actually a Warrior.\n        c = new Warrior();\n        \n        // 3. Dynamic Dispatch: JVM checks heap object (Warrior) -> calls Sword Slash\n        c.attack(); \n        \n        // 4. Runtime: The object changes to Archer.\n        c = new Archer();\n        \n        // 5. Dynamic Dispatch: JVM checks heap object (Archer) -> calls Shoot Arrow\n        c.attack();\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Does NOT apply to Static Methods:</b> Static methods are bound at compile-time (<i>Static Dispatch</i>) based on the reference type. You cannot override static methods (only hide them).</li><li><b>Does NOT apply to Private/Final Methods:</b> These cannot be overridden, so the compiler knows exactly which method to call at compile-time (Optimization).</li><li><b>Does NOT apply to Instance Variables:</b> Data is not polymorphic. If Parent and Child both have a variable <code>int x</code>, <code>parentRef.x</code> will always access the Parent's variable, even if the object is a Child.</li><li><b>Double Dispatch:</b> In some patterns (like <b>Visitor</b>), you need to dispatch based on two object types (the visitor and the element). Java only supports <b>Single Dispatch</b> (based on the receiver object), so we simulate Double Dispatch using two method calls.</li></ul>"
    }
  ]
},
  "Immutability": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Immutability:</b> An object is Immutable if its internal state (data) cannot be modified after it is created. Once initialized, it remains constant for its entire lifecycle. If you want to change something, you must create a new object.</li></ul><br><p><b>Why use it?</b></p><ul><li><b>Thread Safety:</b> Since the state cannot change, multiple threads can access the object simultaneously without synchronization (no locking needed).</li><li><b>Hash Keys:</b> They make perfect keys for <code>HashMap</code> or <code>HashSet</code>. If the key object changed (mutable), its hashcode would change, and you would lose the value in the map.</li><li><b>Caching:</b> You can safely cache and share references without worrying that one caller will modify the data and affect others.</li></ul><br><p><b>Key Components (The Recipe):</b></p>To create an immutable class in Java:<br><ul><li><b><code>final</code> Class:</b> Prevent subclasses (which might be mutable).</li><li><b><code>private final</code> Fields:</b> Ensure fields are assigned once and not accessible directly.</li><li><b>No Setters:</b> Remove any methods that modify state.</li><li><b>Deep Copy:</b> If the class holds a Mutable object (like a <code>List</code> or <code>Date</code>), you must perform a defensive copy in the Constructor and the Getter.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Final class\npublic final class ImmutableUser {\n    \n    // 2. Private Final fields\n    private final String name;\n    private final List<String> roles; \n\n    public ImmutableUser(String name, List<String> roles) {\n        this.name = name;\n        // 3. Defensive Copy (In): Don't trust the list passed by the caller\n        this.roles = new ArrayList<>(roles);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // 4. No Setters\n    \n    public List<String> getRoles() {\n        // 5. Defensive Copy (Out): Return a copy or unmodifiable view\n        // return new ArrayList<>(roles);\n        return Collections.unmodifiableList(roles);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>String is Immutable:</b> This is the most famous example. <code>String s = \"A\"; s = \"B\";</code> does not change \"A\"; it creates a new string \"B\" and points <code>s</code> to it.</li><li><b>Shallow vs. Deep Immutability:</b><ul><li><b>Shallow:</b> The fields are final, but they point to mutable objects (e.g., an immutable <code>Student</code> class holding a mutable <code>Address</code> object). This is dangerous.</li><li><b>Deep:</b> The object and everything it points to is immutable.</li></ul></li><li><b>Memory Overhead:</b> Since you create new objects for every change, it can generate garbage (pressure on GC). However, modern GCs are very efficient at collecting short-lived objects.</li><li><b>Builder Pattern:</b> Often used to construct complex immutable objects cleanly since you can't use setters after creation.</li></ul>"
    }
  ]
},
  "Abstract Class vs Interface": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Abstract Class:</b> A class that cannot be instantiated and is used to define a base for subclasses. It represents an \"Is-A\" relationship (Identity).</li><li><b>Interface:</b> A contract that defines a set of behaviors. It represents a \"Can-Do\" relationship (Capability).</li></ul><br><p><b>Why use them? (The Choice)</b></p><ul><li><b>Use Abstract Class when:</b> You want to share code and state (variables) among closely related classes (e.g., <code>Car</code> and <code>Truck</code> sharing <code>fuelLevel</code> and <code>startEngine()</code>).</li><li><b>Use Interface when:</b> You want to define a common capability for unrelated classes (e.g., <code>Bird</code> and <code>Airplane</code> both implement <code>Flyable</code>). It enables loose coupling.</li></ul><br><p><b>Key Components (Comparison):</b></p><ul><li><b>Relationship:</b> Abstract Class is \"Is-A\" (Inheritance); Interface is \"Can-Do\" (Capability).</li><li><b>State (Fields):</b> Abstract Class can have private, protected, non-static, mutable fields. Interface has only <code>public static final</code> (Constants) and no instance state.</li><li><b>Inheritance:</b> Abstract Class supports <b>Single Inheritance</b> (extends one class). Interface supports <b>Multiple Inheritance</b> (implements many).</li><li><b>Constructors:</b> Abstract Class has constructors to initialize state. Interface cannot have constructors.</li><li><b>Access Modifiers:</b> Abstract methods can be public, protected, private. Interface methods are implicitly <code>public</code> (Java 9 allows private for internal logic).</li><li><b>Speed:</b> Abstract Class is slightly faster (direct binding). Interface is slightly slower (lookup in interface table).</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// 1. Abstract Class: Defines Identity & Shared State\nabstract class Animal {\n    String name; // State\n    \n    public Animal(String name) { this.name = name; } // Constructor\n    \n    abstract void makeSound(); // Abstract method\n    \n    void sleep() { // Concrete shared method\n        System.out.println(name + \" is sleeping.\");\n    }\n}\n\n// 2. Interface: Defines Capability\ninterface Pet {\n    void play(); // Abstract contract\n}\n\n// 3. Concrete Class: Combines both\nclass Dog extends Animal implements Pet {\n    public Dog(String name) { super(name); }\n    \n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n    \n    @Override\n    public void play() { System.out.println(\"Fetching ball\"); }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Java 8+ Blur:</b> With <code>default</code> and <code>static</code> methods in Interfaces, you can add code to interfaces. However, you still cannot have instance variables (state) in interfaces. State is the main tie-breaker.</li><li><b>Versioning:</b><ul><li>Adding a method to an <b>Interface</b> breaks all implementing classes (unless you make it <code>default</code>).</li><li>Adding a concrete method to an <b>Abstract Class</b> is safe (all children inherit it automatically).</li></ul></li><li><b>Design Rule:</b> \"Favor Interfaces over Abstract Classes\" (Item 20 in <i>Effective Java</i>). Use Abstract Classes only when you explicitly need to share variables or strictly control the hierarchy.</li><li><b>Marker Interface:</b> An interface with no methods (e.g., <code>Serializable</code>) used purely to \"mark\" a class with a specific property.</li></ul>"
    }
  ]
},
  "ER Diagrams": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>An <b>ER Diagram</b> (Entity-Relationship Diagram) is the structural blueprint of a database. It abstracts away technical details (like SQL types) to focus on the data and how it connects (the \"Nouns\" and \"Verbs\").</li></ul><br><p><b>Key Components:</b></p><ul><li><b>Entities (The Nouns):</b><ul><li><b>Strong Entity:</b> Has its own Primary Key (Identity). Symbol: Single Rectangle. (e.g., <code>Student</code>).</li><li><b>Weak Entity:</b> Depends on a \"Strong Entity\" for existence. Does not have a full PK. Symbol: Double Rectangle. (e.g., <code>Apartment</code> needs <code>Building</code>).</li><li><b>Associative Entity:</b> An entity formed by resolving a Many-to-Many relationship. (e.g., <code>Enrollment</code> connecting Student and Course).</li></ul></li><li><b>Attributes (The Adjectives):</b><ul><li><b>Key Attribute:</b> Unique ID (Primary Key). Symbol: Underlined Text.</li><li><b>Composite:</b> Can be divided into sub-parts (e.g., <code>Address</code> -> City, Zip). Physical DBs store the sub-parts.</li><li><b>Multivalued:</b> Can have multiple values (e.g., <code>PhoneNumbers</code>). Symbol: Double Oval.</li><li><b>Derived:</b> Calculated from other attributes (e.g., Age from DOB). Symbol: Dashed Oval.</li></ul></li><li><b>Relationships (The Verbs):</b><ul><li><b>Binary:</b> Between two entities (Most common).</li><li><b>Recursive (Unary):</b> An entity relates to itself (e.g., Employee manages Employee). Symbol: Line looping back to same entity.</li><li><b>Generalization (IS-A):</b> Inheritance in DBs. A Superclass (Vehicle) has Subclasses (Car, Truck). Symbol: Triangle pointing to Superclass.</li></ul></li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Cardinality & Participation (The Rules):</b></p><ul><li><b>Cardinality (Maximums - \"How many?\"):</b><ul><li><b>1:1 (One-to-One):</b> CEO manages Company.</li><li><b>1:N (One-to-Many):</b> Customer places Orders. (Most common).</li><li><b>M:N (Many-to-Many):</b> Actor acts in Movies.</li></ul></li><li><b>Participation (Minimums - \"Must they?\"):</b><ul><li><b>Total (Mandatory):</b> Every entity must be involved (e.g., Every Loan must belong to a Bank). Symbol: Double Line.</li><li><b>Partial (Optional):</b> Not every entity needs to be involved (e.g., Not every Employee manages a Department). Symbol: Single Line.</li></ul></li></ul><br><p><b>Notation Reality Check:</b></p><ul><li><b>Chen Notation:</b> Uses Diamonds & Ovals. Good for academic exams/whiteboarding.</li><li><b>Crow's Foot Notation:</b> Uses Forks & Circles. Standard for Industry LLD & SQL Tools.<br><code>||</code> (Exactly One), <code>|&lt;</code> (One or More), <code>0|</code> (Zero or One), <code>0&lt;</code> (Zero or More).</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- The M:N Trap: You cannot implement Many-to-Many in physical SQL.\n-- You must create a Join Table (Associative Entity).\n\n-- Logical: [Student] M <---> N [Course]\n\n-- Physical Implementation:\nCREATE TABLE Student (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100)\n);\n\nCREATE TABLE Course (\n    course_id INT PRIMARY KEY,\n    title VARCHAR(100)\n);\n\n-- The Associative Entity (Join Table)\nCREATE TABLE Enrollment (\n    enrollment_id INT PRIMARY KEY,\n    student_id INT,\n    course_id INT,\n    grade CHAR(1),\n    FOREIGN KEY (student_id) REFERENCES Student(student_id),\n    FOREIGN KEY (course_id) REFERENCES Course(course_id)\n);"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The M:N Trap:</b> You cannot implement a Many-to-Many relationship in a physical SQL database. You must create a <b>Join Table</b> (Associative Entity) to break it into two 1:N relationships.</li><li><b>Identifying Weak Entities:</b> Ask: \"If I delete the Parent, does this child disappear entirely and lose its identity?\" If yes, it's a <b>Weak Entity</b> (e.g., <code>InvoiceLineItem</code> inside <code>Invoice</code>).</li><li><b>Normalization:</b> ER Diagrams should typically reflect <b>3rd Normal Form (3NF)</b>. Avoid storing attributes in the wrong entity (e.g., <code>SupplierAddress</code> should be in <code>Supplier</code>, not <code>Product</code>).</li><li><b>Naming Convention:</b> Use <b>Singular Nouns</b> for Entities (<code>User</code>, not <code>Users</code>) and <b>Verbs</b> for Relationships (<code>Owns</code>, <code>Completes</code>).</li></ul>"
    },
     {
        "type": "gallery",
        "urls": [
          "images/erdiagram3.png",
          "images/erdiagram.png",
          "images/erdiagram2.png"
        ],
        "caption": ""
      }
  ]
},

  "Normalization": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Normalization</b> is the process of organizing columns and tables in a database to reduce data redundancy (duplication) and improve data integrity.</li><li>It is essentially \"Clean Code\" for Data. You break large, messy tables into smaller, focused tables and link them using relationships.</li></ul><br><p><b>Why use it? (The 3 Anomalies)</b></p>We normalize to avoid \"Anomalies\"â€”logical errors that happen when data is duplicated.<br><i>Imagine a single table: <code>Student_Course_Table</code> storing Student Name, Course Name, and Instructor Name.</i><ul><li><b>Update Anomaly:</b> If \"Professor Snape\" changes his phone number, and he teaches 100 students, you have to update 100 rows. If you miss one, your data is inconsistent.</li><li><b>Insertion Anomaly:</b> You cannot add a new Course (e.g., \"Defense Against Dark Arts\") unless a student enrolls in it, because the Primary Key includes <code>Student_ID</code>. No student = No course record.</li><li><b>Deletion Anomaly:</b> If the only student in \"History of Magic\" drops the class, you delete the row. Poof! You just lost the information that \"History of Magic\" exists as a course.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>The Normal Forms (The Steps):</b></p>There is a famous mnemonic by database pioneer Bill Kent to remember the first three rules:<br><i>\"The data depends on the Key (1NF), the Whole Key (2NF), and Nothing But the Key (3NF)... so help me Codd.\"</i><br><br><ul><li><b>First Normal Form (1NF) - \"Atomic Values\":</b><ul><li><b>Rule:</b> Every cell must hold a single value. No lists, arrays, or comma-separated strings.</li><li><b>Bad:</b> A column <code>Skills</code> containing \"Java, Python, C++\".</li><li><b>Good:</b> A separate table <code>User_Skills</code> with one row per skill.</li></ul></li><li><b>Second Normal Form (2NF) - \"No Partial Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 1NF.</li><li><b>The Issue:</b> This usually applies when you have a <b>Composite Primary Key</b> (a key made of 2+ columns).</li><li><b>Rule:</b> Non-key columns must depend on the <i>entire</i> primary key, not just part of it.</li></ul></li><li><b>Third Normal Form (3NF) - \"No Transitive Dependency\":</b><ul><li><b>Pre-requisite:</b> Must be in 2NF.</li><li><b>The Issue:</b> A non-key column depends on another non-key column.</li><li><b>Rule:</b> A column should depend <i>only</i> on the Primary Key.</li></ul></li><li><b>Boyce-Codd Normal Form (BCNF):</b> A stricter version of 3NF. It handles rare cases where a Primary Key column depends on a Non-Key column.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- 2NF Example: Fix Partial Dependency\n-- Scenario: Composite PK is (Student_ID, Course_ID)\n\n-- BAD (Violation): Student_Name depends ONLY on Student_ID, not Course_ID.\nTable Grades {\n    Student_ID (PK),\n    Course_ID (PK),\n    Student_Name, -- Partial Dependency!\n    Grade\n}\n\n-- GOOD (Normalized):\nTable Students {\n    Student_ID (PK),\n    Student_Name\n}\nTable Grades {\n    Student_ID (FK),\n    Course_ID (FK),\n    Grade\n}\n\n-- 3NF Example: Fix Transitive Dependency\n-- Scenario: PK is Order_ID\n\n-- BAD (Violation): City depends on Zip_Code, which depends on Order_ID.\n-- Chain: Order_ID -> Zip_Code -> City\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code,\n    City -- Transitive Dependency!\n}\n\n-- GOOD (Normalized):\nTable Locations {\n    Zip_Code (PK),\n    City\n}\nTable Orders {\n    Order_ID (PK),\n    Total_Amount,\n    Zip_Code (FK)\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Denormalization (The Reality Check):</b></p><ul><li>In LLD and System Design, we sometimes intentionally break these rules. This is called <b>Denormalization</b>.</li><li><b>Why?</b> Normalization requires <b>JOINS</b>. To get a User's profile, address, and recent orders in 3NF, you might need 3-4 Joins. This is slow for reading.</li><li><b>Trade-off:</b><ul><li><b>Normalized:</b> Fast Writes (no duplication to update), Slow Reads (Joins), Consistent Data.</li><li><b>Denormalized:</b> Fast Reads (Pre-joined data), Slow Writes (update everywhere), Risk of Inconsistency.</li></ul></li></ul><br><p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>3NF is the Gold Standard:</b> For most generic backend interviews and \"clean\" designs, aim for 3NF. Going to 4NF or 5NF is usually academic overkill.</li><li><b>Identifying dependencies is key:</b> Ask \"Does knowing X tell me Y?\" If knowing <code>ZipCode</code> tells you the <code>City</code>, then City is dependent on ZipCode. If ZipCode is not the Primary Key, move City out!</li><li><b>NoSQL is often Denormalized:</b> In MongoDB or Cassandra, we often store the Address object inside the User document (breaking 1NF/3NF). We accept the redundancy to avoid Joins.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/Normalization.png"
        ],
        "caption": ""
      }
  ]
},

  "Entity vs Value Object": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This is a fundamental distinction in Domain-Driven Design (DDD) regarding how we model objects based on their identity and lifecycle.</li><li><b>Entity:</b> An object defined by its <b>Identity</b> (Who it is). It has a unique ID that persists over time, even if its details change.</li><li><b>Value Object:</b> An object defined by its <b>Attributes</b> (What it looks like). It has no unique ID; it is defined strictly by the values it holds.</li></ul><br><p><b>The Analogy: \"The Person vs. The Money\"</b></p><ul><li><b>Entity (The Person):</b> Imagine you meet a friend named John. If John changes his shirt, he is still John. If you meet another person named John who looks exactly like him, they are still two different people. <i>Conclusion: You care about which specific person it is.</i></li><li><b>Value Object (The Money):</b> Imagine you have a $10 bill. If you lend it to a friend and they pay you back with a different $10 bill, do you care? No. You define it by its properties (10 USD), not its serial number.</li></ul><br><p><b>Deep Dive: Key Differences</b></p><ul><li><b>Identity:</b><ul><li><b>Entity:</b> Defined by a Unique ID (Primary Key, UUID).</li><li><b>VO:</b> Defined by its State (All fields combined).</li></ul></li><li><b>Equality Check:</b><ul><li><b>Entity:</b> <code>a == b</code> if their IDs match.</li><li><b>VO:</b> <code>a.equals(b)</code> if all fields match.</li></ul></li><li><b>Mutability:</b><ul><li><b>Entity:</b> Mutable. Its state changes over time (lifecycle).</li><li><b>VO:</b> Immutable. Once created, it never changes. To change it, you create a new one.</li></ul></li><li><b>Lifespan:</b><ul><li><b>Entity:</b> Has a history and lifecycle (Created -> Active -> Deleted).</li><li><b>VO:</b> Ephemeral. Created when needed, discarded when done.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "// Value Object (Money)\n// Notice there is no id. Equality checks the values.\npublic final class Money {\n    private final BigDecimal amount;\n    private final String currency;\n\n    public Money(BigDecimal amount, String currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n\n    // VO Logic: Equality depends on content\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Money money = (Money) o;\n        return amount.equals(money.amount) && \n               currency.equals(money.currency);\n    }\n}\n\n// Entity (Order)\n// Notice the id. Equality checks the ID.\npublic class Order {\n    private final String orderId; // Identity\n    private Money totalCost;      // Has-A Value Object\n    private String status;        // Mutable state\n\n    public Order(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public void changeStatus(String newStatus) {\n        this.status = newStatus; // Can change\n    }\n\n    // Entity Logic: Equality depends ONLY on ID\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Order order = (Order) o;\n        return orderId.equals(order.orderId);\n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Swap Test:</b> To decide between Entity vs. Value Object, ask: \"If I replace this object with another one having the exact same values, does it break my system?\"<ul><li><b>If Yes</b> (I need that specific one) -> <b>Entity</b>.</li><li><b>If No</b> (Any identical one works) -> <b>Value Object</b>.</li></ul></li><li><b>Immutability is King:</b> Value Objects should always be immutable. Do not add setters. If you need to change a coordinate (x, y) to (x+1, y), return a new <code>Point</code> object.</li><li><b>Database Mapping:</b><ul><li><b>Entities</b> usually get their own Table (Users, Orders).</li><li><b>Value Objects</b> are usually <b>Embedded</b> in the parent's table (e.g., <code>user_address_city</code>, <code>user_address_zip</code> inside the Users table) or stored as a JSON blob.</li></ul></li><li><b>Code Smell:</b> If you see a Value Object (like <code>Color</code> or <code>Date</code>) with an <code>id</code> field, something is wrong.</li></ul>"
    }
  ]
},

  "ORM Mapping": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>ORM (Object-Relational Mapping)</b> is a technique (and a software layer) that sits between your Object-Oriented code (Java/Python classes) and your Relational Database (SQL tables).</li><li>It acts as a <b>Translator</b>.<br><i>Your Code speaks \"Objects\"</i> (Inheritance, Polymorphism).<br><i>The DB speaks \"Tables\"</i> (Rows, FKs, Joins).</li><li>The ORM automatically translates \"Save User Object\" into <code>INSERT INTO users...</code> and vice versa.</li></ul><br><p><b>Why use it? (The Impedance Mismatch)</b></p>The fundamental problem ORM solves is the friction caused because the two paradigms are conceptually different:<ul><li><b>Granularity:</b> Java has nested classes (<code>Address</code> inside <code>User</code>); SQL has flat columns. ORM maps this.</li><li><b>Inheritance:</b> SQL tables don't support inheritance (e.g., Manager extends Employee). ORM simulates this strategies like Single Table.</li><li><b>Identity:</b> Java uses memory addresses/equals; SQL uses Primary Keys.</li><li><b>Relationships:</b> Java uses references (<code>user.getOrders()</code>); SQL uses Foreign Keys (<code>user_id</code>).</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Key Mapping Annotations (The \"How\" in JPA/Hibernate):</b></p><ul><li><b>Class Level:</b><ul><li><code>@Entity</code>: \"Hey ORM, treat this class as a database table.\"</li><li><code>@Table(name=\"users\")</code>: \"Map this class specifically to the <code>users</code> table.\"</li></ul></li><li><b>Field Level:</b><ul><li><code>@Id</code>: \"This is the Primary Key.\"</li><li><code>@GeneratedValue</code>: \"Auto-increment this ID.\"</li><li><code>@Column(name=\"email_addr\")</code>: \"Map the email field to the <code>email_addr</code> column.\"</li><li><code>@Transient</code>: \"Ignore this field. Do not store it in the DB.\"</li></ul></li><li><b>Relationship Level:</b><ul><li><code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>: Defines the association logic.</li></ul></li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity // 1. Mark as ORM Object\n@Table(name = \"employees\")\npublic class Employee {\n\n    @Id // 2. Primary Key\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    // 3. Mapping a Relationship\n    // \"Many Employees belong to One Department\"\n    @ManyToOne(fetch = FetchType.LAZY) \n    @JoinColumn(name = \"dept_id\") // The Foreign Key column in 'employees' table\n    private Department department;\n\n    // Standard Getters/Setters...\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The N+1 Problem (Performance Killer):</b><ul><li><b>Scenario:</b> You fetch 100 <code>Department</code> objects. Then you loop through them and call <code>dept.getEmployees()</code> for each one.</li><li><b>What happens:</b> 1 Query to get Departments + 100 Queries (one per department) to get their employees = 101 Queries.</li><li><b>Fix:</b> Use \"Join Fetch\" (eagerly load data in the initial query using a JOIN) or Entity Graphs.</li></ul></li><li><b>Lazy vs. Eager Loading:</b><ul><li><b>Eager:</b> \"Bring the Jungle.\" When you fetch the User, the ORM effectively does a JOIN and fetches all their Orders immediately.</li><li><b>Lazy:</b> \"Bring the Banana.\" When you fetch User, the Orders list is just a proxy (empty placeholder). The DB query fires only when you touch <code>user.getOrders()</code>. <b>Best Practice:</b> Prefer Lazy loading.</li></ul></li><li><b>Caching (L1 vs L2):</b><ul><li><b>Level 1 (Session Cache):</b> Default. Within a single transaction, if you ask for User ID #1 twice, the ORM returns it from memory the second time.</li><li><b>Level 2 (Global Cache):</b> Optional (e.g., Redis). Shared across all users/sessions. Good for read-heavy, static data.</li></ul></li><li><b>Dirty Checking:</b> You don't always need to call <code>repository.save(user)</code>. If you modify a fetched object inside a <code>@Transactional</code> block, the ORM automatically detects the change and fires the UPDATE query when the transaction ends.</li></ul>"
    },
    {
        "type": "gallery",
        "urls": [
          "images/ormmapping.png"
        ],
        "caption": ""
      }
  ]
},
  "Lazy vs Eager": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li>This concept dictates <i>when</i> related data is fetched from the database.</li><li><b>Eager Loading:</b> Fetches the main entity and its related entities immediately in a single go (usually via a massive JOIN).</li><li><b>Lazy Loading:</b> Fetches only the main entity. The related entities are fetched on-demand, only when you explicitly access them in your code.</li></ul><br><p><b>The Analogy: \"Moving Houses\"</b></p><ul><li><b>Eager Loading (The Over-Packer):</b> You move to a new house and pack everything you own (winter coats, old yearbooks, kitchen sink) into the truck immediately.<br><i>Pros:</i> Everything is there if you need it.<br><i>Cons:</i> The truck is heavy, slow, and you might not look at those old yearbooks for 5 years. Wasted effort.</li><li><b>Lazy Loading (The Minimalist):</b> You move with just your essentials (bed, clothes). You leave the rest in storage.<br><i>Pros:</i> The move is fast and light.<br><i>Cons:</i> If you suddenly decide you need your \"High School Yearbook,\" you have to drive back to storage (make another DB trip) to get it.</li></ul>"
    },
    {
      "type": "text",
      "content": "<p><b>Mechanics: How it works (The Proxy)</b></p><ul><li>How does Java know to fetch data later? <b>Proxies.</b></li><li>When you Lazy load a User's orders, Hibernate doesn't give you a <code>List&lt;Order&gt;</code>. It gives you a <b>Proxy Object</b> (a placeholder/stub).</li><li>This Proxy looks like a list, but it's empty.</li><li><b>The Trigger:</b> The moment you call <code>user.getOrders().size()</code> or access the data, the Proxy \"wakes up,\" fires a SQL query to the database, fills itself with real data, and then gives it to you.</li></ul>"
    },
    {
      "type": "code",
      "language": "java",
      "content": "@Entity\npublic class User {\n    @Id\n    private Long id;\n\n    // EAGER: \"I want the Profile immediately when I get the User\"\n    // Result: SELECT * FROM User LEFT JOIN Profile ...\n    @OneToOne(fetch = FetchType.EAGER)\n    private Profile profile;\n\n    // LAZY: \"Don't fetch Orders yet. Just give me a placeholder.\"\n    // Result: SELECT * FROM User ... (No Orders yet)\n    @OneToMany(fetch = FetchType.LAZY) \n    private List<Order> orders;\n}\n\n// Usage\nclass Main {\n    void test(EntityManager em) {\n        User u = em.find(User.class, 1L); // Query 1 fires here (User + Profile)\n        \n        System.out.println(u.getProfile().getBio()); // No new query (Already loaded)\n        \n        System.out.println(\"Wait for it...\");\n        \n        // Query 2 fires HERE (The \"Lazy Initialization\")\n        System.out.println(u.getOrders().size()); \n    }\n}"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>The Defaults (Memorize this):</b> JPA has default settings based on cardinality.<ul><li><code>@OneToOne</code>, <code>@ManyToOne</code> (Single Association) -> Default is <b>EAGER</b>.</li><li><code>@OneToMany</code>, <code>@ManyToMany</code> (Collection Association) -> Default is <b>LAZY</b>.</li><li><i>Tip:</i> Always explicitly set <code>@ManyToOne(fetch = FetchType.LAZY)</code>. Eager loading is almost always a performance trap in large apps.</li></ul></li><li><b>LazyInitializationException:</b> This is the most common error in Hibernate.<ul><li><b>Cause:</b> You fetched a Lazy entity, closed the Database Session (Transaction ended), and <i>then</i> tried to access the lazy data.</li><li><b>Result:</b> The Proxy tries to go back to the DB, finds the connection closed, and crashes.</li><li><b>Fix:</b> Keep the transaction open (using <code>@Transactional</code>) or use \"Join Fetch\".</li></ul></li><li><b>When to use which?</b><ul><li><b>Use Eager:</b> When you are 100% sure you will use the related data every single time you load the parent (e.g., User and UserPreferences).</li><li><b>Use Lazy:</b> For everything else. Especially for Lists/Collections. Loading 5000 Orders just to check a User's name is a disaster.</li></ul></li></ul>"
    }
  ]
},

  "Schema Evolution": {
  "blocks": [
    {
      "type": "text",
      "content": "<p><b>Core Concept:</b></p><ul><li><b>Schema Evolution</b> is the process of managing changes to your database structure (tables, columns, types) over time as your application requirements change.</li><li>It is the art of \"Changing the tires on a moving car.\" You need to upgrade the database without crashing the application or losing data.</li></ul><br><p><b>Why use it? (The Challenge)</b></p><ul><li><b>Agile Development:</b> Requirements change. You need a new <code>is_verified</code> column today that you didn't need yesterday.</li><li><b>Zero Downtime:</b> In modern systems, you cannot just shut down the server. The old code and the new database schema must often coexist during deployment.</li><li><b>Compatibility:</b> You must ensure Backward Compatibility (New DB works with Old Code) and Forward Compatibility (Old DB works with New Code).</li></ul><br><p><b>The Strategy: Expand and Contract (Parallel Change)</b></p><ul><li>This is the Gold Standard pattern for safe schema evolution without downtime. It involves multiple small steps instead of one big \"Rename\" or \"Delete\".</li><li><b>Scenario:</b> Rename <code>full_name</code> to <code>display_name</code>.</li><li><b>Steps:</b><ol><li><b>Expand (Add):</b> Add <code>display_name</code> (nullable). DB has both.</li><li><b>Dual Write:</b> Deploy code that writes to both, but reads from old.</li><li><b>Backfill:</b> Copy data from old to new.</li><li><b>Switch Read:</b> Deploy code that reads from new.</li><li><b>Contract (Remove):</b> Stop writing to old. Remove old column.</li></ol></li></ul><br><p><b>Tools of the Trade:</b></p><ul><li><b>Flyway / Liquibase:</b> Version control tools for your database. They use a hidden table (<code>schema_version</code>) to track which scripts have run.</li></ul>"
    },
    {
      "type": "code",
      "language": "sql",
      "content": "-- File: V2__split_name_column.sql\n\n-- 1. Add new columns (Allow NULLs initially to prevent locking/errors)\nALTER TABLE users ADD COLUMN first_name VARCHAR(50);\nALTER TABLE users ADD COLUMN last_name VARCHAR(50);\n\n-- 2. Migrate existing data (The Backfill)\n-- Ideally, do this in batches for large tables to avoid locking\nUPDATE users SET first_name = SPLIT_PART(full_name, ' ', 1),\n    last_name = SPLIT_PART(full_name, ' ', 2);\n\n-- 3. Add constraints (After data is safe)\n-- ALTER TABLE users ALTER COLUMN first_name SET NOT NULL;"
    },
    {
      "type": "text",
      "content": "<p><b>Important Things to Remember (LLD Perspective):</b></p><ul><li><b>Never Rename Columns directly:</b> <code>RENAME COLUMN</code> is a destructive action. The code looking for \"old\" will instantly crash. Use Expand & Contract.</li><li><b>Locking & Performance:</b> Adding a column with a <code>DEFAULT</code> value (in older DB versions) can lock the entire table. <b>Fix:</b> Add as <code>NULL</code> first -> Populate -> Add <code>NOT NULL</code> constraint.</li><li><b>Deprecation Phase:</b> If you delete a column, ensure the code has stopped using it for at least one full deployment cycle.</li><li><b>NoSQL is easier (but messier):</b> In MongoDB, you don't need migrations. You can have Document A with <code>name</code> and Document B with <code>firstName</code>. The complexity moves from the Database to the Application Code.</li></ul>"
    }
  ]
}



  
}















